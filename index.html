<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link
      rel="apple-touch-icon"
      href="https://i.postimg.cc/CMZqNMRh/IMG-6497.jpg"
    />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <title>EPhone</title>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <style>
      @font-face {
        font-family: "bulangni";
        src: url("") format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }
      :root {
        --screen-width: 350px;
        --screen-height: 650px;
        --secondary-bg: #ffffff;
        --border-color: #e0e0e0;
        --text-primary: #1f1f1f;
        --text-secondary: #8a8a8a;
        --accent-color: #007bff;
      }
      html {
        height: 100%;
        overflow: hidden;
      }
      body {
        height: 100%;
        overflow: hidden;
        margin: 0;
        padding: 20px;
        font-family: "bulangni", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Helvetica, Arial, sans-serif;
        font-weight: normal;
        background-color: #dcdcdc;
        display: flex;
        justify-content: center;
        align-items: center;
        box-sizing: border-box;
        transition: background-color 0.3s ease;
      }
      body.dark-mode {
        background-color: #121212;
      }
      #phone-frame {
        padding: 12px;
        background-color: #fff;
        border-radius: 50px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.25),
          inset 0 2px 4px rgba(0, 0, 0, 0.1);
        position: relative;
        transition: background-color 0.3s ease;
      }
      body.dark-mode #phone-frame {
        background-color: #2a2a2a;
        box-shadow: 0 0 25px rgba(220, 235, 255, 0.18),
          0 0 100px rgba(220, 235, 255, 0.1),
          0 0 0 1px rgba(255, 255, 255, 0.1),
          0 40px 80px rgba(0, 0, 0, 0.95),
          inset 0 1px 2px rgba(255, 255, 255, 0.2);
      }
      .notch {
        position: absolute;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        width: 130px;
        height: 28px;
        background-color: #1f1f1f;
        border-radius: 0 0 15px 15px;
        z-index: 20;
      }
      #phone-screen {
        width: var(--screen-width);
        height: var(--screen-height);
        background-color: #000;
        border-radius: 40px;
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        border: 2px solid #333;
      }
      #status-bar {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        padding: 12px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: white;
        z-index: 10;
        font-size: 14px;
        box-sizing: border-box;
        pointer-events: none;
      }
      #status-bar-time {
        font-weight: 600;
      }
      .battery-container {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .battery-icon {
        width: 25px;
        height: 12px;
        border: 1px solid white;
        border-radius: 3px;
        position: relative;
        padding: 1px;
      }
      .battery-icon::after {
        content: "";
        position: absolute;
        right: -3px;
        top: 2px;
        width: 2px;
        height: 6px;
        background-color: white;
        border-radius: 0 1px 1px 0;
      }
      .battery-level {
        height: 100%;
        background-color: white;
        border-radius: 1px;
        transition: width 0.5s ease;
      }
      .battery-container.charging .battery-level {
        background-color: #4cd964;
        animation: charge-breath 2s infinite;
      }
      .battery-container.charging .battery-text {
        color: #4cd964;
      }
      @keyframes charge-breath {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }
      .screen {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
      }
      .screen.active {
        opacity: 1;
        visibility: visible;
        z-index: 1;
      }
      .header {
        position: relative;
        z-index: 15;
        flex-shrink: 0;
        padding: 15px 20px;
        padding-top: 45px;
        background-color: rgba(247, 247, 247, 0.8);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 18px;
        font-weight: 600;
      }
      .header .header-actions {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      .header .back-btn,
      .header .action-btn {
        font-size: 24px;
        cursor: pointer;
        width: 30px;
        text-align: center;
        color: var(--accent-color);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .header .action-btn {
        width: auto;
        min-width: 30px;
        white-space: nowrap;
        font-size: 16px; /* 专门为“上传”、“+”等文字按钮缩小字号 */
        font-weight: 600; /* 可以加粗一点让它更清晰 */
      }

      .header .action-btn img {
        height: 26px;
      }
      .header .save-btn {
        font-size: 16px;
        color: var(--accent-color);
        font-weight: 600;
        cursor: pointer;
      }
      #home-screen {
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        padding: 20px;
        padding-top: 80px;
        padding-bottom: 50px;
        box-sizing: border-box;
        background-size: cover;
        background-position: center;
      }
      #clock-container {
        text-align: center;
        color: white;
        text-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
        margin-bottom: 20px;
        flex-shrink: 0;
      }
      #main-time {
        font-size: 80px;
        font-weight: 200;
      }
      #main-date {
        font-size: 18px;
        font-weight: 500;
      }
      #app-grid {
        margin-top: auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        width: 100%;
        padding: 20px;
      }
      .app-row {
        display: flex;
        justify-content: center;
        gap: 25px;
        width: 100%;
      }
      .app-icon {
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        color: white;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        font-size: 14px;
        font-weight: 500;
        text-align: center;
      }
      .app-icon .icon-bg {
        width: 65px;
        height: 65px;
        border-radius: 18px;
        background-color: var(--secondary-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 32px;
        margin-bottom: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        transition: transform 0.2s ease;
        overflow: hidden;
      }
      .app-icon:active .icon-bg {
        transform: scale(0.9);
      }
      .app-icon .icon-bg img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .app-icon .label {
        color: white;
      }
      .form-container,
      .list-container {
        padding: 20px;
        overflow-y: auto;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
      }
      .form-group {
        margin-bottom: 20px;
      }
      .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
        color: var(--text-secondary);
      }
      .form-group input,
      .form-group select,
      .form-group textarea {
        width: 100%;
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-size: 16px;
        box-sizing: border-box;
      }
      .form-group textarea {
        min-height: 80px;
        resize: vertical;
      }
      #world-book-content-input {
        height: calc(100% - 120px);
      }
      .form-button {
        width: 100%;
        padding: 15px;
        background-color: var(--accent-color);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        margin-top: 10px;
      }
      .form-button-secondary {
        background-color: #f0f0f0;
        color: var(--text-primary);
        border: 1px solid var(--border-color);
      }
      #wallpaper-screen .form-container {
        align-items: center;
      }
      #wallpaper-preview {
        width: 180px;
        height: 320px;
        border: 2px dashed var(--border-color);
        background-color: #f0f2f5;
        margin-bottom: 20px;
        background-size: cover;
        background-position: center;
        border-radius: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        color: var(--text-secondary);
      }
      #wallpaper-upload-input {
        display: none;
      }
      /* 修改后的 #world-book-list 样式 */
      #world-book-list {
        flex-grow: 1;
        overflow-y: auto;
        background-color: var(--secondary-bg);
        padding-top: 80px;
        margin-top: -80px;
      }

      /* 修改后的 #chat-list 样式，去掉了 padding 和 margin */
      #chat-list {
        flex-grow: 1;
        background-color: var(--secondary-bg);
        padding-top: 80px;
        padding-bottom: 50px; /* 为底部导航栏留出空间 */
        box-sizing: border-box;
      }

      .list-item {
        display: flex;
        flex-direction: column;
        padding: 12px 20px;
        cursor: pointer;
        border-bottom: 1px solid var(--border-color);
      }
      .list-item:hover {
        background-color: #f5f5f5;
      }
      .list-item .item-title {
        font-weight: 500;
        font-size: 16px;
        margin-bottom: 5px;
      }
      .list-item .item-content {
        font-size: 14px;
        color: var(--text-secondary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .chat-list-item {
        display: flex;
        align-items: center;
        padding: 10px 15px;
        cursor: pointer;
        border-bottom: 1px solid var(--border-color);
        position: relative;
      }
      .chat-list-item:hover {
        background-color: #f5f5f5;
      }
      .chat-list-item .avatar {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        margin-right: 12px;
        object-fit: cover;
        background-color: #ccc;
      }
      .chat-list-item .info {
        flex-grow: 1;
        overflow: hidden;
      }
      .chat-list-item .name-line {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 2px;
      }
      .chat-list-item .name {
        font-weight: 500;
        color: var(--text-primary);
      }
      .chat-list-item .group-tag {
        font-size: 10px;
        color: var(--accent-color);
        background-color: #e7f3ff;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: bold;
        flex-shrink: 0;
      }
      .chat-list-item .last-msg {
        font-size: 13px;
        color: var(--text-secondary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 180px;
      }
      #chat-interface-screen {
        background-size: cover;
        background-position: center;
        position: relative;
      }
      #selection-cancel-btn,
      #selection-delete-btn {
        font-size: 16px;
        color: var(--accent-color);
        cursor: pointer;
        padding: 5px;
      }
      #selection-delete-btn {
        color: #ff3b30;
      }

      /* ▼▼▼ 用这块代码替换掉你原来的 #chat-messages 样式 ▼▼▼ */
      #chat-messages {
        flex-grow: 1;
        overflow-y: auto;
        overflow-x: hidden; /* 核心修正1: 强制禁止水平滚动/拖动 */
        padding: 10px 15px; /* 核心修正2: 将左右内边距增加到15px，提供更多呼吸空间 */
        padding-top: 110px;
        margin-top: -80px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        box-sizing: border-box; /* 确保内边距计算正确 */
      }
      /* ▲▲▲ 替换结束 ▲▲▲ */
      #load-more-btn {
        text-align: center;
        padding: 10px;
        color: var(--accent-color);
        font-size: 14px;
        cursor: pointer;
        background-color: transparent;
        border: none;
        width: 100%;
      }
      #load-more-btn:hover {
        text-decoration: underline;
      }

      .sender-name {
        font-size: 11px;
        color: #666;
        margin-bottom: 3px;
      }

      .message-wrapper.ai .sender-name {
        margin-left: 50px; /* 稍微调整，与头像对齐 */
        margin-bottom: 3px;
        position: absolute; /* 让它脱离流，避免影响气泡对齐 */
        top: -16px; /* 定位到气泡上方 */
        left: 0;
      }

      /* === 【全新】消息布局与时间戳样式 === */

      /* 1. 消息单元的总容器 (重构) */
      .message-wrapper {
        display: flex; /* 使用Flex布局 */
        gap: 8px; /* 气泡和时间戳之间的间距 */
        align-items: flex-end; /* 核心：让气泡和时间戳底部对齐 */
        position: relative;
        max-width: 90%; /* 可以稍微放宽一点，因为时间戳现在在外面了 */
      }

      /* 2. AI消息单元靠左 */
      .message-wrapper.ai {
        align-self: flex-start;
        flex-direction: row; /* 头像、气泡、时间戳，从左到右排列 */
      }

      /* 3. 用户消息单元靠右 */
      .message-wrapper.user {
        align-self: flex-end;
        flex-direction: row-reverse; /* 时间戳、气泡、头像，从右到左排列 */
      }

      /* 4. 气泡和头像的直接容器 (保持不变) */
      .message-bubble {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        max-width: 100%;
      }

      .timestamp {
        /* 移除旧的 position: absolute */
        font-size: 11px;
        color: #999;
        text-shadow: 0 0 3px rgba(255, 255, 255, 0.6);
        white-space: nowrap; /* 防止时间换行 */
        margin-bottom: 5px; /* 让它和气泡底部有轻微的对齐偏移，更美观 */
        flex-shrink: 0; /* 防止被压缩 */
      }

      .message-bubble.selected::after {
        content: "✔";
        position: absolute;
        left: -10px;
        top: 50%;
        transform: translateY(-50%);
        background-color: var(--accent-color);
        color: white;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
      }
      .message-bubble.user.selected::after {
        left: auto;
        right: -10px;
      }

      .message-bubble.user {
        flex-direction: row-reverse;
      }
      #typing-indicator {
        align-self: flex-start;
        display: none;
        margin: 0 10px 10px;
        color: var(--text-secondary);
      }
      #chat-input-area {
        flex-shrink: 0;
        padding: 8px;
        background-color: rgba(247, 247, 247, 0.8);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-top: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      #chat-input-main-row {
        display: flex;
        align-items: flex-end;
        gap: 8px;
        width: 100%;
      }
      #chat-input {
        flex-grow: 1;
        border: none;
        padding: 10px 15px;
        border-radius: 20px;
        background-color: var(--secondary-bg);
        font-size: 16px;
        max-height: 100px;
        resize: none;
      }
      .action-button {
        border: none;
        color: white;
        border-radius: 20px;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
        flex-shrink: 0;
      }
      #send-btn {
        background-color: var(--accent-color);
        height: 40px;
        padding: 0 15px;
      }
      .modal {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 100;
      }
      .modal.visible {
        display: flex;
      }
      .modal-content {
        width: 90%;
        max-height: 90%;
        background-color: white;
        border-radius: 15px;
        display: flex;
        flex-direction: column;
      }
      .modal-header {
        padding: 15px;
        font-weight: 600;
        border-bottom: 1px solid var(--border-color);
        text-align: center;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .modal-body {
        padding: 15px;
        overflow-y: auto;
      }
      .modal-footer {
        padding: 15px;
        border-top: 1px solid var(--border-color);
        display: flex;
        justify-content: space-around;
      }
      .modal-footer button {
        width: 45%;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid var(--accent-color);
        cursor: pointer;
        font-size: 16px;
      }
      .modal-footer .save {
        background-color: var(--accent-color);
        color: white;
      }
      .modal-footer .cancel {
        background-color: white;
        color: var(--accent-color);
      }
      .avatar-upload {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      .avatar-upload img {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        object-fit: cover;
        background-color: #eee;
      }
      .avatar-upload button {
        padding: 8px 12px;
        border: 1px solid #ccc;
        background-color: #f0f0f0;
        border-radius: 5px;
        cursor: pointer;
      }
      #open-persona-library-btn {
        font-size: 14px;
        padding: 6px 10px;
        margin-left: 0;
      }
      .avatar-upload input[type="file"] {
        display: none;
      }
      .theme-selector label {
        display: inline-flex;
        align-items: center;
        margin-right: 15px;
        margin-bottom: 5px;
        cursor: pointer;
      }
      #reset-theme-btn {
        background: none;
        border: 1px solid #ccc;
        color: #555;
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 5px;
        cursor: pointer;
        margin-left: 10px;
      }
      #group-members-settings {
        display: flex;
        overflow-x: auto;
        padding-bottom: 10px;
        gap: 15px;
      }
      .member-editor {
        text-align: center;
        cursor: pointer;
      }
      .member-editor img {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        object-fit: cover;
        background-color: #eee;
        margin-bottom: 5px;
      }
      .member-editor .member-name {
        font-size: 12px;
      }
      #notification-bar {
        position: absolute;
        top: 40px;
        left: 50%;
        width: 90%;
        z-index: 500;
        background-color: rgba(250, 250, 250, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 16px;
        padding: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
        transform: translateX(-50%) translateY(-150%);
        transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        visibility: hidden;
      }
      #notification-bar.visible {
        /* 关键：在Y轴回到原位的同时，保持X轴的居中变换 */
        transform: translateX(-50%) translateY(0);
        visibility: visible;
      }
      #notification-avatar {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        object-fit: cover;
      }
      #notification-content .name {
        font-weight: 600;
        font-size: 15px;
        color: #000;
      }
      #notification-content .message {
        font-size: 14px;
        color: #555;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 200px;
      }
      .sticker-image {
        max-width: 100px;
        max-height: 100px;
        display: block;
        object-fit: contain;
      }
      .message-bubble.is-sticker .content,
      .message-bubble.is-voice-message .content {
        padding: 0;
        background-color: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }
      #chat-input-actions-top {
        display: flex;
        gap: 8px;
        padding: 0 5px;
      }
      .chat-action-icon-btn {
        font-size: 24px;
        padding: 0;
        width: 38px;
        height: 38px;
        line-height: 38px;
        text-align: center;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.5);
        color: var(--text-primary);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        border: 1px solid rgba(0, 0, 0, 0.05);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #sticker-panel {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 50%;
        background-color: rgba(242, 242, 247, 0.85);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-top: 1px solid var(--border-color);
        border-radius: 20px 20px 0 0;
        z-index: 200;
        display: flex;
        flex-direction: column;
        transform: translateY(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        visibility: hidden;
      }
      #sticker-panel.visible {
        transform: translateY(0);
        visibility: visible;
      }
      #sticker-panel-header {
        padding: 10px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        border-bottom: 1px solid var(--border-color);
      }
      #sticker-panel-header .title {
        font-weight: 600;
      }
      #sticker-panel-header .panel-btn {
        font-size: 16px;
        padding: 5px 10px;
        cursor: pointer;
        color: var(--accent-color);
      }
      #sticker-grid {
        flex-grow: 1;
        overflow-y: auto;
        padding: 15px;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 15px;
      }
      .sticker-item {
        position: relative;
        aspect-ratio: 1 / 1;
        background-color: white;
        border-radius: 10px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }
      .sticker-item .delete-btn {
        display: none;
        position: absolute;
        top: -5px;
        right: -5px;
        width: 20px;
        height: 20px;
        background-color: #ff3b30;
        color: white;
        border-radius: 50%;
        text-align: center;
        line-height: 20px;
        font-size: 14px;
        cursor: pointer;
        border: 2px solid white;
      }
      #input-actions-wrapper {
        position: static;
        display: flex;
        align-items: flex-end;
        gap: 8px;
        flex-shrink: 0;
      }
      #wait-reply-btn {
        position: static;
        bottom: auto;
        right: auto;
        width: auto;
        height: 40px;
        padding: 0 10px;
        border-radius: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(255, 255, 255, 0.6);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        border: 1px solid rgba(0, 0, 0, 0.08);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        transition: opacity 0.2s, transform 0.1s;
        cursor: pointer;
      }
      #wait-reply-btn:hover {
        opacity: 0.8;
      }
      #wait-reply-btn:active {
        transform: scale(0.9);
      }
      #wait-reply-btn img {
        height: 22px;
        display: block;
        margin: auto;
      }
      .chat-image {
        max-width: 100%;
        border-radius: 10px;
        display: block;
      }
      .message-bubble.has-image .content {
        padding: 5px;
      }
      #custom-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
      }
      #custom-modal-overlay.visible {
        display: flex;
        opacity: 1;
      }
      #custom-modal {
        background-color: #fff;
        width: 280px;
        border-radius: 14px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        transform: scale(0.95);
        transition: transform 0.2s ease-in-out;
      }
      #custom-modal-overlay.visible #custom-modal {
        transform: scale(1);
      }
      .custom-modal-header {
        padding: 16px;
        font-size: 17px;
        font-weight: 600;
        text-align: center;
      }
      .custom-modal-body {
        padding: 0 16px 16px;
        text-align: center;
        font-size: 14px;
        color: #333;
        line-height: 1.5;
      }
      .custom-modal-body p {
        margin: 0;
        margin-bottom: 12px;
      }
      .custom-modal-body input {
        width: 100%;
        padding: 8px;
        border-radius: 6px;
        border: 1px solid #ccc;
        font-size: 14px;
        box-sizing: border-box;
      }
      .custom-modal-footer {
        border-top: 1px solid #dbdbdb;
        display: flex;
      }
      .custom-modal-footer button {
        flex: 1;
        background: none;
        border: none;
        padding: 12px;
        font-size: 17px;
        cursor: pointer;
        color: var(--accent-color);
      }
      .custom-modal-footer button:first-child {
        border-right: 1px solid #dbdbdb;
      }
      .custom-modal-footer .confirm-btn {
        font-weight: 600;
      }
      .custom-modal-footer .confirm-btn.btn-danger {
        color: #ff3b30;
      }
      #preset-actions-modal .custom-modal-footer {
        flex-direction: column;
      }
      #preset-actions-modal .custom-modal-footer button {
        width: 100%;
        border: none;
        border-bottom: 1px solid #dbdbdb;
        padding: 14px;
        font-size: 18px;
      }
      #preset-actions-modal .custom-modal-footer button:last-child {
        border-bottom: none;
      }
      .custom-multiselect {
        position: relative;
        user-select: none;
      }
      .select-box {
        display: flex;
        align-items: center;
        width: 100%;
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-size: 16px;
        box-sizing: border-box;
        background-color: #fff;
        cursor: pointer;
      }
      .select-box .selected-options-text {
        flex-grow: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: var(--text-primary);
      }
      .select-box .arrow-down {
        margin-left: auto;
        font-size: 10px;
        color: var(--text-secondary);
        transition: transform 0.2s;
      }
      .select-box.expanded .arrow-down {
        transform: rotate(180deg);
      }

      .checkboxes-container {
        display: none;
        position: absolute;
        /* 核心修改：不再使用 top，而是用 margin-top 来创造间距，更稳定 */
        top: 100%;
        margin-top: 5px; /* <-- 新增：向下推开5像素的距离 */
        left: 0;
        right: 0;
        max-height: 150px;
        overflow-y: auto;
        overflow-x: hidden;
        background-color: #fff;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        z-index: 101;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .checkboxes-container.visible {
        display: block;
      }
      .checkboxes-container label {
        display: block;
        padding: 10px 12px;
        cursor: pointer;
        font-weight: normal;
        color: var(--text-primary);
      }

      .checkboxes-container label {
        display: block;
        padding: 12px 15px; /* <-- 修改：增加了上下和左右的内边距，让每一行更高更宽 */
        cursor: pointer;
        font-weight: normal;
        color: var(--text-primary);
        font-size: 15px; /* <-- 新增：将字体大小从默认值放大到15px */
      }

      .checkboxes-container input {
        margin-right: 10px;
        vertical-align: middle;
      }
      .bg-upload-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 8px;
        flex-wrap: wrap;
      }
      .bg-preview-img {
        max-width: 120px;
        max-height: 80px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        object-fit: cover;
        display: none;
      }
      #remove-bg-btn {
        padding: 8px 12px;
        border: 1px solid #ff3b30;
        color: #ff3b30;
        background-color: #fff;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        display: none;
      }
      .message-bubble.is-ai-image .content {
        padding: 5px;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }
      .ai-generated-image {
        max-width: 180px;
        border-radius: 12px;
        display: block;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      }
      .ai-generated-image:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }
      .voice-message-body {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        cursor: pointer;
        padding: 10px 14px;
        min-width: 60px;
        height: 22px;
        border-radius: 4px;
        position: relative;
        box-shadow: 0 1px 1px rgba(0,0,0,0.1);
        gap: 4px;
      }
      .message-bubble.user .voice-message-body {
        background-color: #2BA245;
        color: #000;
      }
      .message-bubble.ai .voice-message-body {
        background-color: #FFFFFF;
        color: #000;
        flex-direction: row-reverse;
        justify-content: flex-end;
      }
      #phone-screen.dark-mode .message-bubble.ai .voice-message-body {
        background-color: #2C2C2E;
        color: #FFF;
      }

      .voice-message-body::after {
        content: "";
        position: absolute;
        top: 12px;
        width: 0;
        height: 0;
        border-style: solid;
      }
      .message-bubble.user .voice-message-body::after {
        right: -6px;
        border-width: 6px 0 6px 8px;
        border-color: transparent transparent transparent #2BA245;
      }
      .message-bubble.ai .voice-message-body::after {
        left: -6px;
        border-width: 6px 8px 6px 0;
        border-color: transparent #FFFFFF transparent transparent;
      }
      #phone-screen.dark-mode .message-bubble.ai .voice-message-body::after {
        border-color: transparent #2C2C2E transparent transparent;
      }

      .voice-duration {
        font-size: 15px;
        font-weight: 400;
        color: inherit;
        margin: 0 4px;
      }

      .wave-icon {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .wave-icon svg {
        stroke: currentColor;
        fill: currentColor;
      }
      .message-bubble.ai .wave-icon {
        transform: scaleX(-1);
      }

      .wave-icon.playing .wave-path-1 { animation: wave-fade 1s infinite 0.4s; }
      .wave-icon.playing .wave-path-2 { animation: wave-fade 1s infinite 0.2s; }
      .wave-icon.playing .wave-path-3 { animation: wave-fade 1s infinite 0s; }

      @keyframes wave-fade {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.2; }
      }

      .voice-transcript {
        background-color: #1A1A1A;
        color: #FFFFFF;
        padding: 10px 12px;
        border-radius: 6px;
        font-size: 15px;
        line-height: 1.5;
        position: relative;
        text-align: justify;
        margin-top: 8px;
        display: none;
        word-break: break-word;
      }
      .voice-transcript::before {
        content: "";
        position: absolute;
        top: -6px;
        width: 0;
        height: 0;
        border-style: solid;
        border-width: 0 6px 8px 6px;
        border-color: transparent transparent #1A1A1A transparent;
      }
      .message-bubble.user .voice-transcript::before {
        right: 14px;
      }
      .message-bubble.ai .voice-transcript::before {
        left: 14px;
      }

      /* ▼▼▼ 用这块代码替换掉你原来的 .message-bubble .content 样式 ▼▼▼ */
      /* 通用内容区样式，为时间戳和字体大小做准备 */
      .message-bubble .content {
        position: relative;
        font-size: var(--chat-font-size, 16px);
        padding: 8px 12px;
        line-height: 1.5;
        word-break: break-word; /* 核心修正: 强制长单词或URL换行，防止撑破气泡 */
      }
      /* ▲▲▲ 替换结束 ▲▲▲ */

      /* === 气泡主题样式 === */
      .message-bubble.user .content {
        background-color: rgba(255, 255, 255, 0.75);
        color: #585858;
        border-radius: 8px 2px 8px 8px;
      }
      .message-bubble.ai .content {
        background-color: rgba(255, 255, 255, 0.7);
        color: #585858;
        border-radius: 2px 8px 8px 8px;
      }

      .message-bubble::after {
        content: "";
        position: absolute;
        width: 20px;
        height: 20px;
        background-size: contain;
        background-repeat: no-repeat;
        opacity: 1;
        z-index: 1;
      }

      #chat-messages[data-theme="pink_blue"] .message-bubble.user .content {
        background-color: #fff0f6;
        color: #432531;
      }
      #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content {
        background-color: #eff7ff;
        color: #263a4e;
      }
      #chat-messages[data-theme="blue_white"] .message-bubble.user .content {
        background-color: #eff7ff;
        color: #263a4e;
      }
      #chat-messages[data-theme="blue_white"] .message-bubble.ai .content {
        background-color: #f8f9fa;
        color: #383d41;
      }
      #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content {
        background-color: #faf7ff;
        color: #827693;
      }
      #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content {
        background-color: #fffde4;
        color: #5c4033;
      }
      #chat-messages[data-theme="black_white"] .message-bubble.user .content {
        background-color: #343a40;
        color: #f8f9fa;
      }
      #chat-messages[data-theme="black_white"] .message-bubble.ai .content {
        background-color: #f8f9fa;
        color: #343a40;
      }
      #chat-messages[data-theme="yellow_white"] .message-bubble.user .content {
        background-color: #ffeb3b;
        color: #5d4037;
      }
      #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content {
        background-color: #f8f9fa;
        color: #383d41;
      }
      #chat-messages[data-theme="red_black"] .message-bubble.user .content {
        background-color: #c62828;
        color: #ffffff;
      }
      #chat-messages[data-theme="red_black"] .message-bubble.ai .content {
        background-color: #212121;
        color: #ffffff;
      }
      #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content {
        background-color: #a0d2eb;
        color: #153243;
      }
      #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content {
        background-color: #fef9e7;
        color: #5d4037;
      }
      #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content {
        background-color: #fff0f6;
        color: #432531;
      }
      #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content {
        background-color: #fef9e7;
        color: #5d4037;
      }
      #chat-messages[data-theme="pink_purple"] .message-bubble.user .content {
        background-color: #fff0f6;
        color: #a78396;
      }
      #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content {
        background-color: #faf7ff;
        color: #827693;
      }
      #chat-messages[data-theme="gray_white"] .message-bubble.user .content {
        background-color: #e9ecef;
        color: #495057;
      }
      #chat-messages[data-theme="gray_white"] .message-bubble.ai .content {
        background-color: #f8f9fa;
        color: #383d41;
      }
      #chat-messages[data-theme="blue_green"] .message-bubble.user .content {
        background-color: #d1ecf1;
        color: #0c5460;
      }
      #chat-messages[data-theme="blue_green"] .message-bubble.ai .content {
        background-color: #d4edda;
        color: #155724;
      }
      #chat-messages[data-theme="pink_white"] .message-bubble.user .content {
        background-color: #fff0f6;
        color: #a78396;
      }
      #chat-messages[data-theme="pink_white"] .message-bubble.ai .content {
        background-color: #f8f9fa;
        color: #383d41;
      }
      #chat-messages[data-theme="pink_black"] .message-bubble.user .content {
        background-color: #f8bbd0;
        color: #5b2c6f;
      }
      #chat-messages[data-theme="pink_black"] .message-bubble.ai .content {
        background-color: #343a40;
        color: #f8f9fa;
      }
      #chat-messages[data-theme="pink_green"] .message-bubble.user .content {
        background-color: #f8bbd0;
        color: #5b2c6f;
      }
      #chat-messages[data-theme="pink_green"] .message-bubble.ai .content {
        background-color: #c8e6c9;
        color: #1b5e20;
      }
      #chat-messages[data-theme="green_black"] .message-bubble.user .content {
        background-color: #d4edda;
        color: #155724;
      }
      #chat-messages[data-theme="green_black"] .message-bubble.ai .content {
        background-color: #343a40;
        color: #f8f9fa;
      }

      #transfer-btn {
        font-weight: bold;
      }
      #transfer-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1001;
      }
      #transfer-modal.visible {
        display: flex;
      }
      .transfer-content {
        background-color: #fff0f5;
        border-radius: 20px;
        width: 290px;
        padding: 20px;
        box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3);
        text-align: center;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>');
        background-repeat: no-repeat;
        background-position: top right;
        background-size: 80px;
      }
      .transfer-header {
        font-size: 20px;
        font-weight: bold;
        color: #a35c7b;
        margin-bottom: 20px;
      }
      .transfer-input-group {
        margin-bottom: 15px;
        text-align: left;
      }
      .transfer-input-group label {
        display: block;
        font-size: 14px;
        color: #ff85b3;
        margin-bottom: 5px;
        font-weight: 500;
      }
      .transfer-input-group input {
        width: 100%;
        padding: 12px;
        border-radius: 10px;
        border: 2px solid #ffcce0;
        background-color: #fff;
        font-size: 16px;
        box-sizing: border-box;
      }
      .transfer-input-group input:focus {
        border-color: #ff85b3;
        outline: none;
      }
      .transfer-actions {
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }
      .transfer-actions button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 10px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
      }
      .transfer-actions button:active {
        transform: scale(0.95);
      }
      #transfer-cancel-btn {
        background-color: #ffdde9;
        color: #a35c7b;
      }
      #transfer-confirm-btn {
        background-color: #ff85b3;
        color: white;
      }
      .message-bubble.is-transfer .content {
        padding: 0;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        cursor: pointer;
      }
      .transfer-card {
        width: 200px;
        border-radius: 12px;
        padding: 12px;
        color: white;
        position: relative;
        overflow: hidden;
      }
      .transfer-card::before {
        content: "🐾";
        position: absolute;
        right: 10px;
        top: 5px;
        font-size: 30px;
        opacity: 0.2;
        transform: rotate(15deg);
      }
      .message-bubble.user .transfer-card {
        background: radial-gradient(circle at top left, #ffc5d5, #ff85b3);
      }
      .message-bubble.ai .transfer-card {
        background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb);
      }
      .transfer-title {
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 8px;
      }
      .transfer-amount {
        font-size: 28px;
        font-weight: bold;
        margin-bottom: 4px;
      }
      .transfer-note {
        font-size: 13px;
        opacity: 0.9;
        border-top: 1px solid rgba(255, 255, 255, 0.3);
        padding-top: 8px;
        margin-top: 8px;
        word-break: break-all;
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      #listen-together-btn img.rotating {
        animation: spin 2s linear infinite;
      }
      #listen-together-btn img.paused {
        animation-play-state: paused;
      }
      #music-player-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 50;
        display: none;
        justify-content: center;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.3);
      }
      #music-player-overlay.visible {
        display: flex;
      }
      .music-player-window {
        width: 90%;
        background-color: rgba(255, 255, 255, 0.6);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-radius: 20px;
        box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        border: 1px solid rgba(255, 255, 255, 0.18);
        padding: 25px;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: #1f1f1f;
        position: relative;
      }
      #music-playlist-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        font-size: 24px;
        cursor: pointer;
        color: #333;
      }
      #music-time-counter {
        font-size: 12px;
        color: #555;
        margin-bottom: 20px;
      }
      #music-player-song-title {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 5px;
        text-align: center;
      }
      #music-player-artist {
        font-size: 14px;
        color: #666;
        margin-bottom: 25px;
      }
      .music-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 20px;
        width: 100%;
        margin-bottom: 30px;
      }
      .music-controls button {
        background: none;
        border: none;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        color: #333;
        width: 44px;
        height: 44px;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: transform 0.2s;
      }
      .music-controls button:active {
        transform: scale(0.9);
      }
      .music-controls .play-pause-btn {
        font-size: 24px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.05);
      }
      .music-bottom-actions {
        display: flex;
        justify-content: space-between;
        width: 100%;
      }
      .music-bottom-actions button {
        flex: 1;
        padding: 12px 0;
        border: none;
        border-radius: 10px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
      }
      #music-exit-btn {
        background-color: rgba(255, 100, 100, 0.7);
        color: white;
        margin-right: 5px;
      }
      #music-return-btn {
        background-color: rgba(0, 123, 255, 0.7);
        color: white;
        margin-left: 5px;
      }

      #music-playlist-panel {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 70%;
        background-color: rgba(242, 242, 247, 0.9);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-top: 1px solid var(--border-color);
        border-radius: 20px 20px 0 0;
        z-index: 210;
        display: flex;
        flex-direction: column;
        transform: translateY(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        visibility: hidden;
      }
      #music-playlist-panel.visible {
        transform: translateY(0);
        visibility: visible;
      }
      .playlist-header {
        padding: 15px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        border-bottom: 1px solid var(--border-color);
        font-weight: 600;
      }
      .playlist-header .panel-btn {
        font-size: 16px;
        cursor: pointer;
        color: var(--accent-color);
      }
      .playlist-body {
        flex-grow: 1;
        overflow-y: auto;
        padding: 10px 0;
      }
      .playlist-item {
        padding: 10px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      }
      .playlist-item.playing {
        background-color: rgba(0, 123, 255, 0.1);
      }
      .playlist-item-info .title {
        font-weight: 500;
        font-size: 15px;
      }
      .playlist-item-info .artist {
        font-size: 12px;
        color: #666;
      }
      .playlist-item .delete-track-btn {
        color: #ff3b30;
        font-size: 20px;
        padding: 5px;
      }

      /* Persona Library Styles */
      #persona-library-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
        padding: 10px;
      }
      .persona-preset-item {
        aspect-ratio: 1 / 1;
        border-radius: 12px;
        background-size: cover;
        background-position: center;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }
      .persona-preset-item:hover {
        transform: scale(1.08);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      .modal-header .action-button {
        font-size: 16px;
        color: var(--accent-color);
        font-weight: 600;
        cursor: pointer;
        background: none;
        border: none;
        padding: 5px;
      }

      /* Battery Alert Modal Styles */
      #battery-alert-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      #battery-alert-modal.visible {
        display: flex;
        opacity: 1;
      }
      .battery-alert-content {
        background-color: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        width: 280px;
        border-radius: 15px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        text-align: center;
        padding: 20px;
        cursor: pointer;
        transform: scale(0.9);
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      #battery-alert-modal.visible .battery-alert-content {
        transform: scale(1);
      }
      #battery-alert-image {
        max-width: 100px;
        max-height: 100px;
        margin-bottom: 15px;
      }
      #battery-alert-text {
        font-size: 16px;
        font-weight: 500;
        color: #333;
        margin: 0;
        line-height: 1.4;
      }

      /* 这是你要添加的新样式 */
      #font-preview {
        transition: font-family 0.3s ease;
      }

      /* === 聊天列表界面新增样式 (这是新添加的) === */
      #chat-list-screen {
      }

      .chat-list-view {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s, visibility 0.2s;
        z-index: 1;
      }
      .chat-list-view.active {
        opacity: 1;
        visibility: visible;
        z-index: 2;
      }

      #messages-view {
        overflow-y: auto;
      }

      /* 底部导航栏样式 */
      #chat-list-bottom-nav {
        position: absolute; /* 让它固定在底部 */
        bottom: 0;
        left: 0;
        width: 100%;
        z-index: 15; /* 确保它在视图之上 */
        display: flex;
        border-top: 1px solid var(--border-color);
        background-color: rgba(247, 247, 247, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      .nav-item {
        flex: 1;
        text-align: center;
        padding: 12px 0;
        font-size: 14px;
        color: var(--text-secondary);
        cursor: pointer;
        transition: color 0.2s;
      }

      .nav-item.active {
        color: var(--accent-color);
        font-weight: 600;
      }

      /* === 动态界面 (QZone) 样式 (这是新添加的) === */
      #qzone-screen {
        background-color: #f0f2f5;
      }

      .qzone-header {
        /* position: absolute;  <-- 把这个改成 relative */
        position: relative;
        z-index: 10; /* z-index 保持，或者可以更高 */
        flex-shrink: 0; /* 防止被压缩 */
        padding: 15px 20px;
        padding-top: 45px;
        background-color: rgba(247, 247, 247, 0.7);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 18px;
        font-weight: 600;
        text-align: center;
      }

      .qzone-header .back-btn {
        font-size: 24px;
        cursor: pointer;
        color: var(--accent-color);
      }

      .qzone-header span:nth-child(2) {
        /* "好友动态"文字 */
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
      }

      .qzone-content {
        flex-grow: 1;
        overflow-y: auto;
        /* padding-top: 80px;  <-- 删除这个，因为header不再是absolute了 */
      }

      .qzone-profile-header {
        position: relative;
        margin-bottom: 20px;
      }

      .qzone-banner-container {
        width: 100%;
        height: 180px; /* 背景板高度 */
        position: relative;
      }

      #qzone-banner-img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .qzone-user-info {
        position: absolute;
        bottom: -30px; /* 让头像和昵称区域向下偏移，一半在背景板内，一半在外 */
        left: 20px;
        display: flex;
        align-items: flex-end; /* 让昵称和头像底部对齐 */
        gap: 10px;
      }

      .qzone-avatar-container {
        position: relative;
      }

      #qzone-avatar-img {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        border: 3px solid white;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        object-fit: cover;
      }

      #qzone-nickname {
        font-size: 18px;
        font-weight: 600;
        color: #fff;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        padding-bottom: 5px; /* 微调位置 */
      }

      /* 编辑按钮的通用样式 */
      .qzone-edit-btn {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.4);
        color: white;
        border: none;
        border-radius: 10px;
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
      }

      #change-qzone-banner-btn {
        bottom: 10px;
        right: 10px;
      }

      #change-qzone-avatar-btn {
        bottom: 5px;
        right: 5px;
      }

      #change-qzone-nickname-btn {
        font-size: 14px;
        padding: 2px 6px;
        margin-left: 5px; /* 与昵称的间距 */
        color: var(--text-primary);
        background-color: rgba(255, 255, 255, 0.7);
        border-radius: 5px;
        position: relative; /* 脱离flex布局的对齐 */
        bottom: 5px; /* 微调垂直位置 */
      }

      /* === 让编辑功能更“隐形” === */
      #qzone-banner-container,
      #qzone-avatar-container,
      #qzone-nickname {
        cursor: pointer; /* 鼠标悬停时显示为可点击手势 */
        transition: opacity 0.2s;
      }
      #qzone-banner-container:hover,
      #qzone-avatar-container:hover,
      #qzone-nickname:hover {
        opacity: 0.85; /* 悬停时稍微变暗，给用户反馈 */
      }
      /* 隐藏掉旧的、独立的编辑按钮 */
      .qzone-edit-btn {
        display: none;
      }

      /* === 控制 Header 和 Bottom Nav 的显隐 === */
      /* 默认隐藏动态界面的 Header */
      #qzone-screen .qzone-header {
        display: none;
      }
      /* 当动态视图激活时，显示它的Header */
      #qzone-screen.active .qzone-header {
        display: flex;
      }

      /* 当进入动态视图时，隐藏主Header和底部导航栏 */
      #chat-list-screen.in-qzone-view > .header,
      #chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
        display: none;
      }

      .chat-list-item:first-child,
      .chat-group-container:first-child {
        margin-top: 10px;
      }

      /* ▲▲▲ 新样式替换结束 ▲▲▲ */

      /* ▼▼▼ 把所有这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 动态功能栏样式 === */
      .qzone-actions-bar {
        display: flex;
        justify-content: space-around;
        padding: 10px 0;
        margin: 40px 15px 15px 15px; /* 上边距更大，为浮动的头像留出空间 */
        background-color: var(--secondary-bg);
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }

      .action-item {
        flex: 1;
        text-align: center;
        font-size: 15px;
        font-weight: 500;
        color: var(--text-primary);
        cursor: pointer;
        padding: 8px 0;
        position: relative;
      }

      /* 用伪元素创建分隔线 */
      .action-item:not(:last-child)::after {
        content: "";
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 1px;
        height: 20px;
        background-color: var(--border-color);
      }

      /* === 动态帖子列表样式 === */
      #qzone-posts-list {
        padding: 0 15px 20px 15px; /* 左右和底部留出边距 */
        display: flex;
        flex-direction: column;
        gap: 20px; /* 帖子之间的间距 */
      }

      .qzone-post-item {
        background-color: var(--secondary-bg);
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
      }

      .post-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }

      .post-header .post-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        object-fit: cover;
      }

      .post-info {
        display: flex;
        flex-direction: column;
      }

      .post-info .post-nickname {
        font-weight: 600;
        font-size: 15px;
        color: var(--text-primary);
      }

      .post-info .post-timestamp {
        font-size: 12px;
        color: var(--text-secondary);
      }

      .post-content {
        font-size: 14px;
        line-height: 1.6;
        color: #333;
        white-space: pre-wrap; /* 让换行符生效 */
        word-break: break-word; /* 防止长单词溢出 */
      }

      /* ▲▲▲ 新样式结束 ▲▲▲ */

      /* ▼▼▼ 新样式粘贴到末尾 ▼▼▼ */

      /* === 发布动态模态框样式 === */
      #post-public-text {
        min-height: 80px; /* 确保文本域有足够的高度 */
        resize: vertical;
      }

      .post-image-preview-container {
        position: relative;
        width: 100%;
        aspect-ratio: 16 / 9; /* 保持16:9的预览比例 */
        background-color: #f0f2f5;
        border: 2px dashed var(--border-color);
        border-radius: 8px;
        margin-bottom: 15px;
        display: none; /* 默认隐藏 */
        justify-content: center;
        align-items: center;
      }
      .post-image-preview-container.visible {
        display: flex; /* 上传后显示 */
      }

      #post-image-preview {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        border-radius: 6px;
      }

      #post-remove-image-btn {
        position: absolute;
        top: -10px;
        right: -10px;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background-color: #ff3b30;
        color: white;
        border: 2px solid white;
        font-size: 16px;
        line-height: 20px;
        text-align: center;
        cursor: pointer;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
      }

      .post-image-upload-options {
        display: flex;
        gap: 10px;
      }

      .post-image-upload-options button {
        flex: 1;
        margin-top: 0;
      }

      /* ▲▲▲ 新样式结束 ▲▲▲ */

      /* ▼▼▼ 新样式 ▼▼▼ */

      /* === 发布动态模态框 - 模式切换样式 === */
      .post-mode-switcher {
        display: flex;
        margin-bottom: 20px;
        background-color: #e9ecef;
        border-radius: 8px;
        padding: 4px;
      }

      .mode-btn {
        flex: 1;
        padding: 8px;
        border: none;
        background-color: transparent;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.2s ease-in-out;
      }

      .mode-btn.active {
        background-color: var(--secondary-bg);
        color: var(--text-primary);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .post-mode-content {
        display: none; /* 默认都隐藏 */
      }

      .post-mode-content.active {
        display: block; /* 激活的才显示 */
      }

      /* ▲▲▲ 新样式结束 ▲▲▲ */

      /* === 相册页面背景色 === */
      #album-screen {
        background-color: #f0f2f5; /* 使用一个柔和的浅灰色，比纯白更护眼 */
      }

      /* === 相册页面网格布局 === */
      #album-grid-page {
        padding: 15px;
        display: grid;
        grid-template-columns: repeat(2, 1fr); /* 每行显示2个相册 */
        gap: 15px;
      }

      /* === 相册项目样式 (美化) === */
      .album-item {
        display: flex;
        flex-direction: column;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        border-radius: 8px; /* 给整个项目也加个圆角 */
      }

      .album-item:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
      }

      .album-cover {
        aspect-ratio: 1 / 1; /* 保持封面为正方形 */
        background-size: cover;
        background-position: center;
        border-radius: 8px;
        margin-bottom: 8px;
        background-color: #f0f2f5; /* 封面加载前的占位颜色 */
      }

      .album-info {
        text-align: center;
      }

      .album-name {
        font-weight: 500;
        margin: 0 0 4px 0;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis; /* 防止长名字换行 */
      }

      .album-count {
        font-size: 12px;
        color: var(--text-secondary);
        margin: 0;
      }

      /* ▲▲▲ 新的 CSS 粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 相册照片详情页 === */
      #album-photos-screen {
        background-color: #f0f2f5;
      }

      #photos-grid-page {
        padding: 15px;
        display: grid;
        /* 每行显示3张照片，并保持间距 */
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      .photo-item {
        position: relative; /* 为了定位删除按钮 */
        aspect-ratio: 1 / 1; /* 保持照片为正方形 */
        border-radius: 6px;
        overflow: hidden; /* 防止图片溢出圆角 */
        background-color: #e9ecef; /* 图片加载前的占位符颜色 */
      }

      .photo-item .photo-thumb {
        width: 100%;
        height: 100%;
        object-fit: cover; /* 保证图片填满容器且不变形 */
        cursor: pointer;
      }

      /* 删除按钮的样式 */
      .photo-item .photo-delete-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 22px;
        height: 22px;
        background-color: rgba(0, 0, 0, 0.6);
        color: white;
        border: none;
        border-radius: 50%;
        font-size: 16px;
        line-height: 22px;
        text-align: center;
        cursor: pointer;
        opacity: 0; /* 默认隐藏 */
        transition: opacity 0.2s ease;
      }

      /* 鼠标悬停在照片上时显示删除按钮 */
      .photo-item:hover .photo-delete-btn {
        opacity: 1;
      }

      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* === 图片查看器模态框样式 === */
      #photo-viewer-modal {
        background-color: rgba(0, 0, 0, 0.85);
        z-index: 1002;
        -webkit-backdrop-filter: blur(5px);
        backdrop-filter: blur(5px);
      }

      .photo-viewer-content {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
      }

      #photo-viewer-image {
        max-width: 90vw; /* 图片最大宽度为视口的90% */
        max-height: 85vh; /* 图片最大高度为视口的85% */
        object-fit: contain;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        /* 为图片的切换添加一点平滑的淡入淡出效果 */
        transition: opacity 0.2s ease-in-out;
      }

      /* 关闭按钮 */
      #photo-viewer-close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        border: none;
        color: white;
        font-size: 40px;
        font-weight: 200;
        cursor: pointer;
        line-height: 1;
        text-shadow: 0 0 5px black;
      }

      /* 左右导航箭头 */
      #photo-viewer-modal .nav-arrow {
        position: absolute; /* 现在我们用绝对定位来控制箭头 */
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.7);
        font-size: 50px; /* 在手机屏幕上，可以稍微小一点 */
        font-weight: 100;
        cursor: pointer;
        padding: 10px; /* 调整内边距 */
        user-select: none;
        transition: color 0.2s;
        z-index: 1003; /* 确保箭头在最上层 */
      }

      #photo-viewer-prev-btn {
        left: 5px; /* 定位左箭头 */
      }

      #photo-viewer-next-btn {
        right: 5px; /* 定位右箭头 */
      }

      #photo-viewer-modal .nav-arrow:hover {
        color: white;
      }

      /* 当箭头被禁用时（比如第一张或最后一张） */
      #photo-viewer-modal .nav-arrow:disabled {
        color: rgba(255, 255, 255, 0.2);
        cursor: default;
      }

      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* ▼▼▼ 请用这块新CSS替换掉上一版的交互区CSS ▼▼▼ */

      /* === 帖子内容区 - 相对定位容器 === */
      /* === 帖子内容区 === */
      .post-main-content {
        /* 它现在只是一个普通的内容容器，不再需要特殊样式了 */
      }

      /* === 帖子互动图标区 (新样式) === */
      .post-feedback-icons {
        display: flex;
        justify-content: flex-end; /* 让图标靠右对齐 */
        align-items: center;
        gap: 12px;
        padding: 8px 0; /* 核心修改：给图标区域上下各8px的留白 */
      }

      .action-icon {
        cursor: pointer;
        color: var(--text-secondary); /* 默认灰色 */
        transition: all 0.2s ease-in-out;
      }

      .action-icon svg {
        width: 22px;
        height: 22px;
        fill: none;
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      /* 图标激活(点赞/收藏后)的样式 */
      .action-icon.active {
        color: #ff5252; /* 激活后变红色 */
        transform: scale(1.1); /* 轻微放大 */
      }

      .action-icon.active.favorite {
        color: #ffc107; /* 收藏用黄色 */
      }

      .action-icon.active svg {
        fill: currentColor; /* 激活后填充颜色 */
      }

      /* 点击时的动画效果 */
      .animate-like {
        animation: like-bounce 0.4s ease-in-out;
      }

      @keyframes like-bounce {
        0% {
          transform: scale(1);
        }
        25% {
          transform: scale(0.8);
        }
        50% {
          transform: scale(1.2);
        }
        75% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1.1);
        }
      }

      /* === 帖子底部评论区样式 (现在是独立部分) === */
      .post-footer {
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #f0f0f0; /* 用一条浅色线分隔 */
        display: flex;
        align-items: center;
        gap: 8px; /* 调整整体间距 */
      }

      /* 评论区容器 */
      .comment-section {
        flex-grow: 1; /* 占据大部分空间 */
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .comment-section .comment-avatar {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        object-fit: cover;
        flex-shrink: 0;
      }

      .comment-section .comment-input {
        width: 100%;
        padding: 8px 12px;
        border: none;
        background-color: #f0f2f5;
        border-radius: 14px;
        font-size: 13px;
        outline: none;
      }

      /* 新增的发送按钮样式 */
      .comment-send-btn {
        flex-shrink: 0; /* 防止被压缩 */
        padding: 8px 15px;
        border: none;
        background-color: var(--accent-color);
        color: white;
        border-radius: 14px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
      }

      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 未读消息小红点通用样式 === */
      .unread-indicator {
        position: absolute;
        top: -8px;
        right: -15px;
        min-width: 18px;
        height: 18px;
        padding: 0 5px;
        background-color: #ff3b30;
        color: white;
        font-size: 11px;
        font-weight: bold;
        line-height: 18px;
        text-align: center;
        border-radius: 9px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        display: none;
        z-index: 1;
      }

      /* 聊天界面返回按钮上的小红点 (只显示点，不显示数字) */
      .back-btn-indicator {
        top: 0;
        right: -8px; /* 放到返回箭头右上角 */
        width: 10px;
        height: 10px;
        min-width: 10px;
        padding: 0;
        border-radius: 50%;
      }

      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 评论列表容器 === */
      .post-comments-container {
        padding: 10px 0; /* 上下留白 */
        display: flex;
        flex-direction: column;
        gap: 8px; /* 评论之间的间距 */
        font-size: 13px; /* 统一评论区字体大小 */
      }

      /* 每一条评论 */
      .comment-item {
        line-height: 1.5;
      }

      /* 评论者的名字，加粗并使用主题色 */
      .comment-item .commenter-name {
        font-weight: 600;
        color: var(--accent-color);
        cursor: pointer;
        margin-right: 5px; /* 和评论内容之间留点空隙 */
      }

      /* 评论内容 */
      .comment-item .comment-text {
        color: var(--text-primary);
        word-break: break-word;
      }
      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 帖子点赞区域样式 === */
      .post-likes-section {
        display: flex;
        align-items: center;
        gap: 6px; /* 图标和文字的间距 */
        padding: 8px 10px; /* 内边距 */
        font-size: 13px;
        color: var(--accent-color); /* 使用主题蓝色 */
        background-color: #f0f5fa; /* 给一个淡淡的背景色 */
        border-top: 1px solid #e9eef3;
        border-bottom: 1px solid #e9eef3;
        margin-top: 5px; /* 和上方的图标保持一点距离 */
      }

      .post-likes-section .like-icon {
        width: 16px;
        height: 16px;
        fill: currentColor; /* 让SVG图标继承父元素的颜色 */
        flex-shrink: 0; /* 防止图标被压缩 */
      }

      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* === @提及 弹出菜单样式 === */
      .at-mention-popup {
        position: absolute; /* 相对于父元素定位 */
        bottom: 100%; /* 显示在输入框的上方 */
        left: 40px; /* 和输入框左侧对齐 (考虑了头像宽度) */
        width: calc(100% - 40px); /* 宽度和输入框差不多 */
        max-height: 120px;
        overflow-y: auto;
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
        z-index: 10;
        display: none; /* 默认隐藏 */
      }

      .at-mention-item {
        padding: 8px 12px;
        font-size: 14px;
        cursor: pointer;
        color: var(--text-primary);
        border-bottom: 1px solid #f0f0f0;
      }

      .at-mention-item:last-child {
        border-bottom: none;
      }

      .at-mention-item:hover {
        background-color: #f5f5f5;
      }
      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* ▼▼▼ 请用下面这段【新样式】替换掉你现有的 #favorites-list 样式 ▼▼▼ */

      /* 让收藏视图成为一个flex容器, 从上到下排列 */
      #favorites-view {
        display: flex;
        flex-direction: column;
      }

      /* 确保收藏页的header高度固定，不被压缩 */
      #favorites-view > .header {
        flex-shrink: 0;
      }

      /* === 收藏列表样式 (修正后) === */
      #favorites-list {
        flex-grow: 1;
        overflow-y: auto;
        overflow-x: hidden; /* <-- 新增这行，禁止水平滚动 */
        padding: 15px;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      /* ▲▲▲ 替换结束 ▲▲▲ */

      .favorite-item-card {
        background-color: var(--secondary-bg);
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
        position: relative; /* 为了定位删除按钮 */
      }

      /* 卡片头部，包含头像、名字和来源 */
      .fav-card-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }

      .fav-card-header .avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        object-fit: cover;
      }

      .fav-card-header .info {
        flex-grow: 1;
      }

      .fav-card-header .name {
        font-weight: 600;
        font-size: 15px;
      }

      .fav-card-header .source {
        font-size: 12px;
        color: var(--text-secondary);
      }

      /* 卡片内容 */
      .fav-card-content {
        font-size: 14px;
        line-height: 1.6;
        color: #333;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .fav-card-content .chat-image {
        margin-top: 8px; /* 图片和文字的间距 */
      }

      /* 删除按钮 */
      .fav-delete-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 28px;
        height: 28px;
        background: #f0f2f5;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 18px;
        color: var(--text-secondary);
        line-height: 28px;
        text-align: center;
      }

      .fav-delete-btn:hover {
        background-color: #e9ecef;
        color: #ff3b30;
      }

      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 搜索栏样式 === */
      .search-bar-container {
        padding: 10px 15px;
        background-color: #f9f9f9; /* 和列表背景色保持一致 */
        position: relative; /* 为了定位清除按钮 */
        flex-shrink: 0;
      }

      #favorites-search-input {
        width: 100%;
        padding: 10px 30px 10px 15px; /* 右侧留出清除按钮的位置 */
        font-size: 14px;
        border: 1px solid var(--border-color);
        border-radius: 18px; /* 圆角矩形，更现代化 */
        background-color: var(--secondary-bg);
        box-sizing: border-box;
        outline: none;
      }
      #favorites-search-input:focus {
        border-color: var(--accent-color);
      }

      .search-clear-btn {
        position: absolute;
        right: 25px;
        top: 50%;
        transform: translateY(-50%);
        background: #ccc;
        color: white;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        font-size: 16px;
        cursor: pointer;
      }

      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* === 聊天界面多选操作栏优化 === */
      #chat-interface-screen .header .selection-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }

      #chat-interface-screen .selection-controls .action-btn {
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        padding: 5px;
      }

      /* === 收藏页面多选模式样式 === */
      #favorites-view.selection-mode .favorite-item-card {
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      /* 选择框的样式 */
      .favorite-item-card::before {
        content: "";
        position: absolute;
        left: -25px; /* 把它放在卡片左边外面 */
        top: 50%;
        transform: translateY(-50%);
        width: 20px;
        height: 20px;
        border: 2px solid #ccc;
        border-radius: 50%;
        background-color: white;
        transition: all 0.2s ease;
        opacity: 0; /* 默认隐藏 */
      }

      /* 进入选择模式时，卡片向右移动，露出选择框 */
      #favorites-view.selection-mode .favorite-item-card {
        transform: translateX(35px);
      }
      #favorites-view.selection-mode .favorite-item-card::before {
        opacity: 1;
      }

      /* 选中后的样式 */
      #favorites-view.selection-mode .favorite-item-card.selected::before {
        background-color: var(--accent-color);
        border-color: var(--accent-color);
        content: "✔";
        color: white;
        font-size: 14px;
        text-align: center;
        line-height: 20px;
      }

      /* 底部操作栏 (终极修正版) */
      #favorites-action-bar {
        position: absolute; /* ★ 改为 absolute，相对于 #phone-screen 定位 */
        bottom: 0;
        left: 0;
        right: 0; /* ★ 新增 right: 0，和 left: 0 一起撑满宽度 */
        width: auto; /* ★ 改为 auto，让 left/right 决定宽度 */
        padding: 10px 15px;
        padding-bottom: calc(
          10px + env(safe-area-inset-bottom)
        ); /* 适配iPhone底部安全区 */
        background-color: rgba(247, 247, 247, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-top: 1px solid var(--border-color);
        box-sizing: border-box;
        z-index: 5;
        display: none;
        /* max-width 已经不需要了，因为父元素已经限制了宽度 */
      }

      #favorites-action-bar .action-bar-btn {
        width: 100%;
        padding: 12px;
        border-radius: 8px;
        border: none;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        background-color: #ff3b30;
        color: white;
      }

      /* === 【修正】聊天界面头部控件切换逻辑 === */

      /* 默认状态：隐藏多选控件 */
      #chat-interface-screen .header .selection-controls {
        display: none;
      }

      /* 默认状态：显示默认控件，并让它撑满整个头部 */
      #chat-interface-screen .header .default-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }

      /* 当进入多选模式时：隐藏默认控件 */
      #chat-interface-screen.selection-mode .header .default-controls {
        display: none;
      }

      /* 当进入多选模式时：显示多选控件，并让它撑满整个头部 */
      #chat-interface-screen.selection-mode .header .selection-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }

      /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 修正：放大所有主要的“+”号按钮 === */
      #add-chat-btn,
      #add-world-book-btn,
      #create-album-btn-page {
        font-size: 28px; /* 显著增大字体大小，使其视觉上与旁边的图标匹配 */
        font-weight: 300; /* 使用更细的字重，让加号看起来更清爽，不显粗笨 */
        position: relative; /* 允许进行位置微调 */
        top: -1px; /* 字体放大后，通常需要稍微向上移动一点，使其视觉上更居中 */
      }

      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* 预览区容器样式 */
      #settings-preview-area {
        width: 100%;
        height: 180px; /* 给一个固定的高度 */
        background-color: #f0f2f5;
        border-radius: 8px;
        padding: 15px;
        box-sizing: border-box;
        overflow: hidden; /* 防止内容溢出 */
        display: flex;
        flex-direction: column;
        gap: 10px; /* 预览气泡之间的间距 */
        border: 1px solid var(--border-color);
        position: relative; /* 为了定位背景 */
      }

      /* 预览区的背景，可以和真实聊天界面同步 */
      #settings-preview-area::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
        z-index: 1;
        opacity: 0.8;
      }

      /* 让预览气泡在背景之上 */
      #settings-preview-area .message-wrapper {
        position: relative;
        z-index: 2;
      }

      /* 预览区内使用的头像要小一点 */
      #settings-preview-area .message-bubble .avatar {
        width: 30px;
        height: 30px;
      }

      #settings-preview-area .message-bubble .timestamp {
        display: none; /* 预览区不需要显示时间戳 */
      }

      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
      .existing-group-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
        background-color: #f9f9f9;
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }

      .existing-group-item .group-name {
        font-weight: 500;
      }

      .existing-group-item .delete-group-btn {
        color: #ff3b30;
        font-size: 20px;
        cursor: pointer;
        padding: 5px;
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
      .chat-group-container {
        border-bottom: 1px solid var(--border-color);
      }
      .chat-group-container:first-child {
        border-top: 1px solid var(--border-color);
      }

      .chat-group-header {
        display: flex;
        align-items: center;
        padding: 12px 15px;
        cursor: pointer;
        background-color: #f7f7f7;
      }

      .chat-group-header .arrow {
        font-size: 14px;
        margin-right: 8px;
        transition: transform 0.2s ease;
      }

      .chat-group-header.collapsed .arrow {
        transform: rotate(-90deg);
      }

      .chat-group-header .group-name {
        font-weight: 600;
        font-size: 15px;
      }

      .chat-group-content {
        max-height: 1000px; /* 一个足够大的值 */
        overflow: hidden;
        transition: max-height 0.3s ease-in-out;
      }

      .chat-group-content.collapsed {
        max-height: 0;
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

      /* 格式助手按钮的容器 */
      .format-helpers {
        display: flex;
        gap: 10px;
        margin-bottom: 15px; /* 与下方的文本框拉开距离 */
        flex-wrap: wrap; /* 如果按钮太多可以换行 */
      }

      /* 单个格式助手按钮的样式 */
      .format-btn {
        background-color: #e9ecef;
        color: var(--text-primary);
        border: none;
        padding: 6px 12px;
        border-radius: 16px; /* 胶囊形状，更友好 */
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .format-btn:hover {
        background-color: #dcdfe3;
      }

      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

      /* “…”按钮的样式 */
      .post-actions-btn {
        margin-left: auto; /* 关键：让它自动靠到最右边 */
        padding: 5px 10px;
        font-size: 20px;
        font-weight: bold;
        color: var(--text-secondary);
        cursor: pointer;
        border-radius: 50%;
        line-height: 1;
      }
      .post-actions-btn:hover {
        background-color: #f0f0f0;
      }

      /* 动态编辑模态框的样式 (它将复用现有的操作菜单样式) */
      #post-actions-modal .custom-modal-footer button {
        width: 100%;
        border: none;
        border-bottom: 1px solid #dbdbdb;
        padding: 14px;
        font-size: 18px;
      }
      #post-actions-modal .custom-modal-footer button:last-child {
        border-bottom: none;
      }
      #post-actions-modal #cancel-post-action-btn {
        margin-top: 8px;
        border-radius: 8px;
        background-color: #f0f0f0;
      }

      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* 统一重置转账卡片内所有文字的特效和颜色 */
      #chat-messages .transfer-card .transfer-title,
      #chat-messages .transfer-card .transfer-amount,
      #chat-messages .transfer-card .transfer-note {
        text-shadow: none !important; /* 强制移除任何发光或阴影效果 */
        color: white !important; /* 强制锁定文字颜色为白色 */
      }

      /* 分别锁定各自的字体大小和字重，防止被篡改 */
      #chat-messages .transfer-card .transfer-title {
        font-size: 16px !important;
        font-weight: 600 !important;
      }

      #chat-messages .transfer-card .transfer-amount {
        font-size: 28px !important;
        font-weight: bold !important;
      }

      #chat-messages .transfer-card .transfer-note {
        font-size: 13px !important;
        opacity: 0.9 !important;
      }

      /* ▼▼▼ 这是新增的样式，用于修正所有头部标题的居中问题 ▼▼▼ */
      .header > span:nth-child(2),
      #chat-header-title {
        position: absolute;
        left: 50%;
        transform: translateX(
          calc(-50% - 2px)
        ); /* 在-50%的基础上，再向左推2像素 */

        /* (可选但推荐) 防止长标题与两边按钮重叠 */
        max-width: 60%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      /* ▲▲▲ 粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】可视化消息编辑器样式 ▼▼▼ */
      #message-editor-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      .message-editor-block {
        background-color: #f9f9f9;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 12px;
      }

      .message-editor-block textarea {
        width: 100%;
        min-height: 60px;
        resize: vertical;
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 8px;
        font-size: 14px;
        box-sizing: border-box;
      }

      .message-editor-block .format-helpers {
        margin-top: 8px;
        margin-bottom: 0; /* 覆盖默认的 margin-bottom */
      }

      .message-editor-block .delete-block-btn {
        float: right;
        margin-top: -5px;
        background: none;
        border: none;
        color: #ff3b30;
        font-size: 20px;
        cursor: pointer;
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】联系人选择器样式 ▼▼▼ */
      .contact-picker-item {
        display: flex;
        align-items: center;
        padding: 10px 15px;
        cursor: pointer;
        border-bottom: 1px solid var(--border-color);
      }
      .contact-picker-item .checkbox {
        width: 20px;
        height: 20px;
        border: 2px solid #ccc;
        border-radius: 50%;
        margin-right: 15px;
        transition: all 0.2s ease;
      }
      .contact-picker-item.selected .checkbox {
        background-color: var(--accent-color);
        border-color: var(--accent-color);
        content: "✔";
        color: white;
        font-size: 14px;
        text-align: center;
        line-height: 20px;
      }
      .contact-picker-item .avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        margin-right: 12px;
      }
      .contact-picker-item .name {
        font-weight: 500;
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】群成员管理界面样式 ▼▼▼ */
      #member-management-list {
        padding: 0; /* 移除默认padding，让列表项撑满 */
      }

      .member-management-item {
        display: flex;
        align-items: center;
        padding: 12px 15px;
        border-bottom: 1px solid var(--border-color);
      }

      .member-management-item .avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        margin-right: 12px;
      }

      .member-management-item .name {
        flex-grow: 1;
        font-weight: 500;
      }

      .member-management-item .remove-member-btn {
        background-color: #ff3b30;
        color: white;
        border: none;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        font-size: 20px;
        line-height: 28px;
        text-align: center;
        cursor: pointer;
        flex-shrink: 0;
      }

      #member-management-actions {
        flex-shrink: 0;
        padding: 15px;
        border-top: 1px solid var(--border-color);
        background-color: #f7f7f7;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      #member-management-actions button {
        width: 100%;
        padding: 15px;
        background-color: var(--accent-color);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
      }
      #member-management-actions #create-new-member-btn {
        background-color: #4cd964; /* 新建用绿色，以示区分 */
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】外卖代付卡片样式 ▼▼▼ */
      .message-bubble.is-waimai-request .content {
        padding: 0;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }

      .waimai-card {
        width: 240px;
        border-radius: 12px;
        overflow: hidden;
        background-color: #fff;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
      }

      .waimai-header {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        border-bottom: 1px solid #f0f0f0;
      }

      .waimai-header .icon {
        width: 20px;
        height: 20px;
      }

      .waimai-header .title-group {
        display: flex;
        align-items: baseline;
        font-size: 14px;
        color: #8a8a8a;
      }
      .waimai-header .title-group .brand {
        font-weight: 600;
        color: #555;
        margin-right: 5px;
      }
      .waimai-header .title-group .separator {
        margin: 0 5px;
      }

      .waimai-catchphrase {
        font-size: 13px;
        color: #1f1f1f;
        padding: 12px;
      }

      .waimai-main {
        background-color: #ffd66b; /* 橙黄色背景 */
        padding: 12px;
        text-align: center;
      }

      .waimai-main .request-title {
        font-size: 12px;
        color: #856404;
        margin-bottom: 8px;
      }

      .waimai-main .payment-box {
        background-color: #fff;
        border-radius: 8px;
        padding: 15px 10px;
      }

      .waimai-main .payment-label {
        font-size: 13px;
        color: #8a8a8a;
      }

      .waimai-main .amount {
        font-size: 32px;
        font-weight: 700;
        color: #1f1f1f;
        margin: 4px 0 12px 0;
      }

      .waimai-main .countdown-label {
        font-size: 13px;
        color: #8a8a8a;
      }
      .waimai-main .countdown-timer {
        display: inline-flex;
        align-items: center;
        gap: 2px;
        margin-left: 5px;
      }
      .waimai-main .countdown-timer span {
        background-color: #333;
        color: white;
        padding: 2px 4px;
        border-radius: 2px;
        font-weight: bold;
        font-size: 12px;
      }

      .waimai-details-btn {
        width: 100%;
        padding: 10px 0;
        margin-top: 15px;
        border: none;
        border-radius: 6px;
        background-color: #ffc33a;
        color: #49380a;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】外卖响应状态样式 ▼▼▼ */

      /* === 同意支付后的样式 === */
      .message-bubble.status-paid .waimai-card {
        border: 2px solid #28a745; /* 绿色边框 */
      }
      .message-bubble.status-paid .waimai-main .request-title::before {
        content: "✅  ";
      }
      .message-bubble.status-paid .waimai-main .request-title {
        color: #155724;
        font-weight: 600;
        /* 重写 request-title 的内容 */
        content: "我已为您买单，请尽情享用吧～" !important;
        display: block;
        margin-bottom: 15px;
      }

      .message-bubble.status-paid .payment-box {
        display: none; /* 隐藏支付详情 */
      }
      .message-bubble.status-paid .waimai-details-btn {
        background-color: #28a745;
        color: white;
      }

      /* === 拒绝支付后的样式 === */
      .message-bubble.status-rejected .waimai-card {
        border: 2px solid #dc3545; /* 红色边框 */
        opacity: 0.8;
      }
      .message-bubble.status-rejected .waimai-main {
        background-color: #e9ecef;
      }
      .message-bubble.status-rejected .waimai-main .request-title::before {
        content: "❌ ";
      }
      .message-bubble.status-rejected .waimai-main .request-title {
        color: #721c24;
        font-weight: 600;
        /* 重写 request-title 的内容 */
        content: "我拒绝了您的代付请求" !important;
        display: block;
        margin-bottom: 15px;
      }
      .message-bubble.status-rejected .payment-box {
        display: none; /* 隐藏支付详情 */
      }
      .message-bubble.status-rejected .waimai-details-btn {
        background-color: #6c757d;
        color: white;
      }

      /* 强制重写 request-title 内容的技巧 */
      .message-bubble[class*="status-"] .request-title {
        font-size: 0; /* 隐藏原始文本 */
      }
      .message-bubble[class*="status-"] .request-title::after {
        font-size: 14px; /* 让伪元素显示新文本 */
      }
      .message-bubble.status-paid .request-title::after {
        content: "我已为您买单，请尽情享用吧～";
      }
      .message-bubble.status-rejected .request-title::after {
        content: "我拒绝了您的代付请求";
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】外卖请求的用户操作按钮样式 ▼▼▼ */
      .waimai-user-actions {
        display: flex;
        gap: 10px;
        padding: 0 12px 12px 12px; /* 在卡片底部留出空间 */
        background-color: #fff;
      }

      .waimai-user-actions button {
        flex: 1;
        padding: 10px;
        border-radius: 8px;
        border: 1.5px solid;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .waimai-pay-btn {
        background-color: #28a745;
        border-color: #1f7a33;
        color: white;
      }
      .waimai-pay-btn:hover {
        background-color: #218838;
      }

      .waimai-decline-btn {
        background-color: #f8f9fa;
        border-color: #ced4da;
        color: #495057;
      }
      .waimai-decline-btn:hover {
        background-color: #e2e6ea;
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* === 【新增】统一设置页面的背景色 (已修正) === */
      #api-settings-screen,
      #font-settings-screen,
      #wallpaper-screen,
      #memories-view,
      #contact-picker-screen,
      #member-management-screen,
      #world-book-editor-screen {
        background-color: var(--secondary-bg);
      }

      /* 确保这些页面的内容区能正确滚动 */
      #api-settings-screen .form-container,
      #font-settings-screen .form-container,
      #wallpaper-screen .form-container {
        padding-top: 100px;
        margin-top: -80px;
        background-color: var(--secondary-bg);
      }

      /* 壁纸设置页面的预览区比较特殊，需要额外调整 */
      #wallpaper-screen .form-container {
        align-items: center; /* 保持内容居中 */
      }

      /* ▼▼▼ 【全新】来电请求与视频通话界面样式 ▼▼▼ */

      /* --- 来电请求模态框 --- */
      #incoming-call-modal .incoming-call-content {
        background-color: rgba(40, 40, 40, 0.85);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-radius: 20px;
        width: 280px;
        padding: 30px 20px;
        text-align: center;
        color: white;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      .caller-avatar {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        object-fit: cover;
        margin-bottom: 12px;
        border: 3px solid rgba(255, 255, 255, 0.5);
      }

      .caller-name {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 5px;
      }

      .caller-text {
        font-size: 14px;
        color: #ccc;
        margin-bottom: 30px;
      }

      .incoming-call-actions {
        display: flex;
        justify-content: space-around;
        align-items: center;
      }

      .action-button-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: #e0e0e0;
      }

      .call-action-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        background-size: 50%;
        background-repeat: no-repeat;
        background-position: center;
        transition: transform 0.2s, box-shadow 0.2s;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      .call-action-btn:active {
        transform: scale(0.9);
      }

      .call-action-btn.decline {
        background-color: #ff3b30;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
      }

      .call-action-btn.accept {
        background-color: #4cd964;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7);
        }
        70% {
          box-shadow: 0 0 0 15px rgba(76, 217, 100, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(76, 217, 100, 0);
        }
      }

      /* --- 视频通话界面 --- */
      /* ▼▼▼ 请用这一整块【最终修正版】的代码，替换所有旧的 video-call 相关CSS ▼▼▼ */

      /* 1. 通话屏幕总容器 (保持不变) */
      #video-call-screen {
        background-color: #1c1c1e;
        color: white;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      /* 2. 顶部栏和底部控制栏 (保持不变) */
      .video-call-top-bar {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        padding: 15px 20px;
        padding-top: 50px;
        background: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), transparent);
        z-index: 10;
        text-align: center;
        box-sizing: border-box;
        pointer-events: none;
      }
      #call-timer {
        font-size: 16px;
        font-weight: 500;
        letter-spacing: 1px;
      }
      .video-call-controls {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: space-around;
        align-items: center;
        padding: 20px;
        padding-bottom: 40px;
        background: linear-gradient(to top, rgba(0, 0, 0, 0.5), transparent);
        z-index: 10;
        box-sizing: border-box;
      }

      /* 3. 参与者头像显示区 (保持不变) */
      .video-call-avatar-area {
        height: 35%; /* 修改：固定高度比例，给下方留出更多空间 */
        flex-shrink: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
        padding-top: 80px; /* 确保顶部有足够空间 */
        box-sizing: border-box;
        overflow-y: auto; /* ★ 新增：如果头像太多，允许此区域滚动 */
      }

      /* 4. 头像网格容器 (保持不变) */
      #participant-avatars-grid {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 15px; /* ★ 稍微减小头像间距 */
        max-width: 100%;
      }

      /* 5. 单个参与者的头像容器 (头像缩小) */
      .participant-avatar-wrapper {
        position: relative;
        text-align: center;
        flex-shrink: 0;
      }
      .participant-avatar {
        width: 70px; /* ★ 从 80px 缩小到 70px */
        height: 70px; /* ★ 从 80px 缩小到 70px */
        border-radius: 50%;
        object-fit: cover;
        border: 3px solid rgba(255, 255, 255, 0.2);
        transition: all 0.3s ease;
      }
      .participant-name {
        margin-top: 8px;
        font-size: 12px;
        color: #ccc;
      }

      /* 6. 发言者头像高亮效果 (保持不变) */
      .participant-avatar.speaking {
        border-color: #4cd964;
        box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
        transform: scale(1.05);
      }

      /* 7. 【最终版】对话框区域 */
      #video-call-main {
        flex-grow: 1; /* 修改：自动占据剩余空间 */
        /* height: 30%;  已移除固定高度 */
        margin: 15px 15px 130px 15px; /* ★ 核心修改：底部边距从120px增加到130px，创造明显空隙 */
        overflow-y: auto;
        padding: 15px;
        background-color: rgba(255, 255, 255, 0.05);
        border-radius: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        box-sizing: border-box;
      }

      /* 8. 控制按钮样式 (保持不变) */
      .control-btn {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        background-repeat: no-repeat;
        background-position: center;
        transition: transform 0.2s, background-color 0.2s;
      }
      .control-btn:active {
        transform: scale(0.9);
      }
      .control-btn.speak-btn {
        background-color: rgba(255, 255, 255, 0.2);
        background-size: 55%;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>');
      }
      .control-btn.hangup-btn {
        background-color: #ff3b30;
        background-size: 50%;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
      }
      .control-btn.join-btn {
        background-color: #007bff;
        background-size: 50%;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
      }

      /* ▲▲▲ 新CSS替换结束 ▲▲▲ */

      /* ▼▼▼ 【全新】视频通话对话气泡样式 ▼▼▼ */
      .call-message-bubble {
        padding: 10px 15px;
        border-radius: 12px;
        max-width: 85%;
        line-height: 1.6;
        word-break: break-word;
        white-space: pre-wrap;
      }

      .call-message-bubble.ai-speech {
        background-color: rgba(255, 255, 255, 0.15);
        align-self: flex-start; /* AI发言靠左 */
      }

      .call-message-bubble.user-speech {
        background-color: #4cd964; /* 用户发言用绿色，类似微信 */
        align-self: flex-end; /* 用户发言靠右 */
        text-align: left; /* 确保用户气泡内的文字是左对齐的 */
      }
      /* ▲▲▲ 新增CSS结束 ▲▲▲ */

      /* ▼▼▼ 【全新添加】正在呼叫界面样式 ▼▼▼ */
      #outgoing-call-screen {
        background-color: #1c1c1e;
        color: white;
        justify-content: center; /* 垂直居中 */
        align-items: center; /* 水平居中 */
      }

      .outgoing-call-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
      }

      .outgoing-call-actions {
        margin-top: 50px; /* 和上方文字拉开距离 */
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: #e0e0e0;
      }
      /* ▲▲▲ 添加结束 ▲▲▲ */

      /* 1. 动态帖子的外层容器，我们需要它来定位和裁剪 */
      .qzone-post-container {
        position: relative; /* 让内部的删除按钮可以相对于它定位 */
        overflow: hidden; /* 隐藏掉超出部分的删除按钮 */
        border-radius: 12px; /* 和内部卡片保持一致的圆角 */
      }

      /* 2. 可滑动的内容卡片，增加一个平滑的过渡效果 */
      .qzone-post-item {
        transition: transform 0.3s ease;
        background-color: var(
          --secondary-bg
        ); /* 确保它有背景色，能盖住下面的删除按钮 */
        position: relative; /* 确保它在最上层 */
        z-index: 2;
      }

      /* 3. 【核心】这就是那个“删除”按钮的样式！*/
      .qzone-post-delete-action {
        position: absolute; /* 绝对定位，脱离文档流 */
        top: 0;
        right: 0;
        bottom: 0;
        width: 90px; /* 删除按钮的宽度 */
        background-color: #ff3b30; /* 您想要的红色背景 */
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        cursor: pointer;
        z-index: 1; /* 确保它在卡片下面 */
      }

      /* 4. 当卡片左滑时，把它向左移动，露出删除按钮 */
      .qzone-post-item.swiped {
        transform: translateX(-90px); /* 移动的距离和删除按钮的宽度一致 */
      }

      /* ▲▲▲ 粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这【一整块】全新的“拍一拍”样式，粘贴到 <style> 的末尾 ▼▼▼ */

      /* 1. “拍一拍”的屏幕震动动画 */
      @keyframes pat-shake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-3px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(3px);
        }
      }

      .pat-animation {
        animation: pat-shake 0.4s ease-in-out;
      }

      /* 2. “拍一拍”系统提示消息的样式 */
      .system-message {
        align-self: center; /* 居中显示 */
        padding: 4px 12px;
        margin: 5px 0;
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--text-secondary);
        font-size: 12px;
        border-radius: 10px;
        text-align: center;
        max-width: 80%;
      }

      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* 让“拍一拍”类型的 wrapper 居中 */
      .message-wrapper.system-pat {
        justify-content: center;
        align-self: center;
        margin: 5px 0;
        max-width: 80%;
      }
      /* “拍一-拍”消息气泡的样式 */
      .message-bubble.system-bubble {
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--text-secondary);
        font-size: 12px;
        padding: 4px 12px;
        border-radius: 10px;
      }

      /* === 修复：特定消息类型的包裹气泡移除 === */
      .message-bubble.is-sticker .content,
      .message-bubble.is-transfer .content,
      .message-bubble.is-waimai-request .content,
      .message-bubble.has-image .content,
      .message-bubble.is-ai-image .content,
      .message-bubble.is-voice-message .content {
        background-color: transparent !important;
        background: transparent !important;
        box-shadow: none !important;
        border: none !important;
        padding: 0 !important;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
      }

      /* 移除特定消息气泡的小尾巴 */
      .message-bubble.is-sticker::after,
      .message-bubble.has-image::after,
      .message-bubble.is-ai-image::after,
      .message-bubble.is-transfer::after,
      .message-bubble.is-waimai-request::after,
      .message-bubble.is-voice-message::after {
        display: none !important;
      }

      /* 确保正在输入状态也显示为淡灰色气泡 */
      #typing-indicator {
        align-self: center;
        margin: 5px 0;
        display: none;
      }
      #typing-indicator .system-bubble {
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--text-secondary);
        font-size: 12px;
        padding: 4px 12px;
        border-radius: 10px;
        display: inline-block;
      }

      /* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 修正：让顶部操作栏可以横向滚动 === */
      #chat-input-actions-top {
        display: flex;
        gap: 8px;
        padding: 0 5px;

        /* --- 核心代码开始 --- */
        overflow-x: auto;
        flex-wrap: nowrap;
        -webkit-overflow-scrolling: touch;

        scrollbar-width: none;
        -ms-overflow-style: none;
      }

      #chat-input-actions-top::-webkit-scrollbar {
        display: none;
      }

      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* === 【全新】聊天界面头部状态栏样式 === */

      /* 1. 标题和状态的总容器，使用flex布局让它们垂直排列 */
      #chat-header-title-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center; /* 水平居中 */
        gap: 2px; /* 标题和状态之间的微小间距 */

        /* 为了让它能在flex布局中正确居中 */
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        max-width: 60%;
      }

      /* 2. 主标题的样式微调 */
      #chat-header-title {
        font-size: 16px; /* 可以稍微缩小一点，给状态栏留出空间 */
        font-weight: 600;
        position: static; /* 覆盖掉旧的absolute定位 */
        transform: none; /* 覆盖掉旧的transform */
        /* 保证长标题也能正确显示省略号 */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
      }

      /* 3. 状态栏容器 */
      #chat-header-status {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 11px;
        color: var(--text-secondary);
        transition: all 0.3s ease;
      }

      /* 4. 状态小圆点 */
      .status-dot {
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background-color: #4cd964; /* 默认绿色，代表在线 */
        transition: background-color 0.3s ease;
      }

      /* 当AI状态为“忙碌”或“离开”时，让圆点变灰色 */
      #chat-header-status.busy .status-dot {
        background-color: #cccccc;
      }

      /* 5. 状态文本 */
      .status-text {
        font-weight: 500;
      }

      /* === 【全新美化版】回忆卡片样式 === */

      /* 1. 卡片总容器：这里负责定义整体的背景色和边框 */
      .memory-card {
        background-color: #fffaf0; /* 统一的、温暖的米黄色背景 */
        border-radius: 12px;
        padding: 15px; /* 在卡片四周留出内边距 */
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.07);
        border-left: 5px solid #ffb74d;
        display: flex; /* 让它成为flex容器，方便内部元素排列 */
        flex-direction: column; /* 让头部和内容垂直堆叠 */
        gap: 8px; /* 在头部和内容之间创造一个自然的间距 */
      }

      /* 2. 头部容器：现在只负责布局和分割线 */
      .memory-card .header {
        border-bottom: 1px solid rgba(217, 129, 0, 0.15); /* 分割线颜色可以稍微加深一点 */
        padding-bottom: 8px;
      }

      /* 3. 日期样式 (保持不变) */
      .memory-card .header .date {
        font-size: 11px;
        color: #a1887f;
        margin-bottom: 4px;
      }

      /* 4. 作者样式 (保持不变) */
      .memory-card .header .author {
        font-weight: 600;
        color: #d98100;
        font-size: 15px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* 5. 内容区样式 (保持不变) */
      .memory-card .content {
        font-size: 14px;
        line-height: 1.7;
        color: #5d4037;
        white-space: pre-wrap;
      }

      /* === 【全新】约定/倒计时卡片样式 === */
      .countdown-card {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
        text-align: center;
        position: relative;
        overflow: hidden;
        flex-shrink: 0;
      }
      .countdown-card::before {
        content: "✨";
        position: absolute;
        top: -10px;
        left: -10px;
        font-size: 50px;
        opacity: 0.1;
        transform: rotate(-15deg);
      }
      .countdown-card .title {
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 15px;
      }
      .countdown-card .timer {
        font-size: 28px;
        font-weight: 300;
        letter-spacing: 2px;
        margin-bottom: 15px;
      }
      .countdown-card .target-date {
        font-size: 12px;
        opacity: 0.8;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        padding-top: 10px;
      }

      /* === 【全新】聊天锁定遮罩层样式 === */
      #chat-lock-overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        background-color: rgba(247, 247, 247, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        z-index: 150; /* 比输入框高，比贴纸面板低 */
        display: none; /* 默认隐藏 */
        align-items: center;
        justify-content: center;
        padding: 20px;
        box-sizing: border-box;
        border-top: 1px solid var(--border-color);
        text-align: center;
      }
      #chat-lock-content {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      #chat-lock-content .lock-text {
        color: var(--text-secondary);
        font-size: 14px;
      }
      #chat-lock-content .lock-action-btn {
        padding: 10px 20px;
        border-radius: 20px;
        border: 1px solid var(--accent-color);
        background-color: var(--accent-color);
        color: white;
        cursor: pointer;
      }
      #chat-lock-content .lock-action-btn.secondary {
        background-color: transparent;
        color: var(--accent-color);
      }

      /* ▼▼▼ 【全新】红包卡片样式 ▼▼▼ */
      .message-bubble.is-red-packet .content {
        padding: 0;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }

      .red-packet-card {
        width: 220px;
        border-radius: 8px;
        background: linear-gradient(160deg, #f96259, #e44d44);
        color: #ffd700; /* 金色文字 */
        padding: 12px;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        position: relative;
        overflow: hidden;
      }

      .red-packet-card.opened {
        background: linear-gradient(160deg, #d3c4a0, #c4b693);
        cursor: default;
      }

      .red-packet-card::before {
        content: "🧧";
        position: absolute;
        top: -5px;
        left: -5px;
        font-size: 30px;
        opacity: 0.2;
        transform: rotate(-10deg);
      }

      .rp-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
      }

      .rp-icon {
        width: 20px;
        height: 20px;
      }

      .rp-greeting {
        font-size: 15px;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .rp-type {
        font-size: 11px;
        color: white;
        opacity: 0.8;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        padding-top: 8px;
        margin-top: 8px;
      }

      .rp-claimed-info {
        font-size: 13px;
        color: white;
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid rgba(255, 255, 255, 0.3);
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】红包详情列表样式 ▼▼▼ */
      .rp-details-item {
        display: flex;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid #eee;
      }
      .rp-details-item:last-child {
        border-bottom: none;
      }
      .rp-details-item .name {
        flex-grow: 1;
        font-weight: 500;
        color: #333;
      }
      .rp-details-item .amount {
        font-weight: 500;
        color: #555;
      }
      .rp-details-item .lucky-king-tag {
        font-size: 10px;
        background-color: #ffd700;
        color: #a67c00;
        padding: 2px 5px;
        border-radius: 4px;
        margin-left: 8px;
        font-weight: bold;
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】投票功能样式 ▼▼▼ */

      /* 投票卡片在消息气泡中的样式 */
      .message-bubble.is-poll .content {
        padding: 0;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }

      /* 投票卡片主体 */
      .poll-card {
        width: 250px;
        background-color: #f9f9f9;
        border-radius: 10px;
        border: 1px solid #e0e0e0;
        padding: 12px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }

      .poll-card.closed {
        background-color: #e9ecef; /* 结束后变灰 */
      }

      /* 投票问题 */
      .poll-question {
        font-weight: 600;
        font-size: 15px;
        margin-bottom: 12px;
        line-height: 1.4;
        word-break: break-word;
      }

      /* 投票选项列表 */
      .poll-options-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      /* 单个投票选项 */
      .poll-option-item {
        background-color: white;
        border: 1px solid #dcdcdc;
        border-radius: 8px;
        padding: 10px;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        transition: background-color 0.2s;
      }

      .poll-card:not(.closed) .poll-option-item:hover {
        background-color: #f0f8ff;
      }

      /* 用户已投票的选项样式 */
      .poll-option-item.voted {
        border-color: var(--accent-color);
        background-color: #e7f3ff;
        font-weight: 500;
      }

      /* 投票进度条 */
      .poll-option-bar {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        background-color: rgba(0, 123, 255, 0.1);
        z-index: 1;
        transition: width 0.3s ease-in-out;
      }

      /* 选项内容（文字和票数），确保在进度条之上 */
      .poll-option-content {
        position: relative;
        z-index: 2;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .poll-option-text {
        font-size: 14px;
      }

      .poll-option-votes {
        font-size: 13px;
        color: #8a8a8a;
        font-weight: 500;
      }

      /* 投票卡片底部 */
      .poll-footer {
        margin-top: 12px;
        padding-top: 8px;
        border-top: 1px solid #e9e9e9;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 12px;
        color: var(--text-secondary);
      }

      .poll-total-votes {
        font-weight: 500;
      }

      .poll-action-btn {
        background: none;
        border: 1px solid var(--accent-color);
        color: var(--accent-color);
        padding: 4px 10px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 12px;
      }
      .poll-card.closed .poll-action-btn {
        background-color: #6c757d;
        color: white;
        border-color: #6c757d;
      }

      /* 创建投票模态框的选项输入 */
      .poll-option-input-wrapper {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .poll-option-input-wrapper input {
        flex-grow: 1;
      }
      .poll-option-input-wrapper .remove-option-btn {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background-color: #f0f0f0;
        color: #ff3b30;
        border: none;
        cursor: pointer;
        font-size: 18px;
        line-height: 28px;
        text-align: center;
        flex-shrink: 0;
      }

      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* === 【全新】聊天头部“正在输入”状态样式 === */
      #chat-header-title.typing-status {
        color: var(--text-secondary);
        animation: typing-pulse 1.5s infinite;
        font-style: italic;
      }

      @keyframes typing-pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      #chat-header-title {
        transition: opacity 0.2s ease-in-out;
      }

      @keyframes message-pop-in {
        from {
          opacity: 0;
          transform: translateY(15px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message-wrapper.animate-in {
        animation: message-pop-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
      }

      /* ▼▼▼ 【全新】App图标设置样式 ▼▼▼ */
      #icon-settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
        gap: 20px;
        width: 100%;
        padding: 0 10px;
        box-sizing: border-box;
      }

      .icon-setting-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }

      .icon-preview {
        width: 60px;
        height: 60px;
        border-radius: 15px;
        background-size: cover;
        background-position: center;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .change-icon-btn {
        padding: 4px 10px;
        font-size: 12px;
        border: 1px solid #ccc;
        background-color: #f0f0f0;
        border-radius: 5px;
        cursor: pointer;
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】外观设置页面布局修正 ▼▼▼ */

      /* 1. 修正滚动问题 */
      #wallpaper-screen .form-container {
        /* 核心修正1: 解决flex布局下的滚动冲突，让滚动条能正常出现 */
        min-height: 0;
      }

      /* 2. 修正壁纸预览被压扁的问题 */
      #wallpaper-preview {
        /* 核心修正2: 防止预览框被过多的内容挤压变形，让它保持自己的高度 */
        flex-shrink: 0;
      }
      /* ▲▲▲ 修正结束 ▲▲▲ */

      /* ▼▼▼ 【全新】分享链接功能样式 (无图版) ▼▼▼ */

      /* 1. 浏览器界面背景色和内容区样式 (保持不变) */
      #browser-screen {
        background-color: #f8f9fa;
      }
      #browser-content {
        padding: 20px;
        font-size: 16px;
        line-height: 1.8;
        color: #333;
        overflow-y: auto;
        background-color: #f8f9fa;
      }
      #browser-content .article-title {
        font-size: 24px;
        font-weight: 700;
        margin-bottom: 10px;
      }
      #browser-content .article-meta {
        font-size: 13px;
        color: #8a8a8a;
        margin-bottom: 25px;
        padding-bottom: 15px;
        border-bottom: 1px solid #e0e0e0;
      }
      #browser-content .article-body {
        white-space: pre-wrap;
        word-break: break-word;
      }
      #browser-content .article-body p {
        margin-bottom: 1em;
      }

      /* 2. 聊天气泡中的链接卡片样式 (无图版) */
      .message-bubble.is-link-share .content {
        padding: 0;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }

      .link-share-card {
        width: 210px;
        background-color: #fff;
        border-radius: 10px;
        border: 1px solid #e0e0e0;
        padding: 12px;
        cursor: pointer;
        transition: background-color 0.2s;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .link-share-card:hover {
        background-color: #f9f9f9;
      }

      .link-share-card .title {
        font-weight: 600;
        font-size: 15px;
        line-height: 1.4;
        color: #1f1f1f;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .link-share-card .description {
        font-size: 13px;
        color: #8a8a8a;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .link-share-card .footer {
        display: flex; /* 让图标和文字水平对齐 */
        align-items: center;
        gap: 6px; /* 图标和文字的间距 */
        font-size: 12px;
        color: var(--text-secondary);
        margin-top: 4px; /* 和上面的描述拉开一点距离 */
      }
      .link-share-card .footer-icon {
        width: 14px;
        height: 14px;
        flex-shrink: 0; /* 防止图标被压缩 */
      }

      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* 单条评论的容器，现在需要相对定位 */
      .comment-item {
        position: relative;
        padding-right: 25px; /* 在右侧留出删除按钮的空间 */
      }

      /* 评论删除按钮的样式 */
      .comment-delete-btn {
        position: absolute;
        top: 50%;
        right: 0;
        transform: translateY(-50%);
        width: 22px;
        height: 22px;
        line-height: 22px;
        text-align: center;
        border-radius: 50%;
        color: var(--text-secondary);
        font-size: 18px;
        cursor: pointer;
        transition: all 0.2s ease;
        opacity: 0; /* 默认隐藏 */
      }

      /* 鼠标悬停在评论上时，显示删除按钮 */
      .comment-item:hover .comment-delete-btn {
        opacity: 1;
      }

      .comment-delete-btn:hover {
        background-color: #f0f0f0;
        color: #ff3b30;
      }
      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 【全新】夜间模式样式 === */

      /* 核心：当 #phone-screen 拥有 .dark-mode 类时，激活以下所有样式 */

      /* 1. 全局背景和文本颜色 */
      #phone-screen.dark-mode {
        --secondary-bg: #1c1c1e; /* 主要卡片背景色 */
        --border-color: #38383a; /* 边框颜色 */
        --text-primary: #ffffff; /* 主要文字颜色 */
        --text-secondary: #8d8d92; /* 次要文字/图标颜色 */
      }

      /* 2. 各个页面的主背景色 */
      #phone-screen.dark-mode #chat-list-screen,
      #phone-screen.dark-mode #qzone-screen .qzone-content,
      #phone-screen.dark-mode #memories-view {
        background-color: #000000;
      }

      /* 3. 聊天列表 */
      #phone-screen.dark-mode #chat-list {
        background-color: #000000;
      }
      #phone-screen.dark-mode .chat-list-item {
        border-bottom-color: rgba(255, 255, 255, 0.15);
      }
      #phone-screen.dark-mode .chat-group-header {
        background-color: #1c1c1e; /* 从白色改为深灰色 */
        border-bottom: 1px solid #38383a; /* 给它一个细微的下边框 */
      }
      #phone-screen.dark-mode .chat-list-item .name,
      #phone-screen.dark-mode .chat-group-header .group-name {
        color: #ffffff;
      }
      #phone-screen.dark-mode .chat-list-item:hover {
        background-color: #1c1c1e;
      }

      /* 4. 顶部/底部导航栏 */
      #phone-screen.dark-mode .header,
      #phone-screen.dark-mode .qzone-header {
        background-color: rgba(25, 25, 25, 0.9);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-bottom-color: rgba(255, 255, 255, 0.15);
        color: #ffffff;
      }
      #phone-screen.dark-mode .header .back-btn,
      #phone-screen.dark-mode .header .action-btn,
      #phone-screen.dark-mode .header .save-btn {
        color: #ffffff;
      }
      #phone-screen.dark-mode #chat-list-bottom-nav {
        background-color: rgba(25, 25, 25, 0.9);
        border-top-color: rgba(255, 255, 255, 0.15);
      }
      #phone-screen.dark-mode .nav-item.active {
        color: #ffffff;
      }

      /* 5. 聊天界面 */
      #phone-screen.dark-mode #chat-input-area {
        background-color: rgba(5, 5, 5, 0.8);
        border-top: none;
      }
      #phone-screen.dark-mode #chat-input {
        background-color: #3e3e42;
        color: #ffffff;
      }
      #phone-screen.dark-mode #chat-input::placeholder {
        color: #8d8d92;
      }
      #phone-screen.dark-mode .chat-action-icon-btn {
        color: #ffffff;
        background-color: rgba(255, 255, 255, 0.1);
        border: none;
      }
      #phone-screen.dark-mode #send-btn {
        background-color: var(--accent-color);
      }

      /* 6. 动态 (QZone) 界面 */
      #phone-screen.dark-mode .qzone-actions-bar,
      #phone-screen.dark-mode .qzone-post-item {
        background-color: #1c1c1e;
        border: 1px solid #333;
        box-shadow: 0 2px 8px rgba(255, 255, 255, 0.05);
      }
      #phone-screen.dark-mode .action-item:not(:last-child)::after {
        background-color: #333;
      }
      #phone-screen.dark-mode .post-footer,
      #phone-screen.dark-mode .post-likes-section {
        border-top-color: #333;
      }
      #phone-screen.dark-mode .post-likes-section {
        background-color: rgba(0, 123, 255, 0.1);
      }
      #phone-screen.dark-mode .comment-input {
        background-color: #333;
        color: #ffffff;
      }
      #phone-screen.dark-mode .comment-input::placeholder {
        color: #8d8d92;
      }
      #phone-screen.dark-mode .post-actions-btn:hover {
        background-color: #333;
      }
      #phone-screen.dark-mode .at-mention-popup {
        background-color: #1c1c1e;
        border-color: #333;
      }
      #phone-screen.dark-mode .at-mention-item {
        border-bottom-color: #333;
      }
      #phone-screen.dark-mode .at-mention-item:hover {
        background-color: #333;
      }

      /* 7. 回忆录界面 */
      #phone-screen.dark-mode .memory-card {
        background-color: #1c1c1e;
        border-left-color: #e6a753;
        box-shadow: 0 4px 12px rgba(255, 255, 255, 0.08);
      }
      #phone-screen.dark-mode .memory-card .header {
        background-color: #2c2c2e;
        border-bottom-color: #38383a;
        margin: -15px -15px 8px -15px;
        padding: 12px 15px;
        border-radius: 12px 12px 0 0;
      }
      #phone-screen.dark-mode .memory-card .header .date,
      #phone-screen.dark-mode .memory-card .header .author,
      #phone-screen.dark-mode .memory-card .content {
        color: #e0e0e0;
      }

      /* 8. 其他设置和列表页 */
      #phone-screen.dark-mode #api-settings-screen,
      #phone-screen.dark-mode #font-settings-screen,
      #phone-screen.dark-mode #wallpaper-screen,
      #phone-screen.dark-mode #contact-picker-screen,
      #phone-screen.dark-mode #member-management-screen,
      #phone-screen.dark-mode #world-book-editor-screen,
      #phone-screen.dark-mode #world-book-list,
      #phone-screen.dark-mode .list-item:hover,
      #phone-screen.dark-mode .list-container,
      #phone-screen.dark-mode .form-container {
        background-color: #000000;
      }
      #phone-screen.dark-mode .form-group input,
      #phone-screen.dark-mode .form-group select,
      #phone-screen.dark-mode .form-group textarea {
        background-color: #1c1c1e;
        color: #ffffff;
        border-color: #38383a;
      }
      #phone-screen.dark-mode .form-button-secondary {
        background-color: #333;
        border-color: #555;
        color: #fff;
      }
      #phone-screen.dark-mode #font-preview {
        background-color: #1c1c1e;
        border-color: #38383a;
      }
      #phone-screen.dark-mode #font-preview p {
        color: #ffffff;
      }

      /* ▲▲▲ 粘贴结束 ▲▲▲ */

      /* ▼▼▼ 把这一整块【全新的修正CSS】，粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 【全新】夜间模式视觉修正 === */

      /* 1. 修正动态卡片内的文字颜色 */
      #phone-screen.dark-mode .qzone-post-item .post-nickname,
      #phone-screen.dark-mode .qzone-post-item .post-content {
        color: #f0f0f0; /* 从深灰色改为明亮的浅灰色 */
      }

      /* 2. 修正收藏卡片内的文字颜色 */
      #phone-screen.dark-mode .favorite-item-card .fav-card-header .name,
      #phone-screen.dark-mode .favorite-item-card .fav-card-content {
        color: #f0f0f0; /* 同样改为浅灰色 */
      }
      #phone-screen.dark-mode .favorite-item-card .fav-card-header .source {
        color: #8d8d92; /* 来源文字用次要灰色 */
      }

      /* 3. 修正收藏页的搜索栏背景和输入框样式 */
      #phone-screen.dark-mode .search-bar-container {
        background-color: #000000; /* 容器背景变为纯黑 */
      }
      #phone-screen.dark-mode #favorites-search-input {
        background-color: #1c1c1e; /* 输入框背景变为深灰 */
        border-color: #38383a; /* 边框颜色变暗 */
        color: #ffffff; /* 输入文字变为白色 */
      }
      #phone-screen.dark-mode #favorites-search-input::placeholder {
        color: #8d8d92; /* 占位符文字颜色变暗 */
      }

      /* ▲▲▲ 修正CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 【全新】iOS风格的Toggle Switch开关样式 === */

      /* 1. 开关的容器 */
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 51px;
        height: 31px;
      }

      /* 2. 隐藏掉原始的 checkbox 输入框 */
      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      /* 3. 开关的背景（那个椭圆） */
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #e9e9eb; /* 关闭时的背景色 */
        transition: 0.4s;
        border-radius: 34px;
      }

      /* 4. 开关上的圆点 */
      .slider:before {
        position: absolute;
        content: "";
        height: 27px;
        width: 27px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }

      /* 5. 【核心】当 checkbox 被选中时（即开启状态） */
      input:checked + .slider {
        background-color: #34c759; /* 开启时的背景色（iOS绿色）*/
      }

      input:checked + .slider:before {
        transform: translateX(20px); /* 让圆点滑动到右边 */
      }

      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】引用回复功能样式 ▼▼▼ */

      /* 1. 输入框上方的“回复预览栏” */
      #reply-preview-bar {
        display: none; /* 默认隐藏 */
        padding: 8px 12px;
        margin: 0 8px 8px 8px; /* 和输入框周围的边距保持一致 */
        background-color: rgba(0, 0, 0, 0.05);
        border-left: 3px solid var(--accent-color);
        border-radius: 6px;
        position: relative;
        font-size: 13px;
        color: var(--text-secondary);
      }

      #phone-screen.dark-mode #reply-preview-bar {
        background-color: rgba(255, 255, 255, 0.1);
      }

      .reply-preview-content .sender {
        font-weight: 600;
        color: var(--text-primary);
      }

      .reply-preview-content .text {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: block; /* 确保省略号生效 */
        max-width: 95%;
      }

      #cancel-reply-btn {
        position: absolute;
        top: 50%;
        right: 8px;
        transform: translateY(-50%);
        width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.1);
        cursor: pointer;
        font-size: 14px;
      }

      /* 2. 消息气泡内部的“引用消息块” */
      .quoted-message {
        padding: 6px 10px;
        margin-bottom: 6px;
        background-color: rgba(0, 0, 0, 0.04);
        border-left: 2px solid var(--accent-color);
        border-radius: 4px;
        font-size: 0.9em; /* 字体比正文小一点 */
        opacity: 0.8;
        /* (已移除 overflow: hidden;) */
      }

      #phone-screen.dark-mode .quoted-message {
        background-color: rgba(255, 255, 255, 0.08);
        border-left-color: #a0cff1;
      }

      .quoted-message .quoted-sender {
        font-weight: 600;
        color: var(--accent-color);
      }
      #phone-screen.dark-mode .quoted-message .quoted-sender {
        color: #a0cff1;
      }

      .quoted-message .quoted-content {
        color: var(--text-secondary);
        white-space: normal; /* 核心修正1: 允许文本正常换行 */
        word-break: break-word; /* 核心修正2: 强制长单词或连续字符断开，防止溢出 */
        display: block;
        /* (已移除 overflow 和 text-overflow，因为我们需要多行显示而不是单行省略号) */
      }

      /* === 字体预览框样式 (修正后) === */

      /* 默认（日间模式）的样式 */
      #font-preview {
        padding: 20px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: #f9f9f9; /* 日间模式的浅灰色背景 */
        transition: background-color 0.3s, border-color 0.3s;
      }

      /* 预览框里的文字颜色，默认是黑色 */
      #font-preview p {
        color: var(--text-primary);
      }

      /* 夜间模式下的修正样式 */
      #phone-screen.dark-mode #font-preview {
        background-color: #1c1c1e; /* 深灰色背景 */
        border-color: #38383a; /* 暗色边框 */
      }

      /* 夜间模式下，预览框里的文字变为白色 */
      #phone-screen.dark-mode #font-preview p {
        color: #ffffff;
      }

      /* ▼▼▼ 【全新】精致版转账操作弹窗样式 ▼▼▼ */
      .transfer-actions-content {
        background-color: #fff0f5; /* 粉嫩的背景色 */
        border-radius: 20px;
        width: 290px;
        padding: 20px;
        box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); /* 粉色阴影 */
        text-align: center;
        position: relative;
        border: 1px solid #ffcce0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }

      .transfer-actions-header {
        font-size: 20px;
        font-weight: bold;
        color: #a35c7b; /* 深粉色标题 */
        margin-bottom: 15px;
      }

      .transfer-actions-body p {
        font-size: 15px;
        color: #555;
        margin: 0 0 25px 0;
        line-height: 1.5;
      }

      .transfer-actions-footer {
        display: flex;
        justify-content: space-between;
        gap: 15px;
      }

      .transfer-actions-footer .action-btn {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 12px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        color: white;
      }

      .transfer-actions-footer .action-btn:active {
        transform: scale(0.95);
      }

      .transfer-actions-footer .action-btn.accept {
        background: linear-gradient(135deg, #ff85b3, #ff69b4);
        box-shadow: 0 4px 10px rgba(255, 105, 180, 0.4);
      }

      .transfer-actions-footer .action-btn.decline {
        background: linear-gradient(135deg, #c2c2c2, #a0a0a0);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }

      .transfer-actions-content .cancel-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: none;
        background-color: rgba(0, 0, 0, 0.1);
        color: #a35c7b;
        font-size: 20px;
        line-height: 28px;
        cursor: pointer;
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

      /* === 未读消息红点样式 === */
      .unread-count-wrapper {
        flex-shrink: 0;
        width: 40px;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding-top: 20px; /* 让红点和名字差不多高 */
      }

      .unread-count {
        min-width: 20px;
        height: 20px;
        padding: 0 6px;
        background-color: #ff3b30; /* iOS 风格的红色 */
        color: white;
        font-size: 13px;
        font-weight: 500;
        line-height: 20px;
        text-align: center;
        border-radius: 10px; /* 圆角矩形 */
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
        display: none; /* 默认隐藏 */
        justify-content: center;
        align-items: center;
      }
      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】通话记录页面与卡片样式 ▼▼▼ */

      /* 确保页面背景色统一 */
      #call-history-screen {
        background-color: #f0f2f5;
      }

      /* 通话记录卡片样式 */
      .call-record-card {
        background-color: var(--secondary-bg);
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        border-left: 5px solid var(--accent-color);
      }
      .call-record-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
      }

      /* 卡片头部：包含日期和时长 */
      .call-record-card .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 13px;
        color: var(--text-secondary);
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid var(--border-color);
      }
      .call-record-card .card-header .duration {
        font-weight: 500;
        color: var(--text-primary);
      }

      /* 卡片主体：参与者头像 */
      .call-record-card .card-body {
        display: flex;
        align-items: center;
      }
      .call-record-card .participants-avatars {
        display: flex;
        align-items: center;
      }
      .call-record-card .participant-avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      /* 让头像有一个漂亮的堆叠效果 */
      .call-record-card .participant-avatar:not(:first-child) {
        margin-left: -12px;
      }
      .call-record-card .participants-names {
        margin-left: 12px;
        font-weight: 600;
        color: var(--text-primary);
        font-size: 15px;
      }

      /* --- 通话详情弹窗样式 --- */
      #transcript-modal-body {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 15px;
      }
      .transcript-entry {
        padding: 8px 12px;
        border-radius: 10px;
        max-width: 85%;
        line-height: 1.5;
        word-break: break-word;
      }
      .transcript-entry.user {
        background-color: #dcf8c6; /* 类似微信的绿色 */
        align-self: flex-end;
      }
      .transcript-entry.assistant {
        background-color: #ffffff;
        align-self: flex-start;
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      #chat-list-title {
        cursor: pointer;
      }

      /* ▼▼▼ 【全新】通话记录卡片美化样式 ▼▼▼ */

      .call-record-card .card-body {
        /* 将 body 改为 flex 布局，让标题和参与者信息垂直排列 */
        display: flex;
        flex-direction: column;
        gap: 8px; /* 标题和参与者信息之间的间距 */
      }

      .call-record-card .custom-title {
        font-size: 16px;
        font-weight: 600; /* 加粗，让它像个标题 */
        color: var(--text-primary);
        padding-bottom: 8px; /* 标题下的留白 */
        border-bottom: 1px solid var(--border-color); /* 在标题下加一条分割线 */
        margin-bottom: 4px; /* 和下面的参与者信息拉开一点距离 */
      }

      .call-record-card .participants-info {
        /* 这个新容器让头像和“与xx”能水平对齐 */
        display: flex;
        align-items: center;
      }

      /* 参与者名字的样式微调，让它不那么突出 */
      .call-record-card .participants-names {
        margin-left: 12px;
        font-weight: 500; /* 不再加粗 */
        font-size: 14px; /* 稍微小一点 */
        color: var(--text-secondary); /* 使用次要文字颜色 */
      }

      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】语音转文字功能样式 ▼▼▼ */

      /* 1. 语音文字内容的样式 */
      .voice-transcript {
        font-size: 14px; /* 文字大小 */
        line-height: 1.6; /* 行高，让多行文本更易读 */
        color: var(--text-secondary); /* 使用次要文字颜色，与语音条区分 */
        padding: 8px 12px; /* 内边距 */
        margin-top: 6px; /* 和上方的语音条拉开一点距离 */
        background-color: rgba(
          0,
          0,
          0,
          0.04
        ); /* 给一个淡淡的背景，更有层次感 */
        border-radius: 6px; /* 圆角 */
        word-break: break-word; /* 确保长文本能正常换行 */
        display: none; /* 默认隐藏 */
      }

      #phone-screen.dark-mode .voice-transcript {
        background-color: rgba(255, 255, 255, 0.1); /* 夜间模式下的背景色 */
      }

      /* 2. 旋转加载动画的样式 */
      .loading-spinner {
        display: none; /* 默认隐藏 */
        width: 16px;
        height: 16px;
        border: 2px solid rgba(0, 0, 0, 0.2);
        border-top-color: var(--accent-color); /* 旋转部分的颜色 */
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 8px; /* 和波形图、时长保持一点间距 */
      }

      /* 3. 定义旋转动画 */
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      /* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】分享记录查看器样式修正 ▼▼▼ */
      #shared-history-viewer-content {
        display: flex;
        flex-direction: column; /* 让气泡垂直排列 */
        gap: 20px; /* 在每个气泡之间增加20像素的间距 */
        padding: 15px; /* 在容器四周也增加一些内边距，避免气泡贴边 */
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】播放器和歌词样式 ▼▼▼ */
      #music-player-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 50;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding-top: 60px;
        background-color: rgba(0, 0, 0, 0.3);
        opacity: 0;
        visibility: hidden;
        transform: translateY(-50px);
        transition: opacity 0.4s ease-out,
          transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      #music-player-overlay.visible {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
      }

      .music-player-window {
        width: 70%;
        min-height: 420px;
        background-color: rgba(255, 255, 255, 0.6);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-radius: 25px;
        box-shadow: 0 8px 32px 0 rgba(25, 25, 25, 0.37);
        border: 1px solid rgba(255, 255, 255, 0.18);
        padding: 25px;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: #1f1f1f;
        position: relative;
        justify-content: space-between;
        padding-bottom: 15px;
      }

      .music-player-top-actions {
        position: absolute;
        top: 15px;
        left: 15px;
        right: 15px;
        width: calc(100% - 30px);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .top-left-cluster {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      #music-return-btn,
      #music-exit-btn {
        background: none;
        border: none;
        font-size: 28px;
        font-weight: 300;
        cursor: pointer;
        color: #555;
        padding: 5px;
        line-height: 1;
      }
      #music-exit-btn {
        font-size: 24px;
        font-weight: 400;
      }

      .music-progress-bar-container {
        width: 100%;
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 25px;
        margin-bottom: 10px;
      }
      .time-display {
        font-size: 11px;
        color: #888;
        width: 35px;
        text-align: center;
        flex-shrink: 0;
        font-family: "SF Mono", "Menlo", monospace;
      }
      .progress-bar {
        flex-grow: 1;
        height: 5px;
        background-color: #e5e5e5;
        border-radius: 2.5px;
        cursor: pointer;
      }
      .progress-bar-fill {
        width: 0%;
        height: 100%;
        background-color: #333;
        border-radius: 2.5px;
      }

      #music-lyrics-container {
        width: 100%;
        height: 192px;
        overflow: hidden;
        position: relative;
        -webkit-mask-image: linear-gradient(
          transparent,
          black 20%,
          black 80%,
          transparent
        );
        mask-image: linear-gradient(
          transparent,
          black 20%,
          black 80%,
          transparent
        );
      }

      #music-lyrics-list {
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
      }

      .lyric-line {
        padding: 4px 0;
        font-size: 14px;
        color: #666;
        text-align: center;
        line-height: 1.5;
        transition: all 0.5s ease;
        opacity: 0.7;
        transform: scale(0.95);
      }

      .lyric-line.active {
        font-size: 16px;
        color: #000;
        opacity: 1;
        transform: scale(1);
      }

      .music-player-controls-wrapper {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .music-controls {
        margin-top: 0;
      }

      #music-return-btn,
      #music-exit-btn,
      #music-playlist-btn {
        position: relative;
      }

      #music-return-btn {
        top: -2px;
      }
      #music-playlist-btn {
        top: -3px;
      }

      .playlist-item-actions {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      .playlist-action-btn {
        font-size: 18px;
        color: #888;
        cursor: pointer;
        transition: color 0.2s;
      }
      .playlist-action-btn:hover {
        color: #000;
      }
      .delete-track-btn {
        font-size: 24px;
        color: #ff3b30;
      }
      .delete-track-btn:hover {
        color: #c00;
      }
      .lyrics-btn {
        font-weight: 500;
      }

      /* --- 【核心修正】确保头像尺寸 --- */
      .message-bubble .avatar {
        width: 34px;
        height: 34px;
        border-radius: 20%;
        object-fit: cover;
        flex-shrink: 0; /* 防止被压缩 */
      }

      /* ▼▼▼ 【全新】撤回消息样式 ▼▼▼ */

      /* 1. 撤回消息的占位符样式 */
      .recalled-message-placeholder {
        align-self: center; /* 居中显示 */
        padding: 4px 12px;
        margin: 5px 0;
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--text-secondary);
        font-size: 12px;
        border-radius: 10px;
        text-align: center;
        max-width: 80%;
        cursor: pointer; /* 让它看起来可以点击 */
      }

      /* 2. 夜间模式下的适配 */
      #phone-screen.dark-mode .recalled-message-placeholder {
        background-color: rgba(255, 255, 255, 0.15);
      }

      /* 3. AI撤回消息时的动画效果 */
      @keyframes recall-animation {
        from {
          opacity: 1;
          transform: scale(1);
        }
        to {
          opacity: 0;
          transform: scale(0.8);
        }
      }

      .message-wrapper.recalled-animation {
        animation: recall-animation 0.3s ease-out forwards;
      }

      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】撤回消息样式修正 ▼▼▼ */

      /* 强制撤回消息的占位符不换行，并保持内容居中 */
      .recalled-message-placeholder {
        white-space: nowrap; /* 核心：禁止文本换行 */
        display: inline-block; /* 让背景根据内容自适应宽度 */
        padding: 4px 12px;
      }

      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】世界书分类列表样式 ▼▼▼ */
      .world-book-group-container {
        border-bottom: 1px solid var(--border-color);
      }
      .world-book-group-container:first-child {
        border-top: 1px solid var(--border-color);
      }
      .world-book-group-header {
        display: flex;
        align-items: center;
        padding: 12px 15px;
        cursor: pointer;
        background-color: #f7f7f7;
      }
      .world-book-group-header .arrow {
        font-size: 14px;
        margin-right: 8px;
        transition: transform 0.2s ease;
      }
      .world-book-group-header.collapsed .arrow {
        transform: rotate(-90deg);
      }
      .world-book-group-header .group-name {
        font-weight: 600;
        font-size: 15px;
      }
      .world-book-group-content {
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out;
      }
      .world-book-group-content.collapsed {
        max-height: 0;
      }
      #phone-screen.dark-mode .world-book-group-header {
        background-color: #1c1c1e;
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】红包/转账模态框页签样式 ▼▼▼ */
      .frame-tabs {
        display: flex;
        background-color: #f0f0f0;
        padding: 4px;
        margin: 15px;
        border-radius: 8px;
      }
      .frame-tab {
        flex: 1;
        text-align: center;
        padding: 8px;
        font-size: 14px;
        font-weight: 500;
        color: #555;
        cursor: pointer;
        border-radius: 6px;
        transition: all 0.2s ease-in-out;
      }
      .frame-tab.active {
        background-color: #ffffff;
        color: #000000;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 请将这段全新的CSS粘贴到 <style> 的末尾 ▼▼▼ */

      /* 1. 分类文件夹的样式 */
      .wb-category-header {
        display: flex;
        align-items: center;
        padding: 10px 12px;
        cursor: pointer;
        background-color: #f0f2f5; /* 给文件夹一个淡淡的背景色以区分 */
        font-weight: 600; /* 加粗字体 */
      }
      #phone-screen.dark-mode .wb-category-header {
        background-color: #2c2c2e; /* 夜间模式下的背景色 */
      }

      /* 2. 展开/收起的小箭头 */
      .wb-category-header .arrow {
        font-size: 12px;
        margin-right: 8px;
        transition: transform 0.2s ease;
      }

      /* 3. 当文件夹收起时，箭头旋转 */
      .wb-category-header.collapsed .arrow {
        transform: rotate(-90deg);
      }

      /* 4. 存放书籍条目的容器 */
      .wb-book-container {
        padding-left: 20px; /* 核心：让书籍条目向内缩进，看起来像在文件夹里 */
        max-height: 1000px; /* 一个足够大的值，用于动画 */
        overflow: hidden;
        transition: max-height 0.3s ease-in-out;
      }

      /* 5. 当文件夹收起时，书籍容器的高度变为0，实现动画效果 */
      .wb-book-container.collapsed {
        max-height: 0;
      }

      /* 6. 单个书籍条目（覆盖默认的label样式，微调间距） */
      .wb-book-container label {
        padding: 8px 12px;
      }

      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

      /* ▼▼▼ 【全新】世界书关联选择器 - 视觉优化 ▼▼▼ */

      /* 1. 让分类标题更突出 */
      .wb-category-header > span:last-of-type {
        font-size: 14px;
        font-weight: 700; /* 加粗 */
        color: var(--text-primary);
      }

      /* 2. 为箭头设置一个漂亮的颜色循环 */
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 1)
        .arrow {
        color: #007bff;
      } /* 蓝色 */
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 2)
        .arrow {
        color: #28a745;
      } /* 绿色 */
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 3)
        .arrow {
        color: #fd7e14;
      } /* 橙色 */
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 4)
        .arrow {
        color: #6f42c1;
      } /* 紫色 */
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 5)
        .arrow {
        color: #dc3545;
      } /* 红色 */
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 6)
        .arrow {
        color: #ffc107;
      } /* 黄色 */

      /* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
      #video-call-floating-bubble {
        position: absolute;
        right: 20px;
        top: 150px;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        overflow: hidden;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        z-index: 999;
        cursor: pointer;
        border: 3px solid white;
        transition: transform 0.2s;
      }
      #video-call-floating-bubble:active {
        transform: scale(0.95);
      }
      #video-floating-avatar {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
/* --- 13.2 API 配置列表样式 --- */
#api-configs-list { display: flex; flex-direction: column; gap: 12px; }
.api-config-item { background-color: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 10px; padding: 12px; display: flex; justify-content: space-between; align-items: center; }
#phone-screen.dark-mode .api-config-item { background-color: #2c2c2e; }
.api-config-item .config-main { display: flex; align-items: center; gap: 12px; flex-grow: 1; overflow: hidden; }
.api-config-item input[type="radio"] { width: 20px; height: 20px; flex-shrink: 0; accent-color: var(--accent-color); }
.api-config-item .config-details { display: flex; flex-direction: column; gap: 2px; overflow: hidden; }
.api-config-item .config-name { font-weight: 600; color: var(--text-primary); font-size: 15px; }
.api-config-item .config-url { font-size: 12px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.api-config-item .config-actions { display: flex; gap: 8px; flex-shrink: 0; }
.api-config-item .config-actions button { padding: 5px 10px; font-size: 12px; border-radius: 5px; cursor: pointer; border: 1px solid transparent; }
.api-config-item .config-actions .edit-btn { background-color: #e7f3ff; color: var(--accent-color); }
.api-config-item .config-actions .delete-btn { background-color: #ffebee; color: #c62828; }

/* 用于替换内'style'的工具类 */
.form-group-flex { display: flex; justify-content: space-between; align-items: center; }

    </style>
  </head>
  <body>
    <div id="phone-frame">
      <div class="notch"></div>
      <div id="phone-screen">
        <div id="status-bar">
          <span id="status-bar-time">12:00</span>
          <div id="status-bar-battery" class="battery-container">
            <span class="battery-text">--%</span>
            <div class="battery-icon">
              <div class="battery-level"></div>
            </div>
          </div>
        </div>
      <div id="video-call-floating-bubble" style="display: none">
        <img id="video-floating-avatar" src="" />
      </div>
      <div id="video-call-floating-bubble" style="display: none">
        <img id="video-floating-avatar" src="" />
      </div>
      <div id="video-call-floating-bubble" style="display: none">
        <img id="video-floating-avatar" src="" />
      </div>
        <div id="notification-bar">
          <img id="notification-avatar" src="" />
          <div id="notification-content">
            <div class="name"></div>
            <div class="message"></div>
          </div>
        </div>

        <div id="home-screen" class="screen active">
          <div id="clock-container">
            <div id="main-time">12:00</div>
            <div id="main-date">星期一, 1月1日</div>
          </div>
          <!-- ▼▼▼ 用这整块代码替换你原来的 id="app-grid" ▼▼▼ -->
          <div id="app-grid">
            <!-- 第一行：放2个图标 -->
            <div class="app-row">
              <div class="app-icon" onclick="showScreen('world-book-screen')">
                <div class="icon-bg">
                  <!-- 【核心修改1】添加ID -->
                  <img
                    id="icon-img-world-book"
                    src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg"
                    alt="世界书"
                  />
                </div>
                <span class="label">世界书</span>
              </div>
              <div class="app-icon" onclick="showScreen('chat-list-screen')">
                <div class="icon-bg">
                  <!-- 【核心修改2】添加ID -->
                  <img
                    id="icon-img-qq"
                    src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg"
                    alt="QQ"
                  />
                </div>
                <span class="label">QQ</span>
              </div>
            </div>
            <!-- 第二行：放3个图标 -->
            <div class="app-row">
              <div class="app-icon" onclick="showScreen('api-settings-screen')">
                <div class="icon-bg">
                  <!-- 【核心修改3】添加ID -->
                  <img
                    id="icon-img-api-settings"
                    src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg"
                    alt="API设置"
                  />
                </div>
                <span class="label">API设置</span>
              </div>
              <div class="app-icon" onclick="showScreen('wallpaper-screen')">
                <div class="icon-bg">
                  <!-- 【核心修改4】添加ID -->
                  <img
                    id="icon-img-wallpaper"
                    src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg"
                    alt="外观设置"
                  />
                </div>
                <span class="label">外观设置</span>
              </div>
              <div
                class="app-icon"
                onclick="showScreen('font-settings-screen')"
              >
                <div class="icon-bg">
                  <!-- 【核心修改5】添加ID -->
                  <img
                    id="icon-img-font"
                    src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg"
                    alt="字体"
                  />
                </div>
                <span class="label">字体</span>
              </div>
            </div>
          </div>
          <!-- ▲▲▲ 替换结束 ▲▲▲ -->
        </div>

        <div id="world-book-screen" class="screen">
          <div class="header">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <span>世界书</span>
            <div class="header-actions">
              <!-- 【推荐】用一个容器把按钮包起来 -->
              <span class="action-btn" id="manage-world-book-categories-btn"
                >管理分类</span
              >
              <span class="action-btn" id="add-world-book-btn">+</span>
            </div>
          </div>
          <div id="world-book-list"></div>
        </div>
        <div id="world-book-editor-screen" class="screen">
          <div class="header">
            <span class="back-btn" onclick="showScreen('world-book-screen')"
              >‹</span
            >
            <span id="world-book-editor-title">编辑世界书</span>
            <span class="save-btn" id="save-world-book-btn">保存</span>
          </div>
          <div class="form-container">
            <div class="form-group">
              <label for="world-book-name-input">书名</label>
              <input
                type="text"
                id="world-book-name-input"
                placeholder="请输入世界书的名称..."
              />
            </div>

            <!-- ▼▼▼ 【全新】在这里添加分类选择 ▼▼▼ -->
            <div class="form-group">
              <label for="world-book-category-select">分类</label>
              <select id="world-book-category-select">
                <!-- 选项将由JS动态生成 -->
              </select>
            </div>
            <!-- ▲▲▲ 添加结束 ▲▲▲ -->

            <div class="form-group" style="height: 100%">
              <label for="world-book-content-input">内容</label>
              <textarea
                id="world-book-content-input"
                placeholder="在此处输入详细的世界观设定..."
              ></textarea>
            </div>
          </div>
        </div>

        <div id="api-settings-screen" class="screen">
          <div class="header">
            <button type="button" class="back-btn" onclick="showScreen('home-screen')">‹</button>
            <span>API 设置</span>
            <span style="width: 30px"></span>
          </div>
          <div class="form-container">
            <div class="form-group">
              <label>API 配置管理</label>
              <div id="api-configs-list">
                <!-- API 配置列表将由 JS 动态生成 -->
              </div>
              <button
                type="button"
                class="form-button form-button-secondary"
                id="add-new-config-btn"
                style="margin-top: 15px"
              >
                + 添加新配置
              </button>
            </div>

            <hr style="margin: 20px 0; opacity: 0.3" />

            <div class="form-group form-group-flex">
              <label for="background-activity-switch" style="margin-bottom: 0">
                启用后台角色活动
                <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px">
                  警告：此功能会显著增加API调用和费用！
                </p>
              </label>
              <input
                type="checkbox"
                id="background-activity-switch"
                style="width: auto; height: 20px"
              />
            </div>
            <div class="form-group form-group-flex" style="margin-top: 10px">
              <label for="background-interval-input" style="margin-bottom: 0">
                后台活动检测间隔 (秒)
                <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px">
                  建议值 60-300。值越大，费用越低，但角色反应越慢。
                </p>
              </label>
              <input
                type="number"
                id="background-interval-input"
                min="30"
                value="60"
                style="width: 80px; text-align: center"
              />
            </div>
            <div class="form-group form-group-flex" style="margin-top: 10px">
              <label for="block-cooldown-input" style="margin-bottom: 0">
                AI被拉黑后冷静期 (小时)
                <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px">
                  被拉黑超过这个时间后，AI才有几率重新申请好友。
                </p>
              </label>
              <input
                type="number"
                id="block-cooldown-input"
                min="0.1"
                step="0.1"
                value="1"
                style="width: 80px; text-align: center"
              />
            </div>

            <hr style="margin: 20px 0; opacity: 0.3" />

            <button type="button" class="form-button" id="export-data-btn">导出数据</button>
            <button type="button" class="form-button" id="import-btn">导入备份文件</button>
            <input id="import-data-input" type="file" accept="application/json" hidden />
          </div>
        </div>
        <!-- ▼▼▼ 用下面这段代码，完整替换掉你原来的 chat-list-screen ▼▼▼ -->
        <div id="chat-list-screen" class="screen">
          <!-- 主头部 (只在消息列表显示) -->
          <div class="header" id="main-chat-list-header">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <span id="chat-list-title">消息</span>
            <div class="header-actions">
              <span class="action-btn" id="add-group-chat-btn" title="创建群聊"
                ><svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M21 21L19 19"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  /></svg
              ></span>
              <span class="action-btn" id="add-chat-btn">+</span>
            </div>
          </div>

          <!-- 消息列表视图 -->
          <div id="messages-view" class="chat-list-view active">
            <div id="chat-list">
              <!-- JS会在这里生成聊天列表 -->
            </div>
          </div>

          <!-- 动态界面视图 -->
          <div id="qzone-screen" class="chat-list-view">
            <div class="qzone-header">
              <span class="back-btn" id="qzone-back-btn">‹</span>
              <!-- 这个按钮现在只负责从动态返回 -->
              <span>好友动态</span>
            </div>
            <div class="qzone-content">
              <div class="qzone-profile-header">
                <div id="qzone-banner-container" class="qzone-banner-container">
                  <img
                    id="qzone-banner-img"
                    src="https://files.catbox.moe/r5heyt.gif"
                    alt="背景"
                  />
                  <input
                    type="file"
                    id="qzone-banner-input"
                    accept="image/*"
                    hidden
                  />
                </div>
                <div class="qzone-user-info">
                  <div
                    id="qzone-avatar-container"
                    class="qzone-avatar-container"
                  >
                    <img
                      id="qzone-avatar-img"
                      src="https://files.catbox.moe/q6z5fc.jpeg"
                      alt="头像"
                    />
                    <input
                      type="file"
                      id="qzone-avatar-input"
                      accept="image/*"
                      hidden
                    />
                  </div>
                  <span id="qzone-nickname">{{user}}</span>
                </div>
              </div>
              <div class="qzone-actions-bar">
                <div class="action-item" id="create-shuoshuo-btn">
                  <span>说说</span>
                </div>
                <div class="action-item" id="create-post-btn">
                  <span>动态</span>
                </div>
                <div class="action-item" id="open-album-btn">
                  <span>相册</span>
                </div>
              </div>
              <div id="qzone-posts-list"></div>
            </div>
          </div>

          <!-- 收藏界面视图 -->
          <div id="favorites-view" class="chat-list-view">
            <div class="header">
              <span class="back-btn" id="favorites-back-btn">‹</span>
              <span>我的收藏</span>
              <!-- 新增的编辑按钮 -->
              <span class="action-btn" id="favorites-edit-btn">编辑</span>
            </div>

            <!-- 【新增】搜索栏容器 -->
            <div class="search-bar-container">
              <input
                type="search"
                id="favorites-search-input"
                placeholder="搜索收藏的标题、内容或作者..."
              />
              <button
                id="favorites-search-clear-btn"
                class="search-clear-btn"
                style="display: none"
              >
                ×
              </button>
            </div>

            <div id="favorites-list" class="list-container">
              <!-- 收藏内容将由JS动态生成在这里 -->
            </div>

            <!-- 新增：收藏页底部操作栏 -->
            <div id="favorites-action-bar" style="display: none">
              <button id="favorites-delete-selected-btn" class="action-bar-btn">
                删除 (0)
              </button>
            </div>
          </div>

          <!-- ▼▼▼ 【全新】回忆录界面视图 ▼▼▼ -->
          <div id="memories-view" class="chat-list-view">
            <div class="header">
              <span class="back-btn" id="memories-back-btn">‹</span>
              <span>我们的回忆</span>
              <span class="action-btn" id="add-countdown-btn">+</span>
            </div>
            <div
              id="memories-list"
              class="list-container"
              style="
                padding: 15px;
                display: flex;
                flex-direction: column;
                gap: 15px;
              "
            >
              <!-- 回忆卡片将由JS动态生成在这里 -->
            </div>
          </div>
          <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

          <!-- 底部导航栏 -->
          <div id="chat-list-bottom-nav">
            <div class="nav-item active" data-view="messages-view">
              <span>消息</span>
            </div>
            <div class="nav-item" data-view="qzone-screen">
              <span>动态</span>
            </div>
            <!-- ▼▼▼ 在“动态”和“收藏”之间，加入这个新页签 ▼▼▼ -->
            <div class="nav-item" data-view="memories-view">
              <span>回忆</span>
            </div>
            <!-- ▲▲▲ 添加结束 ▲▲▲ -->
            <div class="nav-item" data-view="favorites-view">
              <span>收藏</span>
            </div>
          </div>
        </div>
        <!-- ▲▲▲ 替换区域结束 ▲▲▲ -->

        <!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="chat-list-screen" 的 div 之后 ▼▼▼ -->
        <div id="album-screen" class="screen">
          <!-- 1. 页面头部，包含返回按钮和标题 -->
          <div class="header">
            <span class="back-btn" id="album-back-btn">‹</span>
            <span>我的相册</span>
            <span class="action-btn" id="create-album-btn-page">+</span>
          </div>

          <!-- 2. 页面内容容器 -->
          <div class="list-container">
            <div id="album-grid-page">
              <!-- 相册列表将由 JS 动态生成在这里 -->
            </div>
          </div>
        </div>
        <!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

        <!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="album-screen" 的 div 之后 ▼▼▼ -->
        <div id="album-photos-screen" class="screen">
          <!-- 1. 页面头部 -->
          <div class="header">
            <span class="back-btn" id="album-photos-back-btn">‹</span>
            <span id="album-photos-title">相册名称</span>
            <span class="action-btn" id="album-upload-photo-btn">上传</span>
          </div>

          <!-- 2. 页面内容容器 -->
          <div class="list-container">
            <div id="photos-grid-page">
              <!-- 照片列表将由 JS 动态生成在这里 -->
            </div>

            <!-- ▼▼▼ 请将这段新的 HTML 粘贴到所有模态框的末尾 ▼▼▼ -->
            <div id="photo-viewer-modal" class="modal">
              <!-- 1. 关闭按钮 -->
              <button id="photo-viewer-close-btn">×</button>

              <!-- 2. 上一张照片按钮 -->
              <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>

              <!-- 3. 图片容器 -->
              <div class="photo-viewer-content">
                <img id="photo-viewer-image" src="" alt="全屏照片预览" />
              </div>

              <!-- 4. 下一张照片按钮 -->
              <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
            </div>
            <!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->
          </div>
        </div>
        <!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

        <!-- ▼▼▼ 粘贴到 #album-photos-screen 的 div 之后 ▼▼▼ -->
        <input
          type="file"
          id="album-photo-input"
          accept="image/*"
          multiple
          hidden
        />

        <!-- ▼▼▼ 请用这【一整块】全新的代码，完整替换掉您文件中旧的 #chat-interface-screen 及其所有内容 ▼▼▼ -->
        <div id="chat-interface-screen" class="screen">
          <!-- 【最终修正版】Header，已将状态栏和搜索功能正确整合 -->
          <div class="header">
            <!-- 默认控件：包含标题、状态栏和常规按钮 -->
            <div class="default-controls">
              <span class="back-btn" id="back-to-list-btn">‹</span>

              <!-- ▼▼▼ 【核心新增】标题和状态的容器 ▼▼▼ -->
              <div id="chat-header-title-wrapper">
                <span id="chat-header-title">聊天对象</span>
                <div id="chat-header-status">
                  <span class="status-dot"></span>
                  <span class="status-text">在线</span>
                </div>
              </div>
              <!-- ▲▲▲ 新增结束 ▲▲▲ -->

              <div class="header-actions">
                <span class="action-btn" id="listen-together-btn" title="一起听"
                  ><img
                    src="https://i.postimg.cc/dV8sdNcx/210-20250618115221.png"
                    alt="一起听"
                /></span>
                <span class="action-btn" id="chat-settings-btn" title="聊天设置"
                  ><img
                    src="https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png"
                    alt="设置"
                /></span>
              </div>
            </div>

            <!-- 多选模式控件 (保持不变) -->
            <div class="selection-controls">
              <span id="selection-cancel-btn">取消</span>
              <span id="selection-count"></span>
              <div class="header-actions">
                <span id="selection-favorite-btn" class="action-btn">收藏</span>
                <span id="selection-share-btn" class="action-btn">分享</span>
                <span
                  id="selection-delete-btn"
                  class="action-btn"
                  style="color: #ff3b30"
                  >删除</span
                >
              </div>
            </div>
          </div>

          <!-- 聊天消息区域 (保持不变) -->
          <div id="chat-messages">
            <div id="typing-indicator">对方正在输入...</div>
          </div>

          <!-- 输入区域 (保持不变) -->
          <div id="chat-input-area">
            <div id="reply-preview-bar">
              <div class="reply-preview-content">
                <div class="sender">回复 xxx:</div>
                <div class="text">被引用的消息内容...</div>
              </div>
              <span id="cancel-reply-btn">×</span>
            </div>
            <div id="chat-input-actions-top">
              <button
                id="open-sticker-panel-btn"
                class="chat-action-icon-btn action-button"
                title="表情面板"
              >
                +
              </button>
              <button
                id="send-photo-btn"
                class="chat-action-icon-btn action-button"
                title="发送照片"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"
                  />
                  <circle cx="12" cy="13" r="4" />
                </svg>
              </button>
              <button
                id="upload-image-btn"
                class="chat-action-icon-btn action-button"
                title="上传图片"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  style="color: var(--text-primary)"
                >
                  <path
                    d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </button>
              <button
                id="transfer-btn"
                class="chat-action-icon-btn action-button"
                title="转账"
              >
                ￥
              </button>
              <button
                id="voice-message-btn"
                class="chat-action-icon-btn action-button"
                title="发送语音"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"
                  />
                  <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                  <path d="M12 19v4" />
                  <path d="M8 23h8" />
                </svg>
              </button>
              <!-- ▼▼▼ 将这行新代码粘贴到“发送语音”按钮的后面 ▼▼▼ -->
              <button
                id="send-waimai-request-btn"
                class="chat-action-icon-btn action-button"
                title="发起外卖请求"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"
                  />
                  <line x1="3" y1="6" x2="21" y2="6" />
                  <path d="M16 10a4 4 0 0 1-8 0" />
                </svg>
              </button>
              <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
              <!-- ▼▼▼ 【新增】视频通话按钮 ▼▼▼ -->
              <button
                id="video-call-btn"
                class="chat-action-icon-btn action-button"
                title="视频通话"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <polygon points="23 7 16 12 23 17 23 7"></polygon>
                  <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                </svg>
              </button>
              <!-- ▲▲▲ 新增结束 ▲▲▲
<!-- ▼▼▼群视频通话按钮 ▼▼▼ -->
              <button
                id="group-video-call-btn"
                class="chat-action-icon-btn action-button"
                title="群视频通话"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                  <circle cx="9" cy="7" r="4"></circle>
                  <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                  <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                </svg>
              </button>
              <!-- ▲▲▲ 全新添加结束 ▲▲▲ -->
              <!-- ▼▼▼发起投票按钮▼▼▼ -->
              <button
                id="send-poll-btn"
                class="chat-action-icon-btn action-button"
                title="发起投票"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M8 6h10" />
                  <path d="M6 6h.01" />
                  <path d="M8 12h10" />
                  <path d="M6 12h.01" />
                  <path d="M8 18h10" />
                  <path d="M6 18h.01" />
                </svg>
              </button>
              <!-- ▲▲▲ 替换结束 ▲▲▲ -->
              <!-- ▼▼▼ 在 id="chat-input-actions-top" 的末尾，【添加】这个新的按钮 ▼▼▼ -->
              <button
                id="share-link-btn"
                class="chat-action-icon-btn action-button"
                title="分享链接"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"
                  ></path>
                  <path
                    d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"
                  ></path>
                </svg>
              </button>
              <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
            </div>
            <div id="chat-input-main-row">
              <textarea
                id="chat-input"
                rows="1"
                placeholder="输入消息..."
              ></textarea>
              <div id="input-actions-wrapper">
                <button id="wait-reply-btn" title="等待回复">
                  <img
                    src="https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png"
                    alt="等待回复"
                  />
                </button>
                <button id="send-btn" class="action-button">发送</button>
              </div>
            </div>
          </div>

          <!-- ▼▼▼ 在这里新增 ▼▼▼ -->
          <div id="chat-lock-overlay">
            <div id="chat-lock-content"></div>
          </div>
          <!-- ▲▲▲ 新增结束 ▲▲▲ -->

          <!-- 表情面板 (保持不变) -->
          <div id="sticker-panel">
            <div id="sticker-panel-header">
              <span class="panel-btn" id="close-sticker-panel-btn">取消</span>
              <span class="title">我的表情</span>
              <div style="display: flex; gap: 10px">
                <span class="panel-btn" id="add-sticker-btn">添加</span>
                <span class="panel-btn" id="upload-sticker-btn">上传</span>
              </div>
            </div>
            <div id="sticker-grid"></div>
          </div>
          <input
            type="file"
            id="sticker-upload-input"
            accept="image/*"
            style="display: none"
          />
          <input
            type="file"
            id="image-upload-input"
            accept="image/*"
            style="display: none"
          />

          <!-- 音乐播放器 (保持不变) -->
          <div id="music-player-overlay">
            <div class="music-player-window">
              <!-- 1. 顶部操作栏 -->
              <div class="music-player-top-actions">
                <div class="top-left-cluster">
                  <button id="music-return-btn">‹</button>
                  <button id="music-exit-btn">×</button>
                </div>
                <span id="music-playlist-btn">☰</span>
              </div>

              <!-- 2. 歌曲信息 -->
              <div id="music-time-counter">已经一起听了0.0小时</div>
              <div id="music-player-song-title">请添加歌曲</div>
              <div id="music-player-artist">...</div>

              <!-- 3. 【全新】歌词显示区域 -->
              <div id="music-lyrics-container">
                <div id="music-lyrics-list">
                  <!-- 歌词将由JS动态生成在这里 -->
                  <div class="lyric-line">♪ 暂无歌词 ♪</div>
                </div>
              </div>

              <!-- 4. 【全新】播放控制区的包裹容器 -->
              <div class="music-player-controls-wrapper">
                <!-- a. 新的iOS风格进度条 -->
                <div class="music-progress-bar-container">
                  <div id="music-current-time" class="time-display">0:00</div>
                  <div class="progress-bar">
                    <div
                      id="music-progress-fill"
                      class="progress-bar-fill"
                    ></div>
                  </div>
                  <div id="music-total-time" class="time-display">0:00</div>
                </div>

                <!-- b. 播放控制按钮 -->
                <div class="music-controls">
                  <button id="music-prev-btn">◀</button>
                  <button id="music-play-pause-btn" class="play-pause-btn">
                    ▶
                  </button>
                  <button id="music-next-btn">▶</button>
                  <button id="music-mode-btn">顺序</button>
                </div>
              </div>
            </div>
          </div>

          <div id="music-playlist-panel">
            <div class="playlist-header">
              <span class="panel-btn" id="close-playlist-btn">返回</span>
              <span>播放列表</span>
              <div>
                <span class="panel-btn" id="add-song-local-btn">本地</span>
                <span class="panel-btn" id="add-song-url-btn">URL</span>
              </div>
            </div>
            <div class="playlist-body" id="playlist-body"></div>
          </div>
          <input
            type="file"
            id="local-song-upload-input"
            accept="audio/*"
            multiple
            style="display: none"
          />
          <input
            type="file"
            id="lrc-upload-input"
            accept=".lrc"
            style="display: none"
          />
        </div>
        <!-- ▲▲▲ 替换结束 ▲▲▲ -->

        <!-- ▼▼▼ 用这整块代码替换你原来的 id="wallpaper-screen" ▼▼▼ -->
        <div id="wallpaper-screen" class="screen">
          <div class="header">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <!-- 【核心修改1】标题改为“外观设置”，更通用 -->
            <span>外观设置</span>
            <span style="width: 30px"></span>
          </div>
          <div class="form-container">
            <!-- 壁纸设置部分保持不变 -->
            <div id="wallpaper-preview">点击下方上传</div>
            <button
              class="form-button"
              onclick="document.getElementById('wallpaper-upload-input').click();"
            >
              上传壁纸
            </button>
            <input type="file" id="wallpaper-upload-input" accept="image/*" />

            <!-- ▼▼▼ 将【上面整块代码】，完整替换为下面这段【全新的代码】 ▼▼▼ -->
            <div
              class="form-group"
              style="
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <label for="theme-toggle-switch" style="margin-bottom: 0"
                >夜间模式</label
              >
              <label class="toggle-switch">
                <input type="checkbox" id="theme-toggle-switch" />
                <span class="slider"></span>
              </label>
            </div>
            <!-- ▲▲▲ 替换结束 ▲▲▲ -->

            <!-- ▼▼▼ 新增：手机边框颜色设置 ▼▼▼ -->
            <div class="form-group">
              <label for="frame-color-input">
                手机边框颜色
                <button
                  id="reset-frame-color-btn"
                  type="button"
                  style="
                    background: none;
                    border: 1px solid #ccc;
                    color: #555;
                    font-size: 12px;
                    padding: 2px 8px;
                    border-radius: 5px;
                    cursor: pointer;
                    margin-left: 10px;
                  "
                >
                  重置
                </button>
              </label>
              <div style="display: flex; align-items: center; gap: 10px">
                <input
                  type="color"
                  id="frame-color-input"
                  value="#ffffff"
                  style="width: 50px; height: 40px; padding: 0; border: none; cursor: pointer;"
                />
                <span id="frame-color-value" style="font-family: monospace;">#ffffff</span>
              </div>
            </div>
            <!-- ▲▲▲ 新增结束 ▲▲▲ -->

            <!-- 【核心修改2】新增图标设置区域 -->
            <hr style="width: 80%; opacity: 0.3; margin: 30px 0" />
            <div style="width: 100%; text-align: left; margin-bottom: 15px">
              <label style="font-weight: 500; color: var(--text-secondary)"
                >App 图标设置</label
              >
            </div>
            <div id="icon-settings-grid">
              <!-- 图标设置项将由JS动态生成在这里 -->
            </div>

            <!-- 【核心修改3】按钮文字也改一下 -->
            <button
              class="form-button"
              id="save-wallpaper-btn"
              style="margin-top: 30px"
            >
              保存所有外观设置
            </button>
          </div>
        </div>
        <!-- ▲▲▲ 替换结束 ▲▲▲ -->

        <!-- ▼▼▼ 【全新】分享链接功能 HTML ▼▼▼ -->
        <div id="browser-screen" class="screen">
          <div class="header">
            <span class="back-btn" id="browser-back-btn">‹</span>
            <span id="browser-title"></span>
            <span style="width: 30px"></span>
          </div>
          <div id="browser-content" class="list-container">
            <!-- 文章内容将由JS动态生成在这里 -->
          </div>
        </div>
        <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

        <div id="font-settings-screen" class="screen">
          <div class="header">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <span>字体设置</span>
            <span style="width: 30px"></span>
          </div>
          <div class="form-container">
            <div class="form-group">
              <label for="font-url-input"
                >字体文件URL (.ttf, .otf, .woff等)</label
              >
              <input
                type="text"
                id="font-url-input"
                placeholder="https://..../font.ttf"
              />
            </div>

            <div class="form-group">
              <label>实时预览</label>
              <div id="font-preview">
                <p style="font-size: 20px; margin: 0 0 10px 0">
                  你好世界 Hello World
                </p>
                <p style="margin: 0">这是字体预览效果，12345。</p>
              </div>
            </div>

            <button class="form-button" id="save-font-btn">保存并应用</button>
            <button
              class="form-button form-button-secondary"
              id="reset-font-btn"
            >
              恢复默认字体
            </button>
          </div>
        </div>

        <!-- ▼▼▼ 【全新】选择联系人以创建群聊的屏幕 ▼▼▼ -->
        <div id="contact-picker-screen" class="screen">
          <div class="header">
            <span class="back-btn" id="cancel-contact-picker-btn">取消</span>
            <span>选择联系人</span>
            <span class="save-btn" id="confirm-contact-picker-btn"
              >完成(0)</span
            >
          </div>
          <div class="list-container" id="contact-picker-list">
            <!-- 联系人列表将由JS动态生成 -->
          </div>
        </div>
        <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

        <!-- ▼▼▼ 【全新】群成员管理屏幕 ▼▼▼ -->
        <div id="member-management-screen" class="screen">
          <div class="header">
            <span class="back-btn" id="back-from-member-management">‹</span>
            <span>群成员管理</span>
            <span style="width: 30px"></span>
          </div>
          <div class="list-container" id="member-management-list">
            <!-- 现有成员列表会在这里动态生成 -->
          </div>
          <div id="member-management-actions">
            <button id="add-existing-contact-btn">从好友列表添加</button>
            <button id="create-new-member-btn">创建群内新成员</button>
          </div>
        </div>
        <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

        <!-- ▼▼▼ 【全新】来电请求模态框 ▼▼▼ -->
        <div id="incoming-call-modal" class="modal">
          <div class="incoming-call-content">
            <img id="caller-avatar" class="caller-avatar" src="" />
            <div id="caller-name" class="caller-name"></div>
            <div class="caller-text">邀请你视频通话</div>
            <div class="incoming-call-actions">
              <div class="action-button-wrapper">
                <button
                  id="decline-call-btn"
                  class="call-action-btn decline"
                ></button>
                <span>拒绝</span>
              </div>
              <div class="action-button-wrapper">
                <button
                  id="accept-call-btn"
                  class="call-action-btn accept"
                ></button>
                <span>接听</span>
              </div>
            </div>
          </div>
        </div>
        <!-- ▲▲▲ 新增结束 ▲▲▲ -->

        <!-- ▼▼▼ 请用这段【全新群聊兼容结构】的代码，完整替换你旧的 #video-call-screen ▼▼▼ -->
        <div id="video-call-screen" class="screen">
          <!-- ▼▼▼ Visual Interface (Video Mode) ▼▼▼ -->
          <div id="visual-call-interface" style="display: none; width: 100%; height: 100%; position: relative;">
              <!-- Visual Timer -->
              <div style="position: absolute; top: 40px; left: 0; width: 100%; text-align: center; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.8); z-index: 10; pointer-events: none;">
                  <span id="visual-call-timer">00:00</span>
              </div>

              <div id="video-main-view" style="width: 100%; height: 100%;"><img src="" style="width: 100%; height: 100%; object-fit: cover; display: block;"></div>
              <div id="video-pip-view" style="position: absolute; top: 60px; right: 20px; width: 90px; height: 120px; border: 2px solid white; box-shadow: 0 2px 10px rgba(0,0,0,0.3); border-radius: 8px; overflow: hidden;"><img src="" style="width: 100%; height: 100%; object-fit: cover; display: block;"></div>
              <div id="video-call-messages-visual" style="position: absolute; bottom: 100px; left: 0; width: 100%; padding: 15px; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.8); pointer-events: none; text-align: center;"></div>
              
              <!-- Visual Mode Controls (Simplified) -->
              <div class="video-call-controls" style="position: absolute; bottom: 30px; left: 0; width: 100%; background: transparent; pointer-events: auto;">
                  <button onclick="endVideoCall()" class="control-btn hangup-btn" style="margin: 0 auto; display: block;"></button>
              </div>
          </div>
          <!-- ▲▲▲ Visual Interface End ▲▲▲ -->

          <!-- ▼▼▼ Text Interface (Classic Mode) ▼▼▼ -->
          <div id="text-call-interface" style="display: flex; flex-direction: column; height: 100%; width: 100%;">
              <!-- 1. 顶部栏 (保持不变) -->
              <div class="video-call-top-bar">
                <span id="call-timer">00:00</span>
              </div>

              <!-- 2. 【升级】参与者头像网格区域 -->
              <div class="video-call-avatar-area">
                <div id="participant-avatars-grid">
                  <!-- JS会在这里动态生成头像 -->
                </div>
              </div>

              <!-- 3. 对话框区域 (保持不变) -->
              <div id="video-call-main" class="video-call-main">
                <!-- 对话内容会动态生成在这里 -->
              </div>

              <!-- 4. 【升级】底部控制栏，现在包含一个“加入”按钮 -->
              <div class="video-call-controls">
                <button id="user-speak-btn" class="control-btn speak-btn"></button>
                <button id="hang-up-btn" class="control-btn hangup-btn"></button>
                <!-- 这个按钮默认隐藏，只在用户“旁观”时显示 -->
                <button
                  id="join-call-btn"
                  class="control-btn join-btn"
                  style="display: none"
                ></button>
              </div>
          </div>
          <!-- ▲▲▲ Text Interface End ▲▲▲ -->
        </div>
        <!-- ▲▲▲ 替换结束 ▲▲▲ -->

        <!-- ▼▼▼ 【全新添加】正在呼叫界面 ▼▼▼ -->
        <div id="outgoing-call-screen" class="screen">
          <div class="outgoing-call-content">
            <img id="outgoing-call-avatar" class="caller-avatar" src="" />
            <div id="outgoing-call-name" class="caller-name"></div>
            <div class="caller-text">正在呼叫...</div>
            <div class="outgoing-call-actions">
              <button
                id="cancel-call-btn"
                class="call-action-btn decline"
              ></button>
              <span>取消</span>
            </div>
          </div>
        </div>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->

        <!-- ▼▼▼ 【全新】通话记录页面 ▼▼▼ -->
        <div id="call-history-screen" class="screen">
          <div class="header">
            <span class="back-btn" id="call-history-back-btn">‹</span>
            <span id="call-history-title">通话记录</span>
            <span style="width: 30px"></span>
            <!-- 占位符，保持标题居中 -->
          </div>
          <div
            id="call-history-list"
            class="list-container"
            style="
              padding: 15px;
              display: flex;
              flex-direction: column;
              gap: 15px;
            "
          >
            <!-- 通话记录卡片将由JS动态生成在这里 -->
          </div>
        </div>
        <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
      </div>
    </div>

    <div id="chat-settings-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header"><span>聊天设置</span></div>
        <div class="modal-body">
          <div class="form-group" id="chat-name-group">
            <label for="chat-name-input">备注名 / 群名</label
            ><input type="text" id="chat-name-input" />
          </div>

          <!-- ▼▼▼ 请将这段新代码粘贴到“备注名”输入框的 form-group 之后 ▼▼▼ -->
          <div
            class="form-group"
            id="assign-group-section"
            style="display: none"
          >
            <!-- 默认隐藏，只对单聊显示 -->
            <label for="assign-group-select">好友分组</label>
            <div style="display: flex; align-items: center; gap: 10px">
              <select id="assign-group-select" style="flex-grow: 1">
                <!-- 分组选项将由JS动态生成 -->
              </select>
              <button
                id="manage-groups-btn"
                class="form-button-secondary"
                style="margin-top: 0; padding: 12px"
              >
                管理分组
              </button>
            </div>
          </div>
          <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

          <div class="form-group" id="my-group-nickname-group">
            <label for="my-group-nickname-input">我的群昵称</label
            ><input type="text" id="my-group-nickname-input" />
          </div>
          <div class="form-group" id="group-avatar-group">
            <label>群头像</label>
            <div class="avatar-upload">
              <img id="group-avatar-preview" /><button
                onclick="document.getElementById('group-avatar-input').click()"
              >
                上传群头像</button
              ><input type="file" id="group-avatar-input" accept="image/*" />
            </div>
          </div>
          <div class="form-group" id="world-book-link-group">
            <label>关联世界书 (可多选)</label>
            <div class="custom-multiselect">
              <div class="select-box">
                <span class="selected-options-text">-- 点击选择 --</span>
                <span class="arrow-down">▼</span>
              </div>
              <div
                id="world-book-checkboxes-container"
                class="checkboxes-container"
              ></div>
            </div>
          </div>
          <div class="form-group" id="ai-persona-group">
            <label for="ai-persona">对方人设 (AI Persona)</label
            ><textarea id="ai-persona" rows="3"></textarea>
          </div>
          <div class="form-group" id="ai-avatar-group">
            <label>对方头像</label>
            <div class="avatar-upload">
              <img id="ai-avatar-preview" /><button
                onclick="document.getElementById('ai-avatar-input').click()"
              >
                上传对方头像</button
              ><button id="manage-ai-avatar-library-btn">管理头像库</button>
              <input type="file" id="ai-avatar-input" accept="image/*" />
            </div>
          </div>

          <div class="form-group" id="video-call-settings-group">
            <hr style="opacity: 0.2; margin: 15px 0;">
            <label style="display: flex; align-items: center; justify-content: space-between; font-weight: bold;">
              <span>可视视频通话</span>
              <input type="checkbox" id="visual-video-call-switch" style="width: auto;">
            </label>

            <div id="video-call-image-uploads" style="display: none; margin-top: 10px; background-color: #f9f9f9; padding: 10px; border-radius: 8px;">
              <div style="display: flex; justify-content: space-around;">
                <div style="text-align: center;">
                  <label style="font-size: 12px;">对方画面</label>
                  <div onclick="document.getElementById('char-video-image-input').click()" style="cursor: pointer; margin-top: 5px;">
                    <img id="char-video-image-preview" src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png" style="width: 70px; height: 70px; object-fit: cover; border-radius: 8px; border: 1px dashed #ccc;">
                  </div>
                  <input type="file" id="char-video-image-input" accept="image/*" hidden />
                </div>
                <div style="text-align: center;">
                  <label style="font-size: 12px;">我的画面</label>
                  <div onclick="document.getElementById('user-video-image-input').click()" style="cursor: pointer; margin-top: 5px;">
                    <img id="user-video-image-preview" src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png" style="width: 70px; height: 70px; object-fit: cover; border-radius: 8px; border: 1px dashed #ccc;">
                  </div>
                  <input type="file" id="user-video-image-input" accept="image/*" hidden />
                </div>
              </div>
            </div>

            <label style="display: flex; align-items: center; justify-content: space-between; margin-top: 15px;">
              <span>语音接入 (Minimax)</span>
              <input type="checkbox" id="video-call-voice-access-switch" style="width: auto;">
            </label>
          </div>
          <div class="form-group" id="my-persona-group">
            <label for="my-persona">我的人设 (My Persona)</label
            ><textarea id="my-persona" rows="3"></textarea>
          </div>
          <div class="form-group" id="my-avatar-group">
            <label>我的头像</label>
            <div class="avatar-upload">
              <img id="my-avatar-preview" /><button
                onclick="document.getElementById('my-avatar-input').click()"
              >
                上传我的头像</button
              ><button id="open-persona-library-btn">预设</button
              ><input type="file" id="my-avatar-input" accept="image/*" />
            </div>
          </div>
          <div class="form-group" id="group-members-group">
            <label>群成员人设</label>
            <div id="group-members-settings"></div>

            <!-- 【新增】管理成员按钮 -->
            <button
              id="manage-members-btn"
              class="form-button form-button-secondary"
              style="margin-top: 15px"
            >
              管理群成员
            </button>
          </div>
          <div class="form-group">
            <label for="max-memory">上下文记忆条数</label
            ><input type="number" id="max-memory" value="10" />
          </div>
          <div class="form-group">
            <label
              >聊天气泡主题
              <button id="reset-theme-btn" type="button">重置</button></label
            >
            <div class="theme-selector">
              <label
                ><input
                  type="radio"
                  name="theme-select"
                  value="default"
                  id="theme-default"
                />
                默认</label
              ><label
                ><input type="radio" name="theme-select" value="pink_blue" />
                粉蓝</label
              ><label
                ><input type="radio" name="theme-select" value="blue_white" />
                蓝白</label
              ><label
                ><input
                  type="radio"
                  name="theme-select"
                  value="purple_yellow"
                />
                紫黄</label
              ><label
                ><input type="radio" name="theme-select" value="black_white" />
                黑白</label
              ><label
                ><input type="radio" name="theme-select" value="yellow_white" />
                黄白</label
              ><label
                ><input type="radio" name="theme-select" value="red_black" />
                红黑</label
              ><label
                ><input type="radio" name="theme-select" value="blue_yellow" />
                蓝黄</label
              ><label
                ><input type="radio" name="theme-select" value="pink_yellow" />
                粉黄</label
              ><label
                ><input type="radio" name="theme-select" value="pink_purple" />
                粉紫</label
              ><label
                ><input type="radio" name="theme-select" value="gray_white" />
                灰白</label
              ><label
                ><input type="radio" name="theme-select" value="blue_green" />
                蓝绿</label
              ><label
                ><input type="radio" name="theme-select" value="pink_white" />
                粉白</label
              ><label
                ><input type="radio" name="theme-select" value="pink_black" />
                粉黑</label
              ><label
                ><input type="radio" name="theme-select" value="pink_green" />
                粉绿</label
              ><label
                ><input type="radio" name="theme-select" value="green_black" />
                绿黑</label
              >
            </div>
          </div>

          <!-- ▼▼▼ 请将这段新代码粘贴到“聊天气泡主题”的 form-group 之后 ▼▼▼ -->
          <div class="form-group">
            <label for="font-size-slider"
              >聊天字体大小 <span id="font-size-value">13px</span></label
            >
            <input
              type="range"
              id="font-size-slider"
              min="12"
              max="20"
              step="1"
              value="13"
              style="width: 100%; margin-top: 8px"
            />
          </div>
          <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

          <!-- ▼▼▼ 请将这段新代码粘贴到“聊天字体大小”的 form-group 之后 ▼▼▼ -->
          <div class="form-group">
            <label for="custom-css-input">
              自定义气泡样式 (CSS)
              <button
                id="reset-custom-css-btn"
                type="button"
                style="
                  background: none;
                  border: 1px solid #ccc;
                  color: #555;
                  font-size: 12px;
                  padding: 2px 8px;
                  border-radius: 5px;
                  cursor: pointer;
                  margin-left: 10px;
                "
              >
                重置
              </button>
            </label>
            <textarea
              id="custom-css-input"
              rows="5"
              style="
                width: 100%;
                margin-top: 8px;
                font-family: monospace;
                font-size: 12px;
                resize: vertical;
              "
              placeholder="/* 示例：为“我”的气泡添加渐变背景和阴影 */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"
            ></textarea>
          </div>
          <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

          <!-- ▼▼▼ 请将这段新代码粘贴到自定义CSS输入框的 form-group 之后 ▼▼▼ -->
          <div class="form-group">
            <label>实时预览</label>
            <div id="settings-preview-area">
              <!-- JS会在这里生成预览内容 -->
            </div>
          </div>
          <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

          <div class="form-group">
            <label>聊天背景</label>
            <div class="bg-upload-container">
              <button
                type="button"
                class="form-button-secondary"
                style="width: auto; padding: 8px 12px; margin-top: 0"
                onclick="document.getElementById('bg-input').click()"
              >
                上传背景图
              </button>
              <button type="button" id="remove-bg-btn">移除背景</button>
            </div>
            <img id="bg-preview" class="bg-preview-img" />
            <input
              type="file"
              id="bg-input"
              accept="image/*"
              style="display: none"
            />
          </div>
          <hr
            style="margin: 25px 0; border: none; border-top: 1px solid #eee"
          />
          <button
            class="form-button form-button-secondary"
            id="block-chat-btn"
            style="
              background-color: #ff3b30;
              color: white;
              border-color: #ff3b30;
            "
          >
            拉黑对方
          </button>
          <button class="form-button form-button-secondary" id="clear-chat-btn">
            清空聊天记录
          </button>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-chat-settings-btn">取消</button
          ><button class="save" id="save-chat-settings-btn">保存</button>
        </div>
      </div>
    </div>

    <div id="persona-library-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span>我的人设库</span
          ><button id="add-persona-preset-btn" class="action-button">
            添加
          </button>
        </div>
        <div class="modal-body"><div id="persona-library-grid"></div></div>
        <div class="modal-footer">
          <button class="cancel" id="close-persona-library-btn">关闭</button>
        </div>
      </div>
    </div>

    <div id="persona-editor-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span id="persona-editor-title">添加人设预设</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>预设头像</label>
            <div class="avatar-upload">
              <img id="preset-avatar-preview" /><button
                onclick="document.getElementById('preset-avatar-input').click()"
              >
                上传头像</button
              ><input type="file" id="preset-avatar-input" accept="image/*" />
            </div>
          </div>
          <div class="form-group">
            <label for="preset-persona-input">预设人设</label
            ><textarea
              id="preset-persona-input"
              rows="4"
              placeholder="在此输入这个人设的详细设定..."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-persona-editor-btn">取消</button
          ><button class="save" id="save-persona-preset-btn">保存</button>
        </div>
      </div>
    </div>

    <div id="member-settings-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header"><span>编辑群成员</span></div>
        <div class="modal-body">
          <div class="form-group">
            <label for="member-name-input">名字</label
            ><input type="text" id="member-name-input" />
          </div>
          <div class="form-group">
            <label for="member-persona-input">人设</label
            ><textarea id="member-persona-input" rows="4"></textarea>
          </div>
          <div class="form-group">
            <label>头像</label>
            <div class="avatar-upload">
              <img id="member-avatar-preview" /><button
                onclick="document.getElementById('member-avatar-input').click()"
              >
                上传头像</button
              ><input type="file" id="member-avatar-input" accept="image/*" />
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-member-settings-btn">取消</button
          ><button class="save" id="save-member-settings-btn">保存</button>
        </div>
      </div>
    </div>

    <div id="custom-modal-overlay">
      <div id="custom-modal">
        <div class="custom-modal-header" id="custom-modal-title"></div>
        <div class="custom-modal-body" id="custom-modal-body"></div>
        <div class="custom-modal-footer">
          <button id="custom-modal-cancel">取消</button>
          <button id="custom-modal-confirm" class="confirm-btn">确定</button>
        </div>
      </div>
    </div>

    <div id="api-config-editor-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 90%">
        <div class="modal-header">
          <span>编辑API配置</span>
        </div>
        <div class="modal-body">
          <input type="hidden" id="config-editor-id" />
          <div class="form-group">
            <label for="config-name-input">配置名称</label>
            <input type="text" id="config-name-input" placeholder="例如：主力模型、备用线路" />
          </div>
          <div class="form-group">
            <label for="config-url-input">反代地址</label>
            <input type="text" id="config-url-input" placeholder="例如: https://api.openai.com" />
          </div>
          <div class="form-group">
            <label for="config-key-input">密钥</label>
            <input type="password" id="config-key-input" placeholder="sk-..." />
          </div>
          <div class="form-group">
            <label for="config-model-select">默认模型</label>
            <select id="config-model-select"></select>
            <button
              type="button"
              class="form-button-secondary"
              id="config-fetch-models-btn"
              style="margin-top: 10px"
            >
              拉取模型列表
            </button>
          </div>
          <div class="form-group form-group-flex">
            <label for="config-stream-switch" style="margin-bottom: 0">启用流式传输</label>
            <label class="toggle-switch">
              <input type="checkbox" id="config-stream-switch" />
              <span class="slider"></span>
            </label>
          </div>
          <div class="form-group form-group-flex">
            <label for="config-hide-stream-switch" style="margin-bottom: 0">隐藏流式响应</label>
            <label class="toggle-switch">
              <input type="checkbox" id="config-hide-stream-switch" />
              <span class="slider"></span>
            </label>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="cancel" id="cancel-config-editor-btn">取消</button>
          <button type="button" class="save" id="save-config-btn">保存</button>
        </div>
      </div>
    </div>

    <div id="preset-actions-modal" class="modal">
      <div id="custom-modal" style="width: 250px">
        <div class="custom-modal-footer">
          <button id="preset-action-edit">编辑预设</button>
          <button id="preset-action-delete" class="btn-danger">删除预设</button>
          <button
            id="preset-action-cancel"
            style="
              margin-top: 8px;
              border-radius: 8px;
              background-color: #f0f0f0;
            "
          >
            取消
          </button>
        </div>
      </div>
    </div>

    <div id="transfer-modal">
      <div class="transfer-content">
        <div class="transfer-header">给Ta一个惊喜！</div>
        <div class="transfer-input-group">
          <label for="transfer-amount">转账金额</label>
          <input
            type="number"
            id="transfer-amount"
            placeholder="0.00"
            min="0"
            max="9999"
            step="0.01"
          />
        </div>
        <div class="transfer-input-group">
          <label for="transfer-note">备注 (可选)</label>
          <input
            type="text"
            id="transfer-note"
            placeholder="留下你的小心思~"
            maxlength="20"
          />
        </div>
        <div class="transfer-actions">
          <button id="transfer-cancel-btn">取消</button>
          <button id="transfer-confirm-btn">确认转账</button>
        </div>
      </div>
    </div>

    <div id="battery-alert-modal">
      <div class="battery-alert-content">
        <img id="battery-alert-image" src="" />
        <p id="battery-alert-text"></p>
      </div>
    </div>

    <audio id="audio-player" style="display: none"></audio>

    <!-- ▼▼▼ 用下面这段【完整】的模态框代码，替换掉你现有的 id="create-post-modal" 的整个 div ▼▼▼ -->
    <div id="create-post-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 90%">
        <div class="modal-header">
          <span>发布动态</span>
        </div>
        <div class="modal-body">
          <!-- 公开文字输入区 -->
          <div class="form-group">
            <textarea
              id="post-public-text"
              rows="3"
              placeholder="分享新鲜事...（非必填的公开文字）"
            ></textarea>
          </div>

          <!-- === 模式切换开关 (新增) === -->
          <div class="post-mode-switcher">
            <button id="switch-to-image-mode" class="mode-btn active">
              上传图片
            </button>
            <button id="switch-to-text-image-mode" class="mode-btn">
              使用文字图
            </button>
          </div>

          <!-- ▼▼▼ 【修正后】的可见范围设置 ▼▼▼ -->
          <div class="form-group">
            <label>可见范围</label>
            <div
              id="post-visibility-options"
              style="display: flex; gap: 15px; margin-bottom: 10px"
            >
              <label
                ><input type="radio" name="visibility" value="public" checked />
                公开</label
              >

              <label
                ><input type="radio" name="visibility" value="include" />
                指定分组可见</label
              >
            </div>
            <div
              id="post-visibility-groups"
              style="
                display: none;
                max-height: 120px;
                overflow-y: auto;
                background: #f9f9f9;
                padding: 10px;
                border-radius: 8px;
              "
            >
              <!-- 分组多选框将由JS动态生成 -->
            </div>
          </div>
          <!-- ▲▲▲ 修正结束 ▲▲▲ -->

          <!-- === 图片模式区域 === -->
          <div id="image-mode-content" class="post-mode-content active">
            <div class="form-group">
              <div
                id="post-image-preview-container"
                class="post-image-preview-container"
              >
                <img id="post-image-preview" src="" alt="图片预览" />
                <button id="post-remove-image-btn">×</button>
              </div>
              <div class="post-image-upload-options">
                <button
                  id="post-upload-local-btn"
                  class="form-button-secondary"
                >
                  本地上传
                </button>
                <button id="post-use-url-btn" class="form-button-secondary">
                  网络URL
                </button>
                <input
                  type="file"
                  id="post-local-image-input"
                  accept="image/*"
                  hidden
                />
              </div>
            </div>
            <div
              id="post-image-desc-group"
              class="form-group"
              style="display: none"
            >
              <label>图片描述 (必填，给AI看)</label>
              <input
                type="text"
                id="post-image-description"
                placeholder="简单描述图片内容，帮助AI理解"
              />
            </div>
          </div>

          <!-- === 文字图模式区域 (新增) === -->
          <div id="text-image-mode-content" class="post-mode-content">
            <div class="form-group">
              <label>文字图 (给AI理解用的描述，点击图片后可见)</label>
              <textarea
                id="post-hidden-text"
                rows="4"
                placeholder="在这里写下图片描述..."
              ></textarea>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-create-post-btn">取消</button>
          <button class="save" id="confirm-create-post-btn">发布</button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 替换结束 ▲▲▲ -->

    <!-- ▼▼▼ 请将这个新的模态框HTML粘贴到所有其他模态框之后 ▼▼▼ -->
    <div id="group-management-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>管理好友分组</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>新建分组</label>
            <div style="display: flex; gap: 10px">
              <input
                type="text"
                id="new-group-name-input"
                placeholder="输入分组名..."
                style="flex-grow: 1"
              />
              <button
                id="add-new-group-btn"
                class="form-button"
                style="width: auto; margin-top: 0; padding: 0 15px"
              >
                添加
              </button>
            </div>
          </div>
          <hr style="opacity: 0.2" />
          <div
            id="existing-groups-list"
            style="display: flex; flex-direction: column; gap: 10px"
          >
            <!-- 分组列表将由JS动态生成 -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="save" id="close-group-manager-btn" style="width: 100%">
            完成
          </button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
    <div id="message-actions-modal" class="modal">
      <div id="custom-modal" style="width: 250px">
        <div class="custom-modal-footer">
          <!-- 新的操作按钮 -->
          <button id="edit-message-btn">编辑消息</button>
          <button id="copy-message-btn">复制文本</button>
          <button id="recall-message-btn">撤回</button>
          <button id="quote-message-btn">引用</button>
          <button id="select-message-btn">进入多选</button>
          <!-- 取消按钮 -->
          <button
            id="cancel-message-action-btn"
            style="
              margin-top: 8px;
              border-radius: 8px;
              background-color: #f0f0f0;
            "
          >
            取消
          </button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
    <div id="post-actions-modal" class="modal">
      <div id="custom-modal" style="width: 250px">
        <div class="custom-modal-footer">
          <button id="edit-post-btn">编辑动态</button>
          <button id="copy-post-btn">复制内容</button>
          <button id="cancel-post-action-btn">取消</button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】可视化消息编辑器模态框 ▼▼▼ -->
    <div id="message-editor-modal" class="modal">
      <div class="modal-content" style="height: 75%">
        <div class="modal-header">
          <span>编辑与拆分消息</span>
        </div>
        <div class="modal-body" id="message-editor-body">
          <!-- 编辑器容器，JS会在这里动态生成文本框 -->
          <div id="message-editor-container"></div>
          <!-- 添加新消息的按钮 -->
          <button
            id="add-message-editor-block-btn"
            class="form-button form-button-secondary"
            style="margin-top: 15px"
          >
            [+] 添加下一条消息
          </button>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-advanced-editor-btn">取消</button>
          <button class="save" id="save-advanced-editor-btn">保存更改</button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】外卖请求模态框 ▼▼▼ -->
    <div id="waimai-request-modal" class="modal">
      <div class="modal-content" style="width: 290px">
        <div class="modal-header">
          <span>发起外卖代付</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="waimai-product-info">商品信息</label>
            <input
              type="text"
              id="waimai-product-info"
              placeholder="例如：一杯杨枝甘露"
            />
          </div>
          <div class="form-group">
            <label for="waimai-amount">代付金额 (元)</label>
            <input
              type="number"
              id="waimai-amount"
              placeholder="例如：21"
              min="0"
              step="0.01"
            />
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="waimai-cancel-btn">取消</button>
          <button class="save" id="waimai-confirm-btn">发起请求</button>
        </div>
      </div>
    </div>

    <!-- ▼▼▼ 【全新】新建约定/倒计时模态框 ▼▼▼ -->
    <div id="create-countdown-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>新建约定</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="countdown-title-input">约定标题</label>
            <input
              type="text"
              id="countdown-title-input"
              placeholder="例如：我的生日"
            />
          </div>
          <div class="form-group">
            <label for="countdown-date-input">约定日期与时间</label>
            <input type="datetime-local" id="countdown-date-input" />
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-create-countdown-btn">取消</button>
          <button class="save" id="confirm-create-countdown-btn">
            保存约定
          </button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】发红包模态框 ▼▼▼ -->
    <div id="red-packet-modal" class="modal">
      <div class="modal-content" style="width: 300px; height: auto">
        <div class="modal-header">
          <span>发红包</span>
        </div>
        <div class="modal-body" style="padding: 0">
          <!-- 1. 页签切换 -->
          <div class="frame-tabs">
            <div id="rp-tab-group" class="frame-tab active">拼手气红包</div>
            <div id="rp-tab-direct" class="frame-tab">专属红包</div>
          </div>

          <!-- 2. 拼手气红包内容区 -->
          <div
            id="rp-content-group"
            class="frame-content"
            style="padding: 20px 15px"
          >
            <div class="form-group">
              <label>总金额 (元)</label>
              <input type="number" id="rp-group-amount" placeholder="0.00" />
            </div>
            <div class="form-group">
              <label>红包个数</label>
              <input
                type="number"
                id="rp-group-count"
                placeholder="填写红包个数"
              />
            </div>
            <div class="form-group">
              <label>祝福语</label>
              <input
                type="text"
                id="rp-group-greeting"
                placeholder="恭喜发财，大吉大利！"
              />
            </div>
            <p
              id="rp-group-total"
              style="
                text-align: center;
                font-size: 24px;
                font-weight: bold;
                margin: 10px 0;
              "
            >
              ¥ 0.00
            </p>
            <button id="send-group-packet-btn" class="form-button">
              塞钱进红包
            </button>
          </div>

          <!-- 3. 专属红包内容区 -->
          <div
            id="rp-content-direct"
            class="frame-content"
            style="display: none; padding: 20px 15px"
          >
            <div class="form-group">
              <label>发送给</label>
              <select id="rp-direct-receiver"></select>
            </div>
            <div class="form-group">
              <label>金额 (元)</label>
              <input type="number" id="rp-direct-amount" placeholder="0.00" />
            </div>
            <div class="form-group">
              <label>祝福语</label>
              <input
                type="text"
                id="rp-direct-greeting"
                placeholder="恭喜发财，大吉大利！"
              />
            </div>
            <p
              id="rp-direct-total"
              style="
                text-align: center;
                font-size: 24px;
                font-weight: bold;
                margin: 10px 0;
              "
            >
              ¥ 0.00
            </p>
            <button id="send-direct-packet-btn" class="form-button">
              塞钱进红包
            </button>
          </div>
        </div>
        <div class="modal-footer" style="justify-content: center">
          <button class="cancel" id="cancel-red-packet-btn" style="width: 100%">
            取消
          </button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】红包详情模态框 ▼▼▼ -->
    <div id="red-packet-details-modal" class="modal">
      <div
        class="modal-content"
        style="width: 280px; height: auto; background-color: #f7f7f7"
      >
        <div
          class="modal-header"
          style="
            background-color: #f96259;
            color: white;
            border-bottom: none;
            padding-bottom: 5px;
          "
        >
          <div style="text-align: center; width: 100%">
            <div id="rp-details-sender" style="font-size: 16px"></div>
            <div style="font-size: 13px; opacity: 0.8">的红包</div>
          </div>
        </div>
        <div class="modal-body" style="padding: 15px">
          <p
            id="rp-details-greeting"
            style="
              text-align: center;
              font-size: 20px;
              color: #333;
              margin: 0 0 20px 0;
            "
          ></p>
          <div
            id="rp-details-my-amount"
            style="text-align: center; display: none; margin-bottom: 20px"
          >
            <span style="font-size: 40px; font-weight: bold; color: #e44d44"
              >0.00</span
            >
            <span style="font-size: 18px; color: #e44d44">元</span>
          </div>
          <div
            id="rp-details-summary"
            style="
              font-size: 13px;
              color: #8a8a8a;
              border-top: 1px solid #e0e0e0;
              padding-top: 10px;
            "
          ></div>
          <div
            id="rp-details-list"
            style="max-height: 150px; overflow-y: auto; margin-top: 10px"
          >
            <!-- 领取详情将由JS动态生成在这里 -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="save" id="close-rp-details-btn" style="width: 100%">
            关闭
          </button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
    <!-- ▼▼▼ 【全新】创建投票模态框 ▼▼▼ -->
    <div id="create-poll-modal" class="modal">
      <div class="modal-content" style="width: 300px; height: auto">
        <div class="modal-header">
          <span>发起投票</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="poll-question-input">投票问题</label>
            <textarea
              id="poll-question-input"
              rows="2"
              placeholder="例如：今晚我们看什么电影？"
            ></textarea>
          </div>
          <div class="form-group">
            <label>投票选项 (至少2项)</label>
            <div
              id="poll-options-container"
              style="display: flex; flex-direction: column; gap: 8px"
            >
              <!-- 投票选项将由JS动态生成在这里 -->
            </div>
            <button
              id="add-poll-option-btn"
              class="form-button form-button-secondary"
              style="margin-top: 12px"
            >
              + 添加选项
            </button>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-create-poll-btn">取消</button>
          <button class="save" id="confirm-create-poll-btn">发起投票</button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】AI头像库管理模态框 ▼▼▼ -->
    <div id="ai-avatar-library-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span id="ai-avatar-library-title">对方的头像库</span>
          <button id="add-ai-avatar-btn" class="action-button">添加</button>
        </div>
        <div class="modal-body" style="padding: 15px">
          <div
            id="ai-avatar-library-grid"
            style="
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
              gap: 15px;
            "
          >
            <!-- 头像库内容将由JS动态生成 -->
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-ai-avatar-library-btn"
            style="width: 100%"
          >
            关闭
          </button>
        </div>
      </div>
    </div>

    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】用户分享链接模态框 ▼▼▼ -->
    <div id="share-link-modal" class="modal">
      <div class="modal-content" style="width: 300px; height: auto">
        <div class="modal-header">
          <span>分享链接</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="link-title-input">标题</label>
            <input
              type="text"
              id="link-title-input"
              placeholder="输入文章或链接的标题"
            />
          </div>
          <div class="form-group">
            <label for="link-description-input">摘要 (可选)</label>
            <textarea
              id="link-description-input"
              rows="2"
              placeholder="简单描述一下链接内容"
            ></textarea>
          </div>
          <div class="form-group">
            <label for="link-source-input">来源名称 (可选)</label>
            <input
              type="text"
              id="link-source-input"
              placeholder="例如：知乎日报、B站"
            />
          </div>
          <div class="form-group">
            <label for="link-content-input"
              >完整内容 (可选，用于浏览器内显示)</label
            >
            <textarea
              id="link-content-input"
              rows="4"
              placeholder="粘贴或输入完整的文章内容"
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-share-link-btn">取消</button>
          <button class="save" id="confirm-share-link-btn">分享</button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】精致版转账操作弹窗 ▼▼▼ -->
    <div id="transfer-actions-modal" class="modal">
      <div class="transfer-actions-content">
        <div class="transfer-actions-header">请选择操作</div>
        <div class="transfer-actions-body">
          <p>
            你收到了来自
            <strong id="transfer-sender-name"></strong> 的一笔转账。
          </p>
        </div>
        <div class="transfer-actions-footer">
          <button id="transfer-action-decline" class="action-btn decline">
            残忍拒绝
          </button>
          <button id="transfer-action-accept" class="action-btn accept">
            开心收下
          </button>
        </div>
        <button id="transfer-action-cancel" class="cancel-btn">×</button>
      </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】通话记录详情模态框 ▼▼▼ -->
    <div id="call-transcript-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span id="transcript-modal-title">通话详情</span>
        </div>
        <div
          class="modal-body"
          id="transcript-modal-body"
          style="background-color: #f0f2f5"
        >
          <!-- 通话文字记录将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
          <button
            class="cancel"
            id="delete-transcript-btn"
            style="
              background-color: #ff3b30;
              color: white;
              border-color: #ff3b30;
            "
          >
            删除记录
          </button>
          <button
            class="save"
            id="close-transcript-modal-btn"
            style="width: 100%"
          >
            关闭
          </button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】分享目标选择器模态框 ▼▼▼ -->
    <div id="share-target-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>分享到...</span>
        </div>
        <div class="modal-body" id="share-target-list" style="padding: 0">
          <!-- 聊天列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-share-target-btn">取消</button>
          <button class="save" id="confirm-share-target-btn">确认分享</button>
        </div>
      </div>
    </div>

    <!-- ▼▼▼ 【全新】分享记录查看器模态框 ▼▼▼ -->
    <div id="shared-history-viewer-modal" class="modal">
      <div class="modal-content" style="height: 80%">
        <div class="modal-header">
          <span id="shared-history-viewer-title">聊天记录</span>
        </div>
        <div
          class="modal-body"
          id="shared-history-viewer-content"
          style="background-color: #f0f2f5"
        >
          <!-- 分享的聊天记录气泡将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-shared-history-viewer-btn"
            style="width: 100%"
          >
            关闭
          </button>
        </div>
      </div>
    </div>

    <!-- ▼▼▼ 【全新】世界书分类管理模态框 ▼▼▼ -->
    <div id="world-book-category-manager-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>管理世界书分类</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>新建分类</label>
            <div style="display: flex; gap: 10px">
              <input
                type="text"
                id="new-category-name-input"
                placeholder="输入分类名..."
                style="flex-grow: 1"
              />
              <button
                id="add-new-category-btn"
                class="form-button"
                style="width: auto; margin-top: 0; padding: 0 15px"
              >
                添加
              </button>
            </div>
          </div>
          <hr style="opacity: 0.2" />
          <div
            id="existing-categories-list"
            style="display: flex; flex-direction: column; gap: 10px"
          >
            <!-- 分类列表将由JS动态生成 -->
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-category-manager-btn"
            style="width: 100%"
          >
            完成
          </button>
        </div>
      </div>
    </div>
    
    <!-- ▼▼▼ 新增：API配置管理模态框 ▼▼▼ -->
    <div id="api-presets-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>API 配置管理</span>
                <button class="action-button" id="close-api-presets-modal-btn">关闭</button>
            </div>
            <div class="modal-body">
                <div class="form-group" style="border-bottom: 1px solid #eee; padding-bottom: 15px; margin-bottom: 15px;">
                    <label>保存当前配置为:</label>
                    <div style="display: flex; gap: 10px; margin-top: 5px;">
                        <input type="text" id="save-preset-name-input" placeholder="配置名称 (如: DeepSeek-V3)" style="flex-grow: 1;">
                        <button class="form-button" id="save-preset-btn" style="width: auto; margin-top: 0;">保存</button>
                    </div>
                </div>
                <label>已保存的配置:</label>
                <div id="api-presets-list" class="list-container" style="max-height: 300px; padding: 0;">
                    <!-- JS生成列表 -->
                </div>
            </div>
        </div>
    </div>
    <!-- ▲▲▲ 新增结束 ▲▲▲ -->


    <script>
      const GEMINI_API_URL =
        "https://generativelanguage.googleapis.com/v1beta/models";
      // gemini如果是多个密钥, 那么随机获取一个
      function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(",")) {
          // 用逗号分隔字符串并移除多余空格
          const arr = str.split(",").map((item) => item.trim());
          // 生成随机索引 (0 到 arr.length-1)
          const randomIndex = Math.floor(Math.random() * arr.length);
          // 返回随机元素
          return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
      }
      function isImage(text, content) {
        let currentImageData = content.image_url.url;
        // 提取Base64数据（去掉前缀）
        const base64Data = currentImageData.split(",")[1];
        // 根据图片类型获取MIME类型
        const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
        return [
          { text: `${text.text}用户向你发送了一张图片` },
          {
            inline_data: {
              mime_type: mimeType,
              data: base64Data,
            },
          },
        ];
      }

      function extractArray(text) {
        // 正则表达式模式：匹配开头的时间戳部分和后续的JSON数组
        const pattern = /^\(Timestamp: (\d+)\)(.*)$/s;
        const match = text.match(pattern);

        if (match) {
          const timestampPart = `(Timestamp: ${match[1]}) `;
          const jsonPart = match[2].trim();

          try {
            // 尝试解析JSON部分
            const parsedJson = JSON.parse(jsonPart);
            // 验证解析结果是否为数组
            if (Array.isArray(parsedJson)) {
              return [timestampPart, parsedJson[0]];
            }
          } catch (error) {
            // 解析失败，返回原始文本
          }
        }

        // 不匹配格式或解析失败时返回原值
        return text;
      }
      function transformChatData(item) {
        let type = {
          send_and_recall: "撤回了消息",
          update_status: "更新了状态",
          change_music: "切换了歌曲",
          create_memory: "记录了回忆",
          create_countdown: "创建了约定/倒计时",
          text: "发送了文本",
          sticker: "发送了表情",
          ai_image: "发送了图片",
          voice_message: "发送了语音",
          transfer: "发起了转账",
          waimai_request: "发起了外卖请求",
          waimai_response: {
            paid: "回应了外卖-同意",
            rejected: "回应了外卖-拒绝",
          },
          video_call_request: "发起了视频通话",
          video_call_response: {
            accept: "回应了视频通话-接受",
            reject: "回应了视频通话-拒绝",
          },
          qzone_post: {
            shuoshuo: "发布了说说",
            text_image: "发布了文字图",
          },
          qzone_comment: "评论了动态",
          qzone_like: "点赞了动态",
          pat_user: "拍一拍了用户",
          block_user: "拉黑了用户",
          friend_request_response: "回应了好友申请",
          change_avatar: "更换了头像",
          share_link: "分享了链接",
          accept_transfer: "回应了转账-接受",
          decline_transfer: "回应了转账-拒绝/退款",
          quote_reply: "引用了回复",
          text: "",
        };
        let res = extractArray(item.content);

        if (Array.isArray(res)) {
          let obj = res[1];
          let itemType = obj.type;
          let time = res[0];
          let text = type[itemType];
          if (text) {
            if (itemType === "sticker") {
              return [{ text: `${time}[${text}] 含义是:${obj.meaning}` }];
            } else if (itemType === "send_and_recall") {
              return [{ text: `${time}[${text}] ${obj.content}` }];
            } else if (itemType === "update_status") {
              return [
                {
                  text: `${time}[${text}] ${obj.status_text}(${
                    obj.is_busy ? "忙碌/离开" : "空闲"
                  })`,
                },
              ];
            } else if (itemType === "change_music") {
              return [
                {
                  text: `${time}[${text}] ${obj.change_music}, 歌名是:${obj.song_name}`,
                },
              ];
            } else if (itemType === "create_memory") {
              return [{ text: `${time}[${text}] ${obj.description}` }];
            } else if (itemType === "create_countdown") {
              return [{ text: `${time}[${text}] ${obj.title}(${obj.date})` }];
            } else if (itemType === "ai_image") {
              return [
                { text: `${time}[${text}] 图片描述是:${obj.description}` },
              ];
            } else if (itemType === "voice_message") {
              return [{ text: `${time}[${text}] ${obj.content}` }];
            } else if (itemType === "transfer") {
              return [
                {
                  text: `${time}[${text}] 金额是:${obj.amount} 备注是:${obj.amount}`,
                },
              ];
            } else if (itemType === "waimai_request") {
              return [
                {
                  text: `${time}[${text}] 金额是:${obj.amount} 商品是:${obj.productInfo}`,
                },
              ];
            } else if (itemType === "waimai_response") {
              return [
                {
                  text: `${time}[${text[obj.status]}] ${
                    obj.status === "paid" ? "同意" : "拒绝"
                  }`,
                },
              ];
            } else if (itemType === "video_call_request") {
              return [{ text: `${time}[${text}]` }];
            }
          } else if (itemType === "video_call_request") {
            return [
              {
                text: `${time}[${text[obj.decision]}] ${
                  obj.decision === "accept" ? "同意" : "拒绝"
                }`,
              },
            ];
          } else if (itemType === "qzone_post") {
            return [
              {
                text: `${time}[${text[obj.postType]}] ${
                  obj.postType === "shuoshuo"
                    ? `${obj.content}`
                    : `图片描述是:${obj.hiddenContent} ${
                        obj.publicText ? `文案是: ${obj.publicText}` : ""
                      }`
                }`,
              },
            ];
          } else if (itemType === "qzone_comment") {
            return [
              {
                text: `${time}[${text}] 评论的id是: ${obj.postId} 评论的内容是: ${obj.commentText}`,
              },
            ];
          } else if (itemType === "qzone_like") {
            return [{ text: `${time}[${text}] 点赞的id是: ${obj.postId}` }];
          } else if (itemType === "pat_user") {
            return [
              { text: `${time}[${text}] ${obj.suffix ? obj.suffix : ""}` },
            ];
          } else if (itemType === "block_user") {
            return [{ text: `${time}[${text}]` }];
          } else if (itemType === "friend_request_response") {
            return [
              {
                text: `${time}[${text}] 结果是:${
                  obj.decision === "accept" ? "同意" : "拒绝"
                }`,
              },
            ];
          } else if (itemType === "change_avatar") {
            return [{ text: `${time}[${text}] 头像名是:${obj.name}` }];
          } else if (itemType === "share_link") {
            return [
              {
                text: `${time}[${text}] 文章标题是:${obj.title}  文章摘要是:${obj.description} 来源网站名是:${obj.source_name} 文章正文是:${obj.content}`,
              },
            ];
          } else if (itemType === "accept_transfer") {
            return [{ text: `${time}[${text}]` }];
          } else if (itemType === "accept_transfer") {
            return [{ text: `${time}[${text}]` }];
          } else if (itemType === "quote_reply") {
            return [
              { text: `${time}[${text}] 引用的内容是:${obj.reply_content}` },
            ];
          } else if (itemType === "text") {
            return [{ text: `${time}${obj.content}` }];
          }
        }

        if (Array.isArray(res) && res.length > 1) {
          res = `${res[0]}${res[1].content}`;
        }

        return [{ text: res }];
      }

      function toGeminiRequestData(
        model,
        apiKey,
        systemInstruction,
        messagesForDecision,
        isGemini
      ) {
        if (!isGemini) {
          return undefined;
        }

        // 【核心修正】在这里，我们将 'system' 角色也映射为 'user'

        let roleType = {
          user: "user",
          assistant: "model",
          system: "user", // <--- 新增这一行
        };
        return {
          url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(
            apiKey
          )}`,
          data: {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              contents: messagesForDecision.map((item) => {
                let includesImages = false;
                if (Array.isArray(item.content) && item.content.length === 2) {
                  includesImages = item.content.some((sub) => {
                    return sub.type === "image_url" && sub.image_url.url;
                  });
                }
                return {
                  role: roleType[item.role], // 现在 'system' 会被正确转换为 'user'
                  parts: includesImages
                    ? isImage(item.content[0], item.content[1])
                    : transformChatData(item),
                };
              }),
              generationConfig: {
                temperature: 0.8,
              },
              systemInstruction: {
                parts: [
                  {
                    text: systemInstruction,
                  },
                ],
              },
            }),
          },
        };
      }
      document.addEventListener("DOMContentLoaded", () => {
  // === Lightweight performance helpers ===
  /* visibility safeguard for streaming (patched) */
  document.addEventListener(
    "visibilitychange",
    async () => {
      if (document.hidden) {
        try {
          // flush any in-flight streaming content
          await db?.chats?.put?.(state.chats[state.activeChatId]);
        } catch (e) {}
      }
    },
    { passive: true }
  );

  // 2) Default all images to lazy & async decoding (static + dynamically added)
  function setImagePerfAttrs(img) {
    try {
      if (!img.hasAttribute("loading")) img.setAttribute("loading", "lazy");
      if (!img.hasAttribute("decoding")) img.setAttribute("decoding", "async");
    } catch (e) {}
  }
  document.querySelectorAll("img").forEach(setImagePerfAttrs);
  const mo = new MutationObserver((mutations) => {
    for (const m of mutations) {
      m.addedNodes &&
        m.addedNodes.forEach((node) => {
          if (node && node.tagName === "IMG") setImagePerfAttrs(node);
          else if (node && node.querySelectorAll)
            node.querySelectorAll("img").forEach(setImagePerfAttrs);
        });
    }
  });
  mo.observe(document.documentElement, { childList: true, subtree: true });

  // 3) Encourage passive listeners for scroll/touch to prevent jank
  (function () {
    const orig = EventTarget.prototype.addEventListener;
    const defaultPassive = { touchstart: true, touchmove: true, wheel: true };
    EventTarget.prototype.addEventListener = function (type, listener, options) {
      let opts = options;
      if (typeof options === "object" && options !== null) {
        if (defaultPassive[type] && options.passive == null) {
          opts = Object.assign({}, options, { passive: true });
        }
      } else if (options === undefined && defaultPassive[type]) {
        opts = { passive: true };
      }
      return orig.call(this, type, listener, opts);
    };
  })();
        // ===================================================================
        // 1. 所有变量和常量定义
        // ===================================================================
        const db = new Dexie("GeminiChatDB");
        // --- 已修正 ---
        let state = {
          chats: {},
          activeChatId: null,
          globalSettings: {},
          apiConfigs: [],
          userStickers: [],
          worldBooks: [],
          personaPresets: [],
          qzoneSettings: {},
          activeAlbumId: null,
        };

        function getActiveApiConfig() {
            const activeConfigId = state.globalSettings.activeApiConfigId;
            const activeConfig = state.apiConfigs.find((c) => c.id === activeConfigId);
            if (!activeConfig) return null;
            return { 
                proxyUrl: activeConfig.url, 
                apiKey: activeConfig.apiKey, 
                model: activeConfig.model,
                enableStreaming: activeConfig.enableStream // Map to old property name for compatibility
            };
        }
        // --- 修正结束 ---
        let musicState = {
          isActive: false,
          activeChatId: null,
          isPlaying: false,
          playlist: [],
          currentIndex: -1,
          playMode: "order",
          totalElapsedTime: 0,
          timerId: null,
          // 【新增】歌词相关状态
          parsedLyrics: [], // 当前歌曲解析后的歌词数组
          currentLyricIndex: -1, // 当前高亮的歌词行索引
        };
        const audioPlayer = document.getElementById("audio-player");
        let newWallpaperBase64 = null;
        let isSelectionMode = false;
        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;

        let waimaiTimers = {}; // 用于存储外卖倒计时

        let activeMessageTimestamp = null;
        let currentReplyContext = null; // <--- 新增这行，用来存储当前正在引用的消息信息
        let activePostId = null; // <-- 新增：用于存储当前操作的动态ID

        let photoViewerState = {
          isOpen: false,
          photos: [], // 存储当前相册的所有照片URL
          currentIndex: -1, // 当前正在查看的照片索引
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set();

        let simulationIntervalId = null;

        const defaultAvatar = "https://i.postimg.cc/PxZrFFFL/o-o-1.jpg";
        const defaultMyGroupAvatar = "https://i.postimg.cc/cLPP10Vm/4.jpg";
        const defaultGroupMemberAvatar = "https://i.postimg.cc/VkQfgzGJ/1.jpg";
        const defaultGroupAvatar =
          "https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg";
        let notificationTimeout;

        // ▼▼▼ 在JS顶部，变量定义区，添加这个新常量 ▼▼▼
        const DEFAULT_APP_ICONS = {
          "world-book": "https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg",
          qq: "https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg",
          "api-settings": "https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg",
          wallpaper: "https://i.postimg.cc/T1j03pQr/IMG-6440.jpg",
          font: "https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg",
        };
        // ▲▲▲ 添加结束 ▲▲▲

        const STICKER_REGEX =
          /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = {
          hasShown40: false,
          hasShown20: false,
          hasShown10: false,
        };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement("style");
        dynamicFontStyle.id = "dynamic-font-style";
        document.head.appendChild(dynamicFontStyle);

        const modalOverlay = document.getElementById("custom-modal-overlay");
        const modalTitle = document.getElementById("custom-modal-title");
        const modalBody = document.getElementById("custom-modal-body");
        const modalConfirmBtn = document.getElementById("custom-modal-confirm");
        const modalCancelBtn = document.getElementById("custom-modal-cancel");
        let modalResolve;

        function showCustomModal() {
          modalOverlay.classList.add("visible");
        }

        function hideCustomModal() {
          modalOverlay.classList.remove("visible");
          modalConfirmBtn.classList.remove("btn-danger");
          if (modalResolve) modalResolve(null);
        }

        function showCustomConfirm(title, message, options = {}) {
          return new Promise((resolve) => {
            modalResolve = resolve;
            modalTitle.textContent = title;
            modalBody.innerHTML = `<p>${message}</p>`;
            modalCancelBtn.style.display = "block";
            modalConfirmBtn.textContent = "确定";
            if (options.confirmButtonClass)
              modalConfirmBtn.classList.add(options.confirmButtonClass);
            modalConfirmBtn.onclick = () => {
              resolve(true);
              hideCustomModal();
            };
            modalCancelBtn.onclick = () => {
              resolve(false);
              hideCustomModal();
            };
            showCustomModal();
          });
        }

        function showCustomAlert(title, message) {
          return new Promise((resolve) => {
            modalResolve = resolve;
            modalTitle.textContent = title;
            modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
            modalCancelBtn.style.display = "none";
            modalConfirmBtn.textContent = "好的";
            modalConfirmBtn.onclick = () => {
              modalCancelBtn.style.display = "block";
              modalConfirmBtn.textContent = "确定";
              resolve(true);
              hideCustomModal();
            };
            showCustomModal();
          });
        }

        // ▼▼▼ 请用这个【功能增强版】替换旧的 showCustomPrompt 函数 ▼▼▼
        function showCustomPrompt(
          title,
          placeholder,
          initialValue = "",
          type = "text",
          extraHtml = ""
        ) {
          return new Promise((resolve) => {
            modalResolve = resolve;
            modalTitle.textContent = title;
            const inputId = "custom-prompt-input";

            const inputHtml =
              type === "textarea"
                ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
                : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;

            // 【核心修改】将额外的HTML和输入框组合在一起
            modalBody.innerHTML = extraHtml + inputHtml;
            const input = document.getElementById(inputId);

            // 【核心修改】为格式助手按钮绑定事件
            modalBody.querySelectorAll(".format-btn").forEach((btn) => {
              btn.addEventListener("click", () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                  try {
                    const templateObj = JSON.parse(templateStr);
                    // 使用 null, 2 参数让JSON字符串格式化，带缩进，更易读
                    input.value = JSON.stringify(templateObj, null, 2);
                    input.focus();
                  } catch (e) {
                    console.error("解析格式模板失败:", e);
                  }
                }
              });
            });

            modalConfirmBtn.onclick = () => {
              resolve(input.value);
              hideCustomModal();
            };
            modalCancelBtn.onclick = () => {
              resolve(null);
              hideCustomModal();
            };
            showCustomModal();
            setTimeout(() => input.focus(), 100);
          });
        }
        // ▲▲▲ 替换结束 ▲▲▲

        // ===================================================================
        // 2. 数据库结构定义
        // ===================================================================

        db.version(24)
          .stores({
            chats: "&id, isGroup, groupId",
            // apiConfig: "&id", // <- 移除旧表
            apiConfigs: "++id, name", // <- 新增，用于存储多个API配置
            globalSettings: "&id",
            userStickers: "&id, url, name",
            worldBooks: "&id, name, categoryId",
            worldBookCategories: "++id, name",
            musicLibrary: "&id",
            personaPresets: "&id",
            qzoneSettings: "&id",
            qzonePosts: "++id, timestamp",
            qzoneAlbums: "++id, name, createdAt",
            qzonePhotos: "++id, albumId",
            favorites: "++id, type, timestamp, originalTimestamp",
            qzoneGroups: "++id, name",
            memories: "++id, chatId, timestamp, type, targetDate",
            callRecords: "++id, chatId, timestamp, customName",
          })
          .upgrade(async (tx) => {
            // 数据迁移脚本：从旧的单个 apiConfig 迁移到新的 apiConfigs 列表
            const oldConfig = await tx.table("apiConfig").get("main");
            if (oldConfig) {
              console.log("检测到旧版API配置，正在执行自动迁移...");
              const newConfigsTable = tx.table("apiConfigs");
              const existingConfigs = await newConfigsTable.toArray();
              if (existingConfigs.length === 0) {
                const newId = await newConfigsTable.add({
                  name: "默认配置",
                  url: oldConfig.proxyUrl || "",
                  apiKey: oldConfig.apiKey || "",
                  model: oldConfig.model || "",
                  enableStream: oldConfig.enableStream || false,
                  hideStreamResponse: oldConfig.hideStreamResponse || false,
                });

                const globalSettings = (await tx.table("globalSettings").get("main")) || { id: "main" };
                globalSettings.activeApiConfigId = newId;
                await tx.table("globalSettings").put(globalSettings);

                await tx.table("apiConfig").clear();
                console.log("API配置迁移成功！");
              }
            }
          });

        // ===================================================================
        // 3. 所有功能函数定义
        // ===================================================================

        function showScreen(screenId) {
          if (screenId === "chat-list-screen") {
            window.renderChatListProxy();
            switchToChatListView("messages-view");
          }
          if (screenId === "api-settings-screen")
            window.renderApiSettingsProxy();
          if (screenId === "wallpaper-screen")
            window.renderWallpaperScreenProxy();
          if (screenId === "world-book-screen")
            window.renderWorldBookScreenProxy();
          document
            .querySelectorAll(".screen")
            .forEach((s) => s.classList.remove("active"));
          const screenToShow = document.getElementById(screenId);
          if (screenToShow) screenToShow.classList.add("active");
          if (screenId === "chat-interface-screen")
            window.updateListenTogetherIconProxy(state.activeChatId);
          if (screenId === "font-settings-screen") {
            document.getElementById("font-url-input").value =
              state.globalSettings.fontUrl || "";
            applyCustomFont(state.globalSettings.fontUrl || "", true);
          }
        }
        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
          const chatListScreen = document.getElementById("chat-list-screen");
          const views = {
            "messages-view": document.getElementById("messages-view"),
            "qzone-screen": document.getElementById("qzone-screen"),
            "favorites-view": document.getElementById("favorites-view"),
            "memories-view": document.getElementById("memories-view"), // <-- 新增这一行
          };
          const mainHeader = document.getElementById("main-chat-list-header");
          const mainBottomNav = document.getElementById("chat-list-bottom-nav"); // 获取主导航栏

          if (isFavoritesSelectionMode) {
            document.getElementById("favorites-edit-btn").click();
          }

          // 隐藏所有视图
          Object.values(views).forEach((v) => v.classList.remove("active"));
          // 显示目标视图
          if (views[viewId]) {
            views[viewId].classList.add("active");
          }

          // 更新底部导航栏高亮
          document
            .querySelectorAll("#chat-list-bottom-nav .nav-item")
            .forEach((item) => {
              item.classList.toggle("active", item.dataset.view === viewId);
            });

          // ▼▼▼ 【核心修正】在这里统一管理所有UI元素的显隐 ▼▼▼
          if (viewId === "messages-view") {
            mainHeader.style.display = "flex";
            mainBottomNav.style.display = "flex";
          } else {
            mainHeader.style.display = "none";
            mainBottomNav.style.display = "none";
          }
          // ▲▲▲ 修正结束 ▲▲▲

          if (viewId !== "memories-view") {
            activeCountdownTimers.forEach((timerId) => clearInterval(timerId));
            activeCountdownTimers = [];
          }

          // 根据视图ID执行特定的渲染/更新逻辑
          switch (viewId) {
            case "qzone-screen":
              views["qzone-screen"].style.backgroundColor = "#f0f2f5";
              updateUnreadIndicator(0);
              renderQzoneScreen();
              renderQzonePosts();
              break;
            case "favorites-view":
              views["favorites-view"].style.backgroundColor = "#f9f9f9";
              renderFavoritesScreen();
              break;
            case "messages-view":
              // 如果需要，可以在这里添加返回消息列表时要执行的逻辑
              break;
          }
        }

        function renderQzoneScreen() {
          if (state && state.qzoneSettings) {
            const settings = state.qzoneSettings;
            document.getElementById("qzone-nickname").textContent =
              settings.nickname;
            document.getElementById("qzone-avatar-img").src = settings.avatar;
            document.getElementById("qzone-banner-img").src = settings.banner;
          }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        async function saveQzoneSettings() {
          if (db && state.qzoneSettings) {
            await db.qzoneSettings.put(state.qzoneSettings);
          }
        }

        function formatPostTimestamp(timestamp) {
          if (!timestamp) return "";
          const now = new Date();
          const date = new Date(timestamp);
          const diffSeconds = Math.floor((now - date) / 1000);
          const diffMinutes = Math.floor(diffSeconds / 60);
          const diffHours = Math.floor(diffMinutes / 60);
          if (diffMinutes < 1) return "刚刚";
          if (diffMinutes < 60) return `${diffMinutes}分钟前`;
          if (diffHours < 24) return `${diffHours}小时前`;
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          const hours = String(date.getHours()).padStart(2, "0");
          const minutes = String(date.getMinutes()).padStart(2, "0");
          if (now.getFullYear() === year) {
            return `${month}-${day} ${hours}:${minutes}`;
          } else {
            return `${year}-${month}-${day} ${hours}:${minutes}`;
          }
        }

        // ▼▼▼ 请用这个【已添加删除按钮】的函数，完整替换掉你旧的 renderQzonePosts 函数 ▼▼▼
        async function renderQzonePosts() {
          const postsListEl = document.getElementById("qzone-posts-list");
          if (!postsListEl) return;

          const [posts, favorites] = await Promise.all([
            db.qzonePosts.orderBy("timestamp").reverse().toArray(),
            db.favorites.where("type").equals("qzone_post").toArray(),
          ]);

          const favoritedPostIds = new Set(
            favorites.map((fav) => fav.content.id)
          );

          postsListEl.innerHTML = "";

          if (posts.length === 0) {
            postsListEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
            return;
          }

          const userSettings = state.qzoneSettings;

          posts.forEach((post) => {
            const postContainer = document.createElement("div");
            postContainer.className = "qzone-post-container";
            postContainer.dataset.postId = post.id;

            const postEl = document.createElement("div");
            postEl.className = "qzone-post-item";

            let authorAvatar = "",
              authorNickname = "",
              commentAvatar = userSettings.avatar;

            if (post.authorId === "user") {
              authorAvatar = userSettings.avatar;
              authorNickname = userSettings.nickname;
            } else if (state.chats[post.authorId]) {
              const authorChat = state.chats[post.authorId];
              authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
              authorNickname = authorChat.name;
            } else {
              authorAvatar = defaultAvatar;
              authorNickname = "{{char}}";
            }

            let contentHtml = "";
            const publicTextHtml = post.publicText
              ? `<div class="post-content">${post.publicText.replace(
                  /\n/g,
                  "<br>"
                )}</div>`
              : "";

            if (post.type === "shuoshuo") {
              contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(
                /\n/g,
                "<br>"
              )}</div>`;
            } else if (post.type === "image_post" && post.imageUrl) {
              contentHtml = publicTextHtml
                ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>`
                : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === "text_image") {
              contentHtml = publicTextHtml
                ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>`
                : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            }

            let likesHtml = "";
            if (post.likes && post.likes.length > 0) {
              likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join(
                "、"
              )} 觉得很赞</span></div>`;
            }

            let commentsHtml = "";
            if (post.comments && post.comments.length > 0) {
              commentsHtml = '<div class="post-comments-container">';
              // ★★★★★【核心修改就在这里】★★★★★
              // 遍历评论时，我们传入 comment 对象本身和它的索引 index
              post.comments.forEach((comment, index) => {
                // 在评论项的末尾，添加一个带有 data-comment-index 属性的删除按钮
                commentsHtml += `
                    <div class="comment-item">
                        <span class="commenter-name">${comment.commenterName}:</span>
                        <span class="comment-text">${comment.text}</span>
                        <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                    </div>`;
              });
              // ★★★★★【修改结束】★★★★★
              commentsHtml += "</div>";
            }

            const userNickname = state.qzoneSettings.nickname;
            const isLikedByUser =
              post.likes && post.likes.includes(userNickname);
            const isFavoritedByUser = favoritedPostIds.has(post.id);

            postEl.innerHTML = `
            <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(
              post.timestamp
            )}</span></div>
                <div class="post-actions-btn">…</div>
            </div>
            <div class="post-main-content">${contentHtml}</div>
            <div class="post-feedback-icons">
                <span class="action-icon like ${
                  isLikedByUser ? "active" : ""
                }"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                <span class="action-icon favorite ${
                  isFavoritedByUser ? "active" : ""
                }"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
            </div>
            ${likesHtml}
            ${commentsHtml}
            <div class="post-footer"><div class="comment-section"><img src="${commentAvatar}" class="comment-avatar"><input type="text" class="comment-input" placeholder="友善的评论是交流的起点"><div class="at-mention-popup"></div></div><button class="comment-send-btn">发送</button></div>
        `;

            const deleteAction = document.createElement("div");
            deleteAction.className = "qzone-post-delete-action";
            deleteAction.innerHTML = "<span>删除</span>";
            postContainer.appendChild(postEl);
            postContainer.appendChild(deleteAction);
            const commentSection =
              postContainer.querySelector(".comment-section");
            if (commentSection) {
              commentSection.addEventListener("touchstart", (e) =>
                e.stopPropagation()
              );
              commentSection.addEventListener("mousedown", (e) =>
                e.stopPropagation()
              );
            }
            postsListEl.appendChild(postContainer);
            const commentInput = postContainer.querySelector(".comment-input");
            const popup = postContainer.querySelector(".at-mention-popup");
            commentInput.addEventListener("input", () => {
              const value = commentInput.value;
              const atMatch = value.match(/@([\p{L}\w]*)$/u);
              if (atMatch) {
                const namesToMention = new Set();
                const authorNickname =
                  postContainer.querySelector(".post-nickname")?.textContent;
                if (authorNickname) namesToMention.add(authorNickname);
                postContainer
                  .querySelectorAll(".commenter-name")
                  .forEach((nameEl) => {
                    namesToMention.add(nameEl.textContent.replace(":", ""));
                  });
                namesToMention.delete(state.qzoneSettings.nickname);
                popup.innerHTML = "";
                if (namesToMention.size > 0) {
                  const searchTerm = atMatch[1];
                  namesToMention.forEach((name) => {
                    if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                      const item = document.createElement("div");
                      item.className = "at-mention-item";
                      item.textContent = name;
                      item.addEventListener("mousedown", (e) => {
                        e.preventDefault();
                        const newText =
                          value.substring(0, atMatch.index) + `@${name} `;
                        commentInput.value = newText;
                        popup.style.display = "none";
                        commentInput.focus();
                      });
                      popup.appendChild(item);
                    }
                  });
                  popup.style.display =
                    popup.children.length > 0 ? "block" : "none";
                } else {
                  popup.style.display = "none";
                }
              } else {
                popup.style.display = "none";
              }
            });
            commentInput.addEventListener("blur", () => {
              setTimeout(() => {
                popup.style.display = "none";
              }, 200);
            });
          });
        }
        // ▲▲▲ 替换结束 ▲▲▲

        // ▼▼▼ 请用下面这个【更新后的】函数，完整替换掉你代码中旧的 displayFilteredFavorites 函数 ▼▼▼

        function displayFilteredFavorites(items) {
          const listEl = document.getElementById("favorites-list");
          listEl.innerHTML = "";

          if (items.length === 0) {
            const searchTerm = document.getElementById(
              "favorites-search-input"
            ).value;
            const message = searchTerm
              ? "未找到相关收藏"
              : "你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！";
            listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
            return;
          }

          for (const item of items) {
            const card = document.createElement("div");
            card.className = "favorite-item-card";
            card.dataset.favid = item.id;

            let headerHtml = "",
              contentHtml = "",
              sourceText = "",
              footerHtml = "";

            if (item.type === "qzone_post") {
              const post = item.content;
              sourceText = "来自动态";
              let authorAvatar = defaultAvatar,
                authorNickname = "未知用户";

              if (post.authorId === "user") {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
              } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
              }

              headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;

              const publicTextHtml = post.publicText
                ? `<div class="post-content">${post.publicText.replace(
                    /\n/g,
                    "<br>"
                  )}</div>`
                : "";
              if (post.type === "shuoshuo") {
                contentHtml = `<div class="post-content">${post.content.replace(
                  /\n/g,
                  "<br>"
                )}</div>`;
              } else if (post.type === "image_post" && post.imageUrl) {
                contentHtml = publicTextHtml
                  ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>`
                  : `<img src="${post.imageUrl}" class="chat-image">`;
              } else if (post.type === "text_image") {
                contentHtml = publicTextHtml
                  ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>`
                  : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
              }

              // ▼▼▼ 新增/修改的代码开始 ▼▼▼

              // 1. 构造点赞区域的HTML
              let likesHtml = "";
              // 检查 post 对象中是否存在 likes 数组并且不为空
              if (post.likes && post.likes.length > 0) {
                // 如果存在，就创建点赞区域的 div
                likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join("、")} 觉得很赞</span>
                    </div>`;
              }

              // 2. 构造评论区域的HTML
              let commentsHtml = "";
              // 检查 post 对象中是否存在 comments 数组并且不为空
              if (post.comments && post.comments.length > 0) {
                // 如果存在，就创建评论容器，并遍历每一条评论
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach((comment) => {
                  commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                });
                commentsHtml += "</div>";
              }

              // 3. 将点赞和评论的HTML组合到 footerHtml 中
              footerHtml = `${likesHtml}${commentsHtml}`;

              // ▲▲▲ 新增/修改的代码结束 ▲▲▲
            } else if (item.type === "chat_message") {
              const msg = item.content;
              const chat = state.chats[item.chatId];
              if (!chat) continue;

              sourceText = `来自与 ${chat.name} 的聊天`;
              const isUser = msg.role === "user";
              let senderName, senderAvatar;

              if (isUser) {
                // 用户消息的逻辑保持不变
                senderName = chat.isGroup
                  ? chat.settings.myNickname || "我"
                  : "我";
                senderAvatar =
                  chat.settings.myAvatar ||
                  (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
              } else {
                // AI/成员消息
                if (chat.isGroup) {
                  // ★★★★★ 这就是唯一的、核心的修改！ ★★★★★
                  // 我们现在使用 originalName 去匹配，而不是旧的 name
                  const member = chat.members.find(
                    (m) => m.originalName === msg.senderName
                  );
                  // ★★★★★ 修改结束 ★★★★★

                  senderName = msg.senderName;
                  // 因为现在能正确找到 member 对象了，所以也能正确获取到他的头像
                  senderAvatar = member
                    ? member.avatar
                    : defaultGroupMemberAvatar;
                } else {
                  // 单聊的逻辑保持不变
                  senderName = chat.name;
                  senderAvatar = chat.settings.aiAvatar || defaultAvatar;
                }
              }

              // 后续拼接 headerHtml 和 contentHtml 的逻辑都保持不变
              headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;

              if (
                typeof msg.content === "string" &&
                STICKER_REGEX.test(msg.content)
              ) {
                contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
              } else if (
                Array.isArray(msg.content) &&
                msg.content[0]?.type === "image_url"
              ) {
                contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
              } else {
                contentHtml = String(msg.content || "").replace(/\n/g, "<br>");
              }
            }

            // ▼▼▼ 修改最终的HTML拼接，加入 footerHtml ▼▼▼
            card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content">${contentHtml}</div>
            ${footerHtml}`; // <-- 把我们新创建的 footerHtml 放在这里

            listEl.appendChild(card);
          }
        }

        // ▲▲▲ 替换区域结束 ▲▲▲

        /**
         * 【重构后的函数】: 负责准备数据并触发渲染
         */
        async function renderFavoritesScreen() {
          // 1. 从数据库获取最新数据并缓存
          allFavoriteItems = await db.favorites
            .orderBy("timestamp")
            .reverse()
            .toArray();

          // 2. 清空搜索框并隐藏清除按钮
          const searchInput = document.getElementById("favorites-search-input");
          const clearBtn = document.getElementById(
            "favorites-search-clear-btn"
          );
          searchInput.value = "";
          clearBtn.style.display = "none";

          // 3. 显示所有收藏项
          displayFilteredFavorites(allFavoriteItems);
        }

        // ▲▲▲ 粘贴结束 ▲▲▲

        function resetCreatePostModal() {
          document.getElementById("post-public-text").value = "";
          document.getElementById("post-image-preview").src = "";
          document.getElementById("post-image-description").value = "";
          document
            .getElementById("post-image-preview-container")
            .classList.remove("visible");
          document.getElementById("post-image-desc-group").style.display =
            "none";
          document.getElementById("post-local-image-input").value = "";
          document.getElementById("post-hidden-text").value = "";
          document.getElementById("switch-to-image-mode").click();
        }

        // ▼▼▼ 用这个【已包含 memories】的版本，完整替换旧的 exportBackup 函数 ▼▼▼
        async function exportBackup() {
          try {
            const backupData = {
              version: 1,
              timestamp: Date.now(),
            };

            const [
              chats,
              worldBooks,
              userStickers,
              apiConfig,
              globalSettings,
              personaPresets,
              musicLibrary,
              qzoneSettings,
              qzonePosts,
              qzoneAlbums,
              qzonePhotos,
              favorites,
              qzoneGroups,
              memories,
              worldBookCategories, // <-- 【核心修改1】在这里添加新变量
            ] = await Promise.all([
              db.chats.toArray(),
              db.worldBooks.toArray(),
              db.userStickers.toArray(),
              db.apiConfig.get("main"),
              db.globalSettings.get("main"),
              db.personaPresets.toArray(),
              db.musicLibrary.get("main"),
              db.qzoneSettings.get("main"),
              db.qzonePosts.toArray(),
              db.qzoneAlbums.toArray(),
              db.qzonePhotos.toArray(),
              db.favorites.toArray(),
              db.qzoneGroups.toArray(),
              db.memories.toArray(),
              db.worldBookCategories.toArray(), // <-- 【核心修改2】在这里添加对新表的读取
            ]);

            Object.assign(backupData, {
              chats,
              worldBooks,
              userStickers,
              apiConfig,
              globalSettings,
              personaPresets,
              musicLibrary,
              qzoneSettings,
              qzonePosts,
              qzoneAlbums,
              qzonePhotos,
              favorites,
              qzoneGroups,
              memories,
              worldBookCategories, // <-- 【核心修改3】将新数据添加到备份对象中
            });

            const blob = new Blob([JSON.stringify(backupData, null, 2)], {
              type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const link = Object.assign(document.createElement("a"), {
              href: url,
              download: `EPhone-Full-Backup-${
                new Date().toISOString().split("T")[0]
              }.json`,
            });
            link.click();
            URL.revokeObjectURL(url);

            await showCustomAlert("导出成功", "已成功导出所有数据！");
          } catch (error) {
            console.error("导出数据时出错:", error);
            await showCustomAlert(
              "导出失败",
              `发生了一个错误: ${error.message}`
            );
          }
        }

        // ▼▼▼ 用这个【已包含 memories】的版本，完整替换旧的 importBackup 函数 ▼▼▼
        async function importBackup(file) {
          if (!file) return;

          const confirmed = await showCustomConfirm(
            "严重警告！",
            "导入备份将完全覆盖您当前的所有数据，包括聊天、动态、设置等。此操作不可撤销！您确定要继续吗？",
            { confirmButtonClass: "btn-danger" }
          );

          if (!confirmed) return;

          try {
            const text = await file.text();
            const data = JSON.parse(text);

            await db.transaction("rw", db.tables, async () => {
              for (const table of db.tables) {
                await table.clear();
              }

              if (Array.isArray(data.chats)) await db.chats.bulkPut(data.chats);
              if (Array.isArray(data.worldBooks))
                await db.worldBooks.bulkPut(data.worldBooks);
              if (Array.isArray(data.worldBookCategories))
                await db.worldBookCategories.bulkPut(data.worldBookCategories);
              if (Array.isArray(data.userStickers))
                await db.userStickers.bulkPut(data.userStickers);
              if (Array.isArray(data.personaPresets))
                await db.personaPresets.bulkPut(data.personaPresets);
              if (Array.isArray(data.qzonePosts))
                await db.qzonePosts.bulkPut(data.qzonePosts);
              if (Array.isArray(data.qzoneAlbums))
                await db.qzoneAlbums.bulkPut(data.qzoneAlbums);
              if (Array.isArray(data.qzonePhotos))
                await db.qzonePhotos.bulkPut(data.qzonePhotos);
              if (Array.isArray(data.favorites))
                await db.favorites.bulkPut(data.favorites);
              if (Array.isArray(data.qzoneGroups))
                await db.qzoneGroups.bulkPut(data.qzoneGroups);
              if (Array.isArray(data.memories))
                await db.memories.bulkPut(data.memories); // 【核心修正】新增

              if (data.apiConfig) await db.apiConfig.put(data.apiConfig);
              if (data.globalSettings)
                await db.globalSettings.put(data.globalSettings);
              if (data.musicLibrary)
                await db.musicLibrary.put(data.musicLibrary);
              if (data.qzoneSettings)
                await db.qzoneSettings.put(data.qzoneSettings);
            });

            await showCustomAlert(
              "导入成功",
              "所有数据已成功恢复！应用即将刷新以应用所有更改。"
            );

            setTimeout(() => {
              window.location.reload();
            }, 1500);
          } catch (error) {
            console.error("导入数据时出错:", error);
            await showCustomAlert(
              "导入失败",
              `文件格式不正确或数据已损坏: ${error.message}`
            );
          }
        }

        function applyCustomFont(fontUrl, isPreviewOnly = false) {
          if (!fontUrl) {
            dynamicFontStyle.innerHTML = "";
            document.getElementById("font-preview").style.fontFamily = "";
            return;
          }
          const fontName = "custom-user-font";
          const newStyle = `
                @font-face {
                  font-family: '${fontName}';
                  src: url('${fontUrl}');
                  font-display: swap;
                }`;
          if (isPreviewOnly) {
            const previewStyle =
              document.getElementById("preview-font-style") ||
              document.createElement("style");
            previewStyle.id = "preview-font-style";
            previewStyle.innerHTML = newStyle;
            if (!document.getElementById("preview-font-style"))
              document.head.appendChild(previewStyle);
            document.getElementById(
              "font-preview"
            ).style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
          } else {
            dynamicFontStyle.innerHTML = `
                    ${newStyle}
                    body {
                      font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                    }`;
          }
        }

        async function resetToDefaultFont() {
          dynamicFontStyle.innerHTML = "";
          state.globalSettings.fontUrl = "";
          await db.globalSettings.put(state.globalSettings);
          document.getElementById("font-url-input").value = "";
          document.getElementById("font-preview").style.fontFamily = "";
          alert("已恢复默认字体。");
        }

        async function loadAllDataFromDB() {
          // ▼▼▼ 【核心修改在这里】 ▼▼▼
          const [
            chatsArr,
            apiConfigs, // <-- 修改这里
            globalSettings,
            userStickers,
            worldBooks,
            musicLib,
            personaPresets,
            qzoneSettings,
            initialFavorites,
          ] = await Promise.all([
            db.chats.toArray(),
            db.apiConfigs.toArray(), // <-- 修改这里
            db.globalSettings.get("main"),
            db.userStickers.toArray(),
            db.worldBooks.toArray(),
            db.musicLibrary.get("main"),
            db.personaPresets.toArray(),
            db.qzoneSettings.get("main"),
            db.favorites.orderBy("timestamp").reverse().toArray(),
          ]);
          // ▲▲▲ 【修改结束】 ▲▲▲

          state.chats = chatsArr.reduce((acc, chat) => {
            if (typeof chat.unreadCount === "undefined") {
              chat.unreadCount = 0; // 如果这个聊天对象没有 unreadCount 属性，就给它初始化为 0
            }

            // ★★★【核心重构：数据迁移脚本】★★★
            // 检查是否是群聊，并且其成员对象使用的是旧的 `name` 结构
            if (
              chat.isGroup &&
              chat.members &&
              chat.members.length > 0 &&
              chat.members[0].name
            ) {
              console.log(
                `检测到旧版群聊数据 for "${chat.name}"，正在执行迁移...`
              );
              chat.members.forEach((member) => {
                // 如果这个成员对象没有 originalName，说明是旧数据
                if (typeof member.originalName === "undefined") {
                  member.originalName = member.name; // 将旧的 name 作为 originalName
                  member.groupNickname = member.name; // 同时创建一个初始的 groupNickname
                  delete member.name; // 删除旧的、有歧义的 name 字段
                  needsUpdate = true; // 标记需要存回数据库
                }
              });
              console.log(`迁移完成 for "${chat.name}"`);
            }

            // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
            // 检查1：如果是一个单聊，并且没有 status 属性
            if (!chat.isGroup && !chat.status) {
              // 就为它补上一个默认的 status 对象
              chat.status = {
                text: "在线",
                lastUpdate: Date.now(),
                isBusy: false,
              };
              console.log(`为旧角色 "${chat.name}" 补全了status属性。`);
            }
            // --- ▲▲▲ 修复结束 ▲▲▲

            // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
            // 检查2：兼容最新的“关系”功能
            if (!chat.isGroup && !chat.relationship) {
              // 如果是单聊，且没有 relationship 对象，就补上一个默认的
              chat.relationship = {
                status: "friend",
                blockedTimestamp: null,
                applicationReason: "",
              };
              console.log(`为旧角色 "${chat.name}" 补全了 relationship 属性。`);
            }
            // --- ▲▲▲ 修复结束 ▲▲▲

            // ▼▼▼ 在这里添加 ▼▼▼
            if (
              !chat.isGroup &&
              (!chat.settings || !chat.settings.aiAvatarLibrary)
            ) {
              if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
              chat.settings.aiAvatarLibrary = [];
              console.log(
                `为旧角色 "${chat.name}" 补全了aiAvatarLibrary属性。`
              );
            }
            // ▲▲▲ 添加结束 ▲▲▲

            if (!chat.musicData) chat.musicData = { totalTime: 0 };
            if (
              chat.settings &&
              chat.settings.linkedWorldBookId &&
              !chat.settings.linkedWorldBookIds
            ) {
              chat.settings.linkedWorldBookIds = [
                chat.settings.linkedWorldBookId,
              ];
              delete chat.settings.linkedWorldBookId;
            }
            acc[chat.id] = chat;
            return acc;
          }, {});
          state.apiConfigs = apiConfigs || [];

          state.globalSettings = globalSettings || {
            id: "main",
            wallpaper: "linear-gradient(135deg, #89f7fe, #66a6ff)",
            fontUrl: "",
            enableBackgroundActivity: false,
            backgroundActivityInterval: 60,
            blockCooldownHours: 1,
            appIcons: { ...DEFAULT_APP_ICONS }, // 【核心修改】确保appIcons存在并有默认值
            framelessOnMobile: false, // 【核心新增】默认不开启无边框模式
            frameColor: "#ffffff", // 【核心新增】默认外框颜色
          };
          // 【核心修改】合并已保存的图标和默认图标，防止更新后旧数据丢失新图标
          state.globalSettings.appIcons = {
            ...DEFAULT_APP_ICONS,
            ...(state.globalSettings.appIcons || {}),
          };

          state.userStickers = userStickers || [];
          state.worldBooks = worldBooks || [];
          musicState.playlist = musicLib?.playlist || [];
          state.personaPresets = personaPresets || [];
          state.qzoneSettings = qzoneSettings || {
            id: "main",
            nickname: "{{user}}",
            avatar: "https://files.catbox.moe/q6z5fc.jpeg",
            banner: "https://files.catbox.moe/r5heyt.gif",
          };

          // ▼▼▼ 【确保这一行在 Promise.all 之后，并使用解构赋值得到的 initialFavorites】 ▼▼▼
          allFavoriteItems = initialFavorites || [];
          // ▲▲▲ 【修改结束】 ▲▲▲
        }

        async function saveGlobalPlaylist() {
          await db.musicLibrary.put({
            id: "main",
            playlist: musicState.playlist,
          });
        }

        function formatTimestamp(timestamp) {
          if (!timestamp) return "";
          const date = new Date(timestamp);
          const hours = String(date.getHours()).padStart(2, "0");
          const minutes = String(date.getMinutes()).padStart(2, "0");
          return `${hours}:${minutes}`;
        }

        function showNotification(chatId, messageContent) {
          clearTimeout(notificationTimeout);
          const chat = state.chats[chatId];
          if (!chat) return;
          const bar = document.getElementById("notification-bar");
          document.getElementById("notification-avatar").src =
            chat.settings.aiAvatar ||
            chat.settings.groupAvatar ||
            defaultAvatar;
          document
            .getElementById("notification-content")
            .querySelector(".name").textContent = chat.name;
          document
            .getElementById("notification-content")
            .querySelector(".message").textContent = messageContent;
          const newBar = bar.cloneNode(true);
          bar.parentNode.replaceChild(newBar, bar);
          newBar.addEventListener("click", () => {
            openChat(chatId);
            newBar.classList.remove("visible");
          });
          newBar.classList.add("visible");
          notificationTimeout = setTimeout(() => {
            newBar.classList.remove("visible");
          }, 4000);
        }

        function updateClock() {
          const now = new Date();
          const timeString = now.toLocaleTimeString("zh-CN", {
            hour: "2-digit",
            minute: "2-digit",
          });
          const dateString = now.toLocaleDateString("zh-CN", {
            weekday: "long",
            month: "long",
            day: "numeric",
          });
          document.getElementById("main-time").textContent = timeString;
          document.getElementById("status-bar-time").textContent = timeString;
          document.getElementById("main-date").textContent = dateString;
        }

        /**
         * 【终极健壮版】解析AI返回的、可能格式不规范的响应内容
         * @param {string} content - AI返回的原始字符串
         * @returns {Array} - 一个标准化的消息对象数组
         */
        function parseAiResponse(content) {
          const trimmedContent = content.trim();

          // 方案1：【最优先】尝试作为标准的、单一的JSON数组解析
          // 这是最理想、最高效的情况
          if (trimmedContent.startsWith("[") && trimmedContent.endsWith("]")) {
            try {
              const parsed = JSON.parse(trimmedContent);
              if (Array.isArray(parsed)) {
                console.log("解析成功：标准JSON数组格式。");
                return parsed;
              }
            } catch (e) {
              // 如果解析失败，说明它虽然看起来像个数组，但内部格式有问题。
              // 此时我们不报错，而是继续尝试下面的“强力解析”方案。
              console.warn("标准JSON数组解析失败，将尝试强力解析...");
            }
          }

          // 方案2：【强力解析】使用正则表达式，从混乱的字符串中提取出所有独立的JSON对象
          // 这能完美解决您遇到的 "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" 这种格式
          const jsonMatches = trimmedContent.match(/{[^{}]*}/g);

          if (jsonMatches) {
            const results = [];
            for (const match of jsonMatches) {
              try {
                // 尝试解析每一个被我们“揪”出来的JSON字符串
                const parsedObject = JSON.parse(match);
                results.push(parsedObject);
              } catch (e) {
                // 如果某个片段不是有效的JSON，就忽略它，继续处理下一个
                console.warn("跳过一个无效的JSON片段:", match);
              }
            }

            // 如果我们成功提取出了至少一个有效的JSON对象，就返回这个结果
            if (results.length > 0) {
              console.log("解析成功：通过强力提取模式。");
              return results;
            }
          }

          // 方案3：【最终备用】如果以上所有方法都失败了，说明AI返回的可能就是纯文本
          // 我们将原始的、未处理的内容，包装成一个标准的文本消息对象返回，确保程序不会崩溃
          console.error("所有解析方案均失败！将返回原始文本。");
          return [{ type: "text", content: content }];
        }

        function renderApiSettings() {
          // 渲染其他全局设置（保持不变）
          document.getElementById("background-activity-switch").checked =
            state.globalSettings.enableBackgroundActivity || false;
          document.getElementById("background-interval-input").value =
            state.globalSettings.backgroundActivityInterval || 60;
          document.getElementById("block-cooldown-input").value =
            state.globalSettings.blockCooldownHours || 1;

          // 渲染API配置列表
          const listEl = document.getElementById("api-configs-list");
          listEl.innerHTML = "";
          if (state.apiConfigs.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary);">还没有任何配置，请点击“添加”创建一个</p>';
          }

          const activeId = state.globalSettings.activeApiConfigId;

          state.apiConfigs.forEach((config) => {
            const item = document.createElement("div");
            item.className = "api-config-item";
            item.dataset.configId = config.id;
            item.innerHTML = `
        <div class="config-main">
            <input type="radio" name="active_api_config" ${
              config.id === activeId ? "checked" : ""
            }>
            <div class="config-details">
                <span class="config-name">${config.name}</span>
                <span class="config-url">${config.url || "URL未设置"}</span>
            </div>
        </div>
        <div class="config-actions">
            <button type="button" class="edit-btn">编辑</button>
            <button type="button" class="delete-btn">删除</button>
        </div>
      `;
            listEl.appendChild(item);
          });
        }
        // ▼▼▼ [新版本] 请使用此函数进行替换 ▼▼▼
        async function openApiConfigEditor(configId = null) {
          let config = {
            name: "",
            url: "",
            apiKey: "",
            model: "gpt-4o",
            enableStream: true,
            hideStreamResponse: false,
          };
          if (configId) {
            config = state.apiConfigs.find((c) => c.id === configId) || config;
          }

          // 填充基本信息
          document.getElementById("config-editor-id").value = configId || "";
          document.getElementById("config-name-input").value = config.name;
          document.getElementById("config-url-input").value = config.url;
          document.getElementById("config-key-input").value = config.apiKey;

          // --- 【核心修复】 ---
          // 每次打开时，都重置模型下拉列表，只显示当前配置已保存的模型
          const modelSelect = document.getElementById("config-model-select");
          // 1. 清空所有旧的 <option> 元素
          modelSelect.innerHTML = "";
          // 2. 创建一个只包含当前已保存模型的新 <option>
          const savedModelOption = document.createElement("option");
          savedModelOption.value = config.model;
          savedModelOption.textContent = config.model;
          savedModelOption.selected = true;
          // 3. 将这个唯一的选项添加到下拉列表中
          modelSelect.appendChild(savedModelOption);
          // --- 【修复结束】 ---

          // 填充开关状态
          document.getElementById("config-stream-switch").checked =
            config.enableStream;
          document.getElementById("config-hide-stream-switch").checked =
            config.hideStreamResponse;

          // 显示模态框
          document
            .getElementById("api-config-editor-modal")
            .classList.add("visible");
        }
        // ▲▲▲ 替换结束 ▲▲▲

        async function saveApiConfig() {
          const id = document.getElementById("config-editor-id").value;
          const configData = {
            name:
              document.getElementById("config-name-input").value.trim() ||
              "未命名配置",
            url: document.getElementById("config-url-input").value.trim(),
            apiKey: document.getElementById("config-key-input").value.trim(),
            model: document.getElementById("config-model-select").value,
            enableStream: document.getElementById("config-stream-switch")
              .checked,
            hideStreamResponse: document.getElementById(
              "config-hide-stream-switch"
            ).checked,
          };

          if (id) {
            // 更新
            configData.id = parseInt(id);
            await db.apiConfigs.put(configData);
            const index = state.apiConfigs.findIndex(
              (c) => c.id === configData.id
            );
            if (index > -1) state.apiConfigs[index] = configData;
          } else {
            // 新增
            const newId = await db.apiConfigs.add(configData);
            configData.id = newId;
            state.apiConfigs.push(configData);
            // 如果是第一个配置，自动设为激活
            if (state.apiConfigs.length === 1) {
              state.globalSettings.activeApiConfigId = newId;
              await db.globalSettings.put(state.globalSettings);
            }
          }

          renderApiSettings();
          document
            .getElementById("api-config-editor-modal")
            .classList.remove("visible");
        }

        async function setActiveApiConfig(configId) {
          state.globalSettings.activeApiConfigId = configId;
          await db.globalSettings.put(state.globalSettings);
          // 可以在这里给一个轻量提示，或者什么都不做
          console.log(`Active API config set to ID: ${configId}`);
        }
        window.renderApiSettingsProxy = renderApiSettings;

        // ▼▼▼ 请用这个【全新版本】的函数，完整替换掉你旧的 renderChatList ▼▼▼
        async function renderChatList() {
          const chatListEl = document.getElementById("chat-list");
          chatListEl.innerHTML = "";

          // 1. 像以前一样，获取所有聊天并按最新消息时间排序
          const allChats = Object.values(state.chats).sort(
            (a, b) =>
              (b.history.slice(-1)[0]?.timestamp || 0) -
              (a.history.slice(-1)[0]?.timestamp || 0)
          );

          // 2. 获取所有分组
          const allGroups = await db.qzoneGroups.toArray();

          if (allChats.length === 0) {
            chatListEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
            return;
          }

          // --- 【核心修正开始】---

          // 3. 为每个分组找到其内部最新的消息时间戳
          allGroups.forEach((group) => {
            // 从已排序的 allChats 中找到本组的第一个（也就是最新的）聊天
            const latestChatInGroup = allChats.find(
              (chat) => chat.groupId === group.id
            );
            // 如果找到了，就用它的时间戳；如果该分组暂时没有聊天或聊天没有历史记录，就用0
            group.latestTimestamp = latestChatInGroup
              ? latestChatInGroup.history.slice(-1)[0]?.timestamp || 0
              : 0;
          });

          // 4. 根据这个最新的时间戳来对“分组本身”进行排序
          allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

          // --- 【核心修正结束】---

          // 5. 现在，我们按照排好序的分组来渲染
          allGroups.forEach((group) => {
            // 从总列表里过滤出属于这个（已排序）分组的好友
            const groupChats = allChats.filter(
              (chat) => !chat.isGroup && chat.groupId === group.id
            );
            // 如果这个分组是空的（可能所有好友都被删了），就跳过
            if (groupChats.length === 0) return;

            const groupContainer = document.createElement("div");
            groupContainer.className = "chat-group-container";
            groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">▼</span>
                <span class="group-name">${group.name}</span>
            </div>
            <div class="chat-group-content"></div>
        `;
            const contentEl = groupContainer.querySelector(
              ".chat-group-content"
            );
            // 因为 allChats 本身就是有序的，所以 groupChats 自然也是有序的
            groupChats.forEach((chat) => {
              const item = createChatListItem(chat);
              contentEl.appendChild(item);
            });
            chatListEl.appendChild(groupContainer);
          });

          // 6. 最后，渲染所有群聊和未分组的好友
          // 他们的顺序因为 allChats 的初始排序，天然就是正确的
          const ungroupedOrGroupChats = allChats.filter(
            (chat) => chat.isGroup || (!chat.isGroup && !chat.groupId)
          );
          ungroupedOrGroupChats.forEach((chat) => {
            const item = createChatListItem(chat);
            chatListEl.appendChild(item);
          });

          // 为所有分组标题添加折叠事件
          document.querySelectorAll(".chat-group-header").forEach((header) => {
            header.addEventListener("click", () => {
              header.classList.toggle("collapsed");
              header.nextElementSibling.classList.toggle("collapsed");
            });
          });
        }
        // ▲▲▲ 替换结束 ▲▲▲

        function createChatListItem(chat) {
          const lastMsgObj =
            chat.history.filter((msg) => !msg.isHidden).slice(-1)[0] || {};
          let lastMsgDisplay;

          // --- ▼▼▼ 【核心修改】在这里加入对关系状态的判断 ▼▼▼ ---
          if (
            !chat.isGroup &&
            chat.relationship?.status === "pending_user_approval"
          ) {
            lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${
              chat.relationship.applicationReason || "请求添加你为好友"
            }</span>`;
          }
          // --- ▲▲▲ 修改结束 ▲▲▲ ---

          // ▼▼▼ 在这里新增 else if ▼▼▼
          else if (
            !chat.isGroup &&
            chat.relationship?.status === "blocked_by_ai"
          ) {
            lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
          }
          // ▲▲▲ 新增结束 ▲▲▲

          // 【核心修改】优先显示状态，而不是最后一条消息
          if (chat.isGroup) {
            // 群聊逻辑保持不变
            if (lastMsgObj.type === "pat_message") {
              lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`;
            }
            // ... (其他群聊消息类型判断) ...
            else if (lastMsgObj.type === "transfer") {
              lastMsgDisplay = "[转账]";
            } else if (
              lastMsgObj.type === "ai_image" ||
              lastMsgObj.type === "user_photo"
            ) {
              lastMsgDisplay = "[照片]";
            } else if (lastMsgObj.type === "voice_message") {
              lastMsgDisplay = "[语音]";
            } else if (
              typeof lastMsgObj.content === "string" &&
              STICKER_REGEX.test(lastMsgObj.content)
            ) {
              lastMsgDisplay = lastMsgObj.meaning
                ? `[表情: ${lastMsgObj.meaning}]`
                : "[表情]";
            } else if (Array.isArray(lastMsgObj.content)) {
              lastMsgDisplay = `[图片]`;
            } else {
              lastMsgDisplay = String(lastMsgObj.content || "...").substring(
                0,
                20
              );
            }

            if (lastMsgObj.senderName && lastMsgObj.type !== "pat_message") {
              lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
            }
          } else {
            // 单聊逻辑：显示状态
            // 确保 chat.status 对象存在
            const statusText = chat.status?.text || "在线";
            lastMsgDisplay = `[${statusText}]`;
          }

          const item = document.createElement("div");
          item.className = "chat-list-item";
          item.dataset.chatId = chat.id;
          const avatar = chat.isGroup
            ? chat.settings.groupAvatar
            : chat.settings.aiAvatar;

          item.innerHTML = `
        <img src="${avatar || defaultAvatar}" class="avatar">
        <div class="info">
            <div class="name-line">
                <span class="name">${chat.name}</span>
                ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ""}
            </div>
            <div class="last-msg" style="color: ${
              chat.isGroup ? "var(--text-secondary)" : "#b5b5b5"
            }; font-style: italic;">${lastMsgDisplay}</div>
        </div>
        <!-- 这里就是我们新加的红点HTML结构 -->
        <div class="unread-count-wrapper">
            <span class="unread-count" style="display: none;">0</span>
        </div>
    `;

          // 【核心修改2】在这里添加控制红点显示/隐藏的逻辑
          const unreadCount = chat.unreadCount || 0;
          const unreadEl = item.querySelector(".unread-count");
          if (unreadCount > 0) {
            unreadEl.textContent = unreadCount > 99 ? "99+" : unreadCount;
            // 注意这里是 'inline-flex'，与我们的CSS对应，使其垂直居中
            unreadEl.style.display = "inline-flex";
          } else {
            unreadEl.style.display = "none";
          }

          const avatarEl = item.querySelector(".avatar");
          if (avatarEl) {
            avatarEl.style.cursor = "pointer";
            avatarEl.addEventListener("click", (e) => {
              e.stopPropagation();
              handleUserPat(chat.id, chat.name);
            });
          }

          const infoEl = item.querySelector(".info");
          if (infoEl) {
            infoEl.addEventListener("click", () => openChat(chat.id));
          }

          addLongPressListener(item, async (e) => {
            const confirmed = await showCustomConfirm(
              "删除对话",
              `确定要删除与 "${chat.name}" 的整个对话吗？此操作不可撤销。`,
              { confirmButtonClass: "btn-danger" }
            );
            if (confirmed) {
              if (musicState.isActive && musicState.activeChatId === chat.id)
                await endListenTogetherSession(false);
              delete state.chats[chat.id];
              if (state.activeChatId === chat.id) state.activeChatId = null;
              await db.chats.delete(chat.id);
              renderChatList();
            }
          });
          return item;
        }

        // ▼▼▼ 请用这个【带诊断功能的全新版本】替换旧的 renderChatInterface 函数 ▼▼▼
        function renderChatInterface(chatId) {
          cleanupWaimaiTimers();
          const chat = state.chats[chatId];
          if (!chat) return;
          exitSelectionMode();

          const messagesContainer = document.getElementById("chat-messages");
          const chatInputArea = document.getElementById("chat-input-area");
          const lockOverlay = document.getElementById("chat-lock-overlay");
          const lockContent = document.getElementById("chat-lock-content");

          messagesContainer.dataset.theme = chat.settings.theme || "default";
          const fontSize = chat.settings.fontSize || 13;
          messagesContainer.style.setProperty(
            "--chat-font-size",
            `${fontSize}px`
          );
          applyScopedCss(
            chat.settings.customCss || "",
            "#chat-messages",
            "custom-bubble-style"
          );

          document.getElementById("chat-header-title").textContent = chat.name;
          const statusContainer = document.getElementById("chat-header-status");
          const statusTextEl = statusContainer.querySelector(".status-text");

          if (chat.isGroup) {
            statusContainer.style.display = "none";
            document.getElementById(
              "chat-header-title-wrapper"
            ).style.justifyContent = "center";
          } else {
            statusContainer.style.display = "flex";
            document.getElementById(
              "chat-header-title-wrapper"
            ).style.justifyContent = "flex-start";
            statusTextEl.textContent = chat.status?.text || "在线";
            statusContainer.classList.toggle(
              "busy",
              chat.status?.isBusy || false
            );
          }

          lockOverlay.style.display = "none";
          chatInputArea.style.visibility = "visible";
          lockContent.innerHTML = "";

          if (!chat.isGroup && chat.relationship.status !== "friend") {
            lockOverlay.style.display = "flex";
            chatInputArea.style.visibility = "hidden";

            let lockHtml = "";
            switch (chat.relationship.status) {
              case "blocked_by_user":
                // --- 【核心修改：在这里加入诊断面板】 ---
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours =
                  state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(
                  0,
                  Math.ceil(
                    (cooldownMilliseconds - timeSinceBlock) / (1000 * 60)
                  )
                );

                lockHtml = `
                    <span class="lock-text">你已将“${chat.name}”拉黑。</span>
                    <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">【开发者诊断面板】</strong><br>
                        - 后台活动总开关: ${
                          state.globalSettings.enableBackgroundActivity
                            ? '<span style="color: green;">已开启</span>'
                            : '<span style="color: red;">已关闭</span>'
                        }<br>
                        - 系统心跳计时器: ${
                          isSimulationRunning
                            ? '<span style="color: green;">运行中</span>'
                            : '<span style="color: red;">未运行</span>'
                        }<br>
                        - 当前角色状态: <strong>${
                          chat.relationship.status
                        }</strong><br>
                        - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                        - 冷静期是否结束: ${
                          isCooldownOver
                            ? '<span style="color: green;">是</span>'
                            : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`
                        }<br>
                        - 触发条件: ${
                          isCooldownOver &&
                          state.globalSettings.enableBackgroundActivity
                            ? '<span style="color: green;">已满足，等待下次系统心跳</span>'
                            : '<span style="color: red;">未满足</span>'
                        }
                    </div>
                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">强制触发一次好友申请检测</button>
                `;
                // --- 【修改结束】 ---
                break;
              case "blocked_by_ai":
                lockHtml = `
                    <span class="lock-text">你被对方拉黑了。</span>
                    <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                `;
                break;

              case "pending_user_approval":
                lockHtml = `
                    <span class="lock-text">“${chat.name}”请求添加你为好友：<br><i>“${chat.relationship.applicationReason}”</i></span>
                    <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                    <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
                `;
                break;

              // 【核心修正】修复当你申请后，你看到的界面
              case "pending_ai_approval":
                lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
                break;
            }
            lockContent.innerHTML = lockHtml;
          }
          messagesContainer.innerHTML = "";
          // ...后续代码保持不变
          const chatScreen = document.getElementById("chat-interface-screen");
          chatScreen.style.backgroundImage = chat.settings.background
            ? `url(${chat.settings.background})`
            : "none";

          const isDarkMode = document
            .getElementById("phone-screen")
            .classList.contains("dark-mode");
          chatScreen.style.backgroundColor = chat.settings.background
            ? "transparent"
            : isDarkMode
            ? "#000000"
            : "#f0f2f5";
          const history = chat.history;
          const totalMessages = history.length;
          currentRenderedCount = 0;
          const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
          initialMessages.forEach((msg) => appendMessage(msg, chat, true));
          currentRenderedCount = initialMessages.length;
          if (totalMessages > currentRenderedCount) {
            prependLoadMoreButton(messagesContainer);
          }
          const typingIndicator = document.createElement("div");
          typingIndicator.id = "typing-indicator";
          typingIndicator.style.display = "none";
          typingIndicator.innerHTML = '<div class="system-bubble">对方正在输入...</div>';
          messagesContainer.appendChild(typingIndicator);
          setTimeout(
            () =>
              (messagesContainer.scrollTop = messagesContainer.scrollHeight),
            0
          );
        }
        // ▲▲▲ 替换结束 ▲▲▲

        function prependLoadMoreButton(container) {
          const button = document.createElement("button");
          button.id = "load-more-btn";
          button.textContent = "加载更早的记录";
          button.addEventListener("click", loadMoreMessages);
          container.prepend(button);
        }

        function loadMoreMessages() {
          const messagesContainer = document.getElementById("chat-messages");
          const chat = state.chats[state.activeChatId];
          if (!chat) return;
          const loadMoreBtn = document.getElementById("load-more-btn");
          if (loadMoreBtn) loadMoreBtn.remove();
          const totalMessages = chat.history.length;
          const nextSliceStart =
            totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW;
          const nextSliceEnd = totalMessages - currentRenderedCount;
          const messagesToPrepend = chat.history.slice(
            Math.max(0, nextSliceStart),
            nextSliceEnd
          );
          const oldScrollHeight = messagesContainer.scrollHeight;
          messagesToPrepend
            .reverse()
            .forEach((msg) => prependMessage(msg, chat));
          currentRenderedCount += messagesToPrepend.length;
          const newScrollHeight = messagesContainer.scrollHeight;
          messagesContainer.scrollTop += newScrollHeight - oldScrollHeight;
          if (totalMessages > currentRenderedCount) {
            prependLoadMoreButton(messagesContainer);
          }
        }

        // ▼▼▼ 用这个【新版本】替换旧的 renderWallpaperScreen 函数 ▼▼▼
        function renderWallpaperScreen() {
          const preview = document.getElementById("wallpaper-preview");
          const bg = newWallpaperBase64 || state.globalSettings.wallpaper;
          if (bg && bg.startsWith("data:image")) {
            preview.style.backgroundImage = `url(${bg})`;
            preview.textContent = "";
          } else if (bg) {
            preview.style.backgroundImage = bg;
            preview.textContent = "当前为渐变色";
          }
          // 【核心修改】在这里调用图标渲染函数
          renderIconSettings();

          // ▼▼▼ 新增：回显边框颜色设置 ▼▼▼
          const frameColorInput = document.getElementById("frame-color-input");
          const frameColorValue = document.getElementById("frame-color-value");
          const currentFrameColor = state.globalSettings.phoneFrameColor || "#ffffff";
          frameColorInput.value = currentFrameColor;
          frameColorValue.textContent = currentFrameColor;
          // ▲▲▲ 新增结束 ▲▲▲
        }
        // ▲▲▲ 替换结束 ▲▲▲
        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() {
          const homeScreen = document.getElementById("home-screen");
          const wallpaper = state.globalSettings.wallpaper;
          if (wallpaper && wallpaper.startsWith("data:image"))
            homeScreen.style.backgroundImage = `url(${wallpaper})`;
          else if (wallpaper) homeScreen.style.backgroundImage = wallpaper;

          // ▼▼▼ 新增：应用手机边框颜色 ▼▼▼
          const phoneFrame = document.getElementById("phone-frame");
          const customColor = state.globalSettings.phoneFrameColor;
          
          if (customColor) {
            phoneFrame.style.backgroundColor = customColor;
          } else {
            // 如果没有自定义颜色，则清除内联样式，让CSS类（如.dark-mode）生效
            phoneFrame.style.backgroundColor = "";
          }
          // ▲▲▲ 新增结束 ▲▲▲
        }

        async function renderWorldBookScreen() {
          const listEl = document.getElementById("world-book-list");
          listEl.innerHTML = "";

          // 1. 同时获取所有书籍和所有分类
          const [books, categories] = await Promise.all([
            db.worldBooks.toArray(),
            db.worldBookCategories.orderBy("name").toArray(),
          ]);

          state.worldBooks = books; // 确保内存中的数据是同步的

          if (books.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 创建你的第一本世界书</p>';
            return;
          }

          // 2. 将书籍按 categoryId 分组
          const groupedBooks = books.reduce((acc, book) => {
            const key = book.categoryId || "uncategorized";
            if (!acc[key]) {
              acc[key] = [];
            }
            acc[key].push(book);
            return acc;
          }, {});

          // 3. 优先渲染已分类的书籍
          categories.forEach((category) => {
            const booksInCategory = groupedBooks[category.id];
            if (booksInCategory && booksInCategory.length > 0) {
              const groupContainer = createWorldBookGroup(
                category.name,
                booksInCategory
              );
              listEl.appendChild(groupContainer);
            }
          });

          // 4. 最后渲染未分类的书籍
          const uncategorizedBooks = groupedBooks["uncategorized"];
          if (uncategorizedBooks && uncategorizedBooks.length > 0) {
            const groupContainer = createWorldBookGroup(
              "未分类",
              uncategorizedBooks
            );
            listEl.appendChild(groupContainer);
          }

          // 5. 为所有分组标题添加折叠事件
          document
            .querySelectorAll(".world-book-group-header")
            .forEach((header) => {
              header.addEventListener("click", () => {
                header.classList.toggle("collapsed");
                header.nextElementSibling.classList.toggle("collapsed");
              });
            });
        }

        /**
         * 【辅助函数】创建一个分类的分组DOM
         * @param {string} groupName - 分类名称
         * @param {Array} books - 该分类下的书籍数组
         * @returns {HTMLElement} - 创建好的分组容器
         */
        function createWorldBookGroup(groupName, books) {
          const groupContainer = document.createElement("div");
          groupContainer.className = "world-book-group-container";

          groupContainer.innerHTML = `
        <div class="world-book-group-header">
            <span class="arrow">▼</span>
            <span class="group-name">${groupName}</span>
        </div>
        <div class="world-book-group-content"></div>
    `;

          // ▼▼▼ 在这里添加新代码 ▼▼▼
          const headerEl = groupContainer.querySelector(
            ".world-book-group-header"
          );
          const contentEl = groupContainer.querySelector(
            ".world-book-group-content"
          );

          // 默认给头部和内容区都加上 collapsed 类
          headerEl.classList.add("collapsed");
          contentEl.classList.add("collapsed");
          // ▲▲▲ 添加结束 ▲▲▲

          books.sort((a, b) => a.name.localeCompare(b.name, "zh-CN"));
          books.forEach((book) => {
            const item = document.createElement("div");
            item.className = "list-item";
            item.dataset.bookId = book.id;
            item.innerHTML = `<div class="item-title">${
              book.name
            }</div><div class="item-content">${(
              book.content || "暂无内容..."
            ).substring(0, 50)}</div>`;
            item.addEventListener("click", () => openWorldBookEditor(book.id));
            addLongPressListener(item, async () => {
              const confirmed = await showCustomConfirm(
                "删除世界书",
                `确定要删除《${book.name}》吗？此操作不可撤销。`,
                { confirmButtonClass: "btn-danger" }
              );
              if (confirmed) {
                await db.worldBooks.delete(book.id);
                state.worldBooks = state.worldBooks.filter(
                  (wb) => wb.id !== book.id
                );
                renderWorldBookScreen();
              }
            });
            contentEl.appendChild(item);
          });

          return groupContainer;
        }
        window.renderWorldBookScreenProxy = renderWorldBookScreen;

        async function openWorldBookEditor(bookId) {
          editingWorldBookId = bookId;
          const [book, categories] = await Promise.all([
            db.worldBooks.get(bookId),
            db.worldBookCategories.toArray(),
          ]);
          if (!book) return;

          document.getElementById("world-book-editor-title").textContent =
            book.name;
          document.getElementById("world-book-name-input").value = book.name;
          document.getElementById("world-book-content-input").value =
            book.content;

          // 【核心修改】填充分类下拉菜单
          const selectEl = document.getElementById(
            "world-book-category-select"
          );
          selectEl.innerHTML = '<option value="">-- 未分类 --</option>'; // 默认选项
          categories.forEach((cat) => {
            const option = document.createElement("option");
            option.value = cat.id;
            option.textContent = cat.name;
            if (book.categoryId === cat.id) {
              option.selected = true; // 选中当前分类
            }
            selectEl.appendChild(option);
          });

          showScreen("world-book-editor-screen");
        }

        function renderStickerPanel() {
          const grid = document.getElementById("sticker-grid");
          grid.innerHTML = "";
          if (state.userStickers.length === 0) {
            grid.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">大人请点击右上角“添加”或“上传”来添加你的第一个表情吧！</p>';
            return;
          }
          state.userStickers.forEach((sticker) => {
            const item = document.createElement("div");
            item.className = "sticker-item";
            item.style.backgroundImage = `url(${sticker.url})`;
            item.title = sticker.name;
            item.addEventListener("click", () => sendSticker(sticker));
            addLongPressListener(item, () => {
              if (isSelectionMode) return;
              const existingDeleteBtn = item.querySelector(".delete-btn");
              if (existingDeleteBtn) return;
              const deleteBtn = document.createElement("div");
              deleteBtn.className = "delete-btn";
              deleteBtn.innerHTML = "&times;";
              deleteBtn.onclick = async (e) => {
                e.stopPropagation();
                const confirmed = await showCustomConfirm(
                  "删除表情",
                  `确定要删除表情 "${sticker.name}" 吗？`,
                  { confirmButtonClass: "btn-danger" }
                );
                if (confirmed) {
                  await db.userStickers.delete(sticker.id);
                  state.userStickers = state.userStickers.filter(
                    (s) => s.id !== sticker.id
                  );
                  renderStickerPanel();
                }
              };
              item.appendChild(deleteBtn);
              deleteBtn.style.display = "block";
              setTimeout(
                () =>
                  item.addEventListener(
                    "mouseleave",
                    () => deleteBtn.remove(),
                    { once: true }
                  ),
                3000
              );
            });
            grid.appendChild(item);
          });
        }

        // ▼▼▼ 用这个【已更新】的版本替换旧的 createMessageElement 函数 ▼▼▼
        function createMessageElement(msg, chat) {
          // ▼▼▼ 在函数最开头，添加这段新代码 ▼▼▼
          if (msg.type === "recalled_message") {
            const wrapper = document.createElement("div");
            // 1. 【核心】给 wrapper 也加上 timestamp，方便事件委托时查找
            wrapper.className = "message-wrapper system-pat";
            wrapper.dataset.timestamp = msg.timestamp;

            const bubble = document.createElement("div");
            // 2. 【核心】让这个元素同时拥有 .message-bubble 和 .recalled-message-placeholder 两个class
            //    这样它既能被选择系统识别，又能保持原有的居中灰色样式
            bubble.className = "message-bubble recalled-message-placeholder";
            // 3. 【核心】把 timestamp 放在 bubble 上，这是多选逻辑的关键
            bubble.dataset.timestamp = msg.timestamp;
            bubble.textContent = msg.content;

            wrapper.appendChild(bubble);

            // 4. 【核心】为它补上和其他消息一样的标准事件监听器
            addLongPressListener(wrapper, () =>
              showMessageActions(msg.timestamp)
            );
            wrapper.addEventListener("click", () => {
              if (isSelectionMode) {
                toggleMessageSelection(msg.timestamp);
              }
            });

            // 5. 【重要】在之前的“点击查看原文”的逻辑中，我们已经使用了事件委托，所以这里不需要再单独为这个元素添加点击事件了。
            //    init() 函数中的那个事件监听器会处理它。

            return wrapper;
          }
          // ▲▲▲ 添加结束 ▲▲▲

          if (msg.isHidden) {
            return null;
          }

          if (msg.type === "pat_message") {
            const wrapper = document.createElement("div");
            wrapper.className = "message-wrapper system-pat";
            const bubble = document.createElement("div");
            bubble.className = "message-bubble system-bubble";
            bubble.dataset.timestamp = msg.timestamp;
            bubble.textContent = msg.content;
            wrapper.appendChild(bubble);
            addLongPressListener(wrapper, () =>
              showMessageActions(msg.timestamp)
            );
            wrapper.addEventListener("click", () => {
              if (isSelectionMode) toggleMessageSelection(msg.timestamp);
            });
            return wrapper;
          }

          const isUser = msg.role === "user";
          const wrapper = document.createElement("div");
          wrapper.className = `message-wrapper ${isUser ? "user" : "ai"}`;

          // ★★★【核心重构】★★★
          // 这段逻辑现在用于查找成员对象，并显示其“群昵称”
          if (chat.isGroup && !isUser) {
            // 1. 使用AI返回的“本名”(`msg.senderName`)去列表里查找成员对象
            const member = chat.members.find(
              (m) => m.originalName === msg.senderName
            );

            // 2. 创建用于显示名字的 div
            const senderNameDiv = document.createElement("div");
            senderNameDiv.className = "sender-name";

            // 3. 如果找到了成员，就显示他的“群昵称”；如果找不到，就显示AI返回的“本名”作为备用
            senderNameDiv.textContent = member
              ? member.groupNickname
              : msg.senderName || "未知成员";

            wrapper.appendChild(senderNameDiv);
          }

          const bubble = document.createElement("div");
          bubble.className = `message-bubble ${isUser ? "user" : "ai"}`;
          bubble.dataset.timestamp = msg.timestamp;

          const timestampEl = document.createElement("span");
          timestampEl.className = "timestamp";
          timestampEl.textContent = formatTimestamp(msg.timestamp);

          // ▼▼▼【粘贴这段新代码】▼▼▼
          let avatarSrc; // 我们现在只需要头像图片，不再需要头像框了
          if (chat.isGroup) {
            if (isUser) {
              avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
            } else {
              const member = chat.members.find(
                (m) => m.originalName === msg.senderName
              );
              avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
            }
          } else {
            if (isUser) {
              avatarSrc = chat.settings.myAvatar || defaultAvatar;
            } else {
              avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            }
          }
          // 直接生成最简单的头像HTML，不再有任何和头像框相关的逻辑
          const avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
          // ▲▲▲【粘贴结束】▲▲▲

          let contentHtml;

          if (msg.type === "share_link") {
            bubble.classList.add("is-link-share");

            // 【核心修正1】将 onclick="openBrowser(...)" 移除，我们将在JS中动态绑定事件
            contentHtml = `
            <div class="link-share-card" data-timestamp="${msg.timestamp}">
                <div class="title">${msg.title || "无标题"}</div>
                <div class="description">${
                  msg.description || "点击查看详情..."
                }</div>
                <div class="footer">
                    <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                    <span>${msg.source_name || "链接分享"}</span>
                </div>
            </div>
        `;
          } else if (msg.type === "share_card") {
            bubble.classList.add("is-link-share"); // 复用链接分享的卡片样式
            // 【核心】把时间戳加到卡片上，方便后面点击时识别
            contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}">
            <div class="title">${msg.payload.title}</div>
            <div class="description">共 ${msg.payload.sharedHistory.length} 条消息</div>
            <div class="footer">
                <svg class="footer-icon" ...>...</svg> <!-- 复用链接分享的图标 -->
                <span>聊天记录</span>
            </div>
        </div>
    `;
          }

          // 后续的其他 else if 保持不变
          else if (msg.type === "user_photo" || msg.type === "ai_image") {
            bubble.classList.add("is-ai-image");
            const altText =
              msg.type === "user_photo" ? "用户描述的照片" : "AI生成的图片";
            contentHtml = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
          } else if (msg.type === "voice_message") {
            bubble.classList.add("is-voice-message");

            // 【核心修正1】将语音原文存储在父级气泡的 data-* 属性中，方便事件处理器获取
            bubble.dataset.voiceText = msg.content;

            const duration = Math.max(
              1,
              Math.round((msg.content || "").length / 5)
            );
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            const durationFormatted = `${minutes}:${String(seconds).padStart(
              2,
              "0"
            )}''`;

            // 使用 test.html 中的 SVG 图标
            const waveIconSVG = `
            <div class="wave-icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path class="wave-path-1" d="M6 3.5C2.5 7 2.5 17 6 20.5" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path class="wave-path-2" d="M11 7C8.5 9.5 8.5 14.5 11 17" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path class="wave-path-3" d="M16 15 Q13.5 12 16 9 L19.5 12 Z" fill="currentColor"/>
                </svg>
            </div>`;

            // 【核心修正2】构建包含所有新元素的完整 HTML
            // 注意：voice-message-body 现在对应 test.html 的 voice-bubble
            contentHtml = `
        <div class="voice-message-body">
            <span class="voice-duration">${durationFormatted}</span>
            ${waveIconSVG}
        </div>
        <div class="voice-transcript" style="display:none;"></div>
    `;
          } else if (msg.type === "transfer") {
            bubble.classList.add("is-transfer");

            let titleText, noteText;
            const myNickname = chat.isGroup
              ? chat.settings.myNickname || "我"
              : "我";

            if (isUser) {
              // 消息是用户发出的
              if (msg.isRefund) {
                // 用户发出的退款（即用户拒收了AI的转账）
                titleText = `退款给 ${chat.name}`;
                noteText = "已拒收对方转账";
              } else {
                // 用户主动发起的转账
                titleText = `转账给 ${msg.receiverName || chat.name}`;
                if (msg.status === "accepted") {
                  noteText = "对方已收款";
                } else if (msg.status === "declined") {
                  noteText = "对方已拒收";
                } else {
                  noteText = msg.note || "等待对方处理...";
                }
              }
            } else {
              // 消息是 AI 发出的
              if (msg.isRefund) {
                // AI 的退款（AI 拒收了用户的转账）
                titleText = `退款来自 ${msg.senderName}`;
                noteText = "转账已被拒收";
              } else if (msg.receiverName === myNickname) {
                // 【核心修正1】这是 AI 主动给用户的转账
                titleText = `转账给 ${myNickname}`;
                if (msg.status === "accepted") {
                  noteText = "你已收款";
                } else if (msg.status === "declined") {
                  noteText = "你已拒收";
                } else {
                  // 这是用户需要处理的转账
                  bubble.style.cursor = "pointer";
                  bubble.dataset.status = "pending";
                  noteText = msg.note || "点击处理";
                }
              } else {
                // 【核心修正2】这是 AI 发给群里其他人的转账，对当前用户来说只是一个通知
                titleText = `转账: ${msg.senderName} → ${msg.receiverName}`;
                noteText = msg.note || "群聊内转账";
              }
            }

            const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;

            contentHtml = `
        <div class="transfer-card">
            <div class="transfer-title">${heartIcon} ${titleText}</div>
            <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(
              2
            )}</div>
            <div class.transfer-note">${noteText}</div>
        </div>
    `;
          } else if (msg.type === "waimai_request") {
            bubble.classList.add("is-waimai-request");
            if (msg.status === "paid" || msg.status === "rejected") {
              bubble.classList.add(`status-${msg.status}`);
            }
            let displayName;
            // 如果是群聊
            if (chat.isGroup) {
              // 就执行原来的逻辑：在成员列表里查找昵称
              const member = chat.members.find(
                (m) => m.originalName === msg.senderName
              );
              displayName = member ? member.groupNickname : msg.senderName;
            } else {
              // 否则（是单聊），直接使用聊天对象的名称
              displayName = chat.name;
            }
            // 【核心修改】使用我们刚刚查找到的 displayName
            const requestTitle = `来自 ${displayName} 的代付请求`;
            let actionButtonsHtml = "";
            if (msg.status === "pending" && !isUser) {
              actionButtonsHtml = `
                <div class="waimai-user-actions">
                    <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                    <button class="waimai-pay-btn" data-choice="paid">为Ta买单</button>
                </div>`;
            }
            contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                    <div class="title-group">
                        <span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span>
                    </div>
                </div>
                <div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div>
                <div class="waimai-main">
                    <div class="request-title">${requestTitle}</div>
                    <div class="payment-box">
                        <div class="payment-label">需付款</div>
                        <div class="amount">¥${Number(msg.amount).toFixed(
                          2
                        )}</div>
                        <div class="countdown-label">剩余支付时间
                            <div class="countdown-timer" id="waimai-timer-${
                              msg.timestamp
                            }"></div>
                        </div>
                    </div>
                    <button class="waimai-details-btn">查看详情</button>
                </div>
                ${actionButtonsHtml}
            </div>`;

            setTimeout(() => {
              const timerEl = document.getElementById(
                `waimai-timer-${msg.timestamp}`
              );
              if (timerEl && msg.countdownEndTime) {
                if (waimaiTimers[msg.timestamp])
                  clearInterval(waimaiTimers[msg.timestamp]);
                if (msg.status === "pending") {
                  waimaiTimers[msg.timestamp] = startWaimaiCountdown(
                    timerEl,
                    msg.countdownEndTime
                  );
                } else {
                  timerEl.innerHTML = `<span>已</span><span>处</span><span>理</span>`;
                }
              }
              const detailsBtn = document.querySelector(
                `.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`
              );
              if (detailsBtn) {
                detailsBtn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  const paidByText = msg.paidBy
                    ? `<br><br><b>状态：</b>由 ${msg.paidBy} 为您代付成功`
                    : "";
                  showCustomAlert(
                    "订单详情",
                    `<b>商品：</b>${msg.productInfo}<br><b>金额：</b>¥${Number(
                      msg.amount
                    ).toFixed(2)}${paidByText}`
                  );
                });
              }
              const actionButtons = document.querySelectorAll(
                `.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`
              );
              actionButtons.forEach((btn) => {
                btn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  const choice = e.target.dataset.choice;
                  handleWaimaiResponse(msg.timestamp, choice);
                });
              });
            }, 0);
          } else if (msg.type === "red_packet") {
            bubble.classList.add("is-red-packet");
            const myNickname = chat.settings.myNickname || "我";

            // 从最新的 msg 对象中获取状态
            const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
            const isFinished = msg.isFullyClaimed;

            let cardClass = "";
            let claimedInfoHtml = "";
            let typeText = "拼手气红包";

            // 1. 判断红包卡片的样式 (颜色)
            if (isFinished) {
              cardClass = "opened";
            } else if (
              msg.packetType === "direct" &&
              Object.keys(msg.claimedBy || {}).length > 0
            ) {
              cardClass = "opened"; // 专属红包被领了也变灰
            }

            // 2. 判断红包下方的提示文字
            if (msg.packetType === "direct") {
              typeText = `专属红包: 给 ${msg.receiverName}`;
            }

            if (hasClaimed) {
              claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${msg.claimedBy[
                myNickname
              ].toFixed(2)} 元</div>`;
            } else if (isFinished) {
              claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`;
            } else if (
              msg.packetType === "direct" &&
              Object.keys(msg.claimedBy || {}).length > 0
            ) {
              claimedInfoHtml = `<div class="rp-claimed-info">已被 ${msg.receiverName} 领取</div>`;
            }

            // 3. 拼接最终的HTML，确保onclick调用的是我们注册到全局的函数
            contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${
                  msg.greeting || "恭喜发财，大吉大利！"
                }</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
            // ▲▲▲ 新增结束 ▲▲▲
          } else if (msg.type === "poll") {
            bubble.classList.add("is-poll");

            let totalVotes = 0;
            const voteCounts = {};

            // 计算总票数和每个选项的票数
            for (const option in msg.votes) {
              const count = msg.votes[option].length;
              voteCounts[option] = count;
              totalVotes += count;
            }

            const myNickname = chat.isGroup
              ? chat.settings.myNickname || "我"
              : "我";
            let myVote = null;
            for (const option in msg.votes) {
              if (msg.votes[option].includes(myNickname)) {
                myVote = option;
                break;
              }
            }

            let optionsHtml = '<div class="poll-options-list">';
            msg.options.forEach((optionText) => {
              const count = voteCounts[optionText] || 0;
              const percentage =
                totalVotes > 0 ? (count / totalVotes) * 100 : 0;
              const isVotedByMe = myVote === optionText;

              optionsHtml += `
            <div class="poll-option-item ${
              isVotedByMe ? "voted" : ""
            }" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} 票</span>
                </div>
            </div>
        `;
            });
            optionsHtml += "</div>";

            let footerHtml = "";
            // 【核心修改】在这里统一按钮的显示逻辑
            if (msg.isClosed) {
              // 如果投票已结束，总是显示“查看结果”
              footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>`;
            } else {
              // 如果投票未结束，总是显示“结束投票”
              footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
            }

            contentHtml = `
        <div class="poll-card ${
          msg.isClosed ? "closed" : ""
        }" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
            // ▲▲▲ 替换结束 ▲▲▲
          } else if (
            typeof msg.content === "string" &&
            STICKER_REGEX.test(msg.content)
          ) {
            bubble.classList.add("is-sticker");
            contentHtml = `<img src="${msg.content}" alt="${
              msg.meaning || "Sticker"
            }" class="sticker-image">`;
          } else if (
            Array.isArray(msg.content) &&
            msg.content[0]?.type === "image_url"
          ) {
            bubble.classList.add("has-image");
            const imageUrl = msg.content[0].image_url.url;
            contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
          } else {
            contentHtml = String(msg.content || "").replace(/\n/g, "<br>");
          }

          // ▼▼▼ 【最终修正版】请用这整块代码，完整替换掉旧的引用渲染逻辑 ▼▼▼

          // 1. 【统一逻辑】检查消息对象中是否存在引用信息 (msg.quote)
          let quoteHtml = "";
          // 无论是用户消息还是AI消息，只要它包含了 .quote 对象，就执行这段逻辑
          if (msg.quote) {
            // a. 【核心修正】直接获取完整的、未经截断的引用内容
            const fullQuotedContent = String(msg.quote.content || "");

            // b. 构建引用块的HTML
            quoteHtml = `
        <div class="quoted-message">
            <div class="quoted-sender">回复 ${msg.quote.senderName}:</div>
            <div class="quoted-content">${fullQuotedContent}</div>
        </div>
    `;
          }

          // 2. 拼接最终的气泡内容
          //    将构建好的 quoteHtml (如果存在) 和 contentHtml 组合起来
          // --- 【最终正确结构】将头像和内容都放回气泡内部 ---
          bubble.innerHTML = `
        ${avatarHtml}
        <div class="content">
            ${quoteHtml}
            ${contentHtml}
        </div>
    `;

          // --- 【最终正确结构】将完整的“气泡”和“时间戳”放入容器 ---
          wrapper.appendChild(bubble);
          wrapper.appendChild(timestampEl);

          addLongPressListener(wrapper, () =>
            showMessageActions(msg.timestamp)
          );
          wrapper.addEventListener("click", () => {
            if (isSelectionMode) toggleMessageSelection(msg.timestamp);
          });

          if (!isUser) {
            const avatarEl = wrapper.querySelector(".avatar"); //  <-- 1. 把查找目标改成 '.avatar'
            if (avatarEl) {
              avatarEl.style.cursor = "pointer";
              avatarEl.addEventListener("click", (e) => {
                //  <-- 2. 确保这里也用新变量
                e.stopPropagation();
                const characterName = chat.isGroup ? msg.senderName : chat.name;
                handleUserPat(chat.id, characterName);
              });
            }
          }

          return wrapper;
        }
        // ▲▲▲ 替换结束 ▲▲▲

        function prependMessage(msg, chat) {
          const messagesContainer = document.getElementById("chat-messages");
          const messageEl = createMessageElement(msg, chat);

          if (!messageEl) return; // <--- 新增这行，同样的处理

          const loadMoreBtn = document.getElementById("load-more-btn");
          if (loadMoreBtn) {
            messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling);
          } else {
            messagesContainer.prepend(messageEl);
          }
        }

        // ▼▼▼ 用这个【带动画的版本】替换你原来的 appendMessage 函数 ▼▼▼
        function appendMessage(msg, chat, isInitialLoad = false) {
          const messagesContainer = document.getElementById("chat-messages");
          const messageEl = createMessageElement(msg, chat);

          if (!messageEl) return; // 如果消息是隐藏的，则不处理

          // 【核心】只对新消息添加动画，不对初始加载的消息添加
          if (!isInitialLoad) {
            messageEl.classList.add("animate-in");
          }

          const typingIndicator = document.getElementById("typing-indicator");
          messagesContainer.insertBefore(messageEl, typingIndicator);

          if (!isInitialLoad) {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            currentRenderedCount++;
          }
        }
        // ▲▲▲ 替换结束 ▲▲▲

        async function openChat(chatId) {
          state.activeChatId = chatId;
          const chat = state.chats[chatId];
          if (!chat) return; // 安全检查

          // 【核心新增】在这里将未读数清零
          if (chat.unreadCount > 0) {
            chat.unreadCount = 0;
            await db.chats.put(chat); // 别忘了把这个改变同步到数据库
            // 我们稍后会在渲染列表时重新渲染，所以这里不需要立即重绘列表
          }

          renderChatInterface(chatId);
          showScreen("chat-interface-screen");
          window.updateListenTogetherIconProxy(state.activeChatId);
          toggleCallButtons(chat.isGroup || false);

          if (
            !chat.isGroup &&
            chat.relationship?.status === "pending_ai_approval"
          ) {
            console.log(
              `检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`
            );
            triggerAiResponse();
          }

          // 【核心修正】根据是否为群聊，显示或隐藏投票按钮
          document.getElementById("send-poll-btn").style.display = chat.isGroup
            ? "flex"
            : "none";
        }
        // ▲▲▲ 替换结束 ▲▲▲

        async function triggerAiResponse() {
          if (!state.activeChatId) return;
          const chatId = state.activeChatId;
          const chat = state.chats[state.activeChatId];

          const chatHeaderTitle = document.getElementById("chat-header-title");

          // ★★★★★【核心修改1：获取群聊的输入提示元素】★★★★★
          const typingIndicator = document.getElementById("typing-indicator");

          // ★★★★★【核心修改2：根据聊天类型，决定显示哪种“正在输入”】★★★★★
          if (chat.isGroup) {
            // 如果是群聊，显示输入框上方的提示条
            if (typingIndicator) {
              const bubble = typingIndicator.querySelector(".system-bubble");
              if (bubble) bubble.textContent = "成员们正在输入...";
              typingIndicator.style.display = "block";
            }
          } else {
            // 如果是单聊，保持原来的标题动画
            if (chatHeaderTitle) {
              chatHeaderTitle.style.opacity = 0;
              setTimeout(() => {
                chatHeaderTitle.textContent = "对方正在输入...";
                chatHeaderTitle.classList.add("typing-status");
                chatHeaderTitle.style.opacity = 1;
              }, 200);
            }
          }

          try {
            const { proxyUrl, apiKey, model } = getActiveApiConfig() || {};
            if (!proxyUrl || !apiKey || !model) {
              alert("请先在API设置中配置反代地址、密钥并选择模型。");
              // ★★★★★【核心修改3：无论成功失败，都要隐藏输入提示】★★★★★
              if (chat.isGroup) {
                if (typingIndicator) typingIndicator.style.display = "none";
              } else {
                if (chatHeaderTitle && state.chats[chatId]) {
                  chatHeaderTitle.textContent = state.chats[chatId].name;
                  chatHeaderTitle.classList.remove("typing-status");
                }
              }
              return;
            }

            // --- 【核心重构 V2：带有上下文和理由的好友申请处理逻辑】---
            if (
              !chat.isGroup &&
              chat.relationship?.status === "pending_ai_approval"
            ) {
              console.log(
                `为角色 "${chat.name}" 触发带理由的好友申请决策流程...`
              );

              // 1. 【注入上下文】抓取被拉黑前的最后5条聊天记录作为参考
              const contextSummary = chat.history
                .filter((m) => !m.isHidden)
                .slice(-10, -5) // 获取拉黑前的最后5条消息
                .map((msg) => {
                  const sender = msg.role === "user" ? "用户" : chat.name;
                  return `${sender}: ${String(msg.content).substring(
                    0,
                    50
                  )}...`;
                })
                .join("\n");

              // 2. 【全新指令】构建一个强制AI给出理由的Prompt
              const decisionPrompt = `
# 你的任务
你现在是角色“${
                chat.name
              }”。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。

# 供你决策的上下文信息:
- **你的角色设定**: ${chat.settings.aiPersona}
- **用户发送的申请理由**: “${chat.relationship.applicationReason}”
- **被拉黑前的最后对话摘要**: 
${contextSummary || "（无有效对话记录）"}

# 你的唯一指令
根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:
{"decision": "accept", "reason": "（在这里写下你同意的理由，比如：好吧，看在你这么真诚的份上，这次就原谅你啦。）"}
或
{"decision": "reject", "reason": "（在这里写下你拒绝的理由，比如：抱歉，我还没准备好，再给我一点时间吧。）"}
`;
              const messagesForDecision = [
                { role: "user", content: decisionPrompt },
              ];

              try {
                // 3. 发送请求
                let isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(
                  model,
                  apiKey,
                  "",
                  messagesForDecision,
                  isGemini
                );
                const response = isGemini
                  ? await fetch(geminiConfig.url, geminiConfig.data)
                  : await fetch(`${proxyUrl}/v1/chat/completions`, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${apiKey}`,
                      },
                      body: JSON.stringify({
                        model: model,
                        messages: messagesForDecision,
                        temperature: 0.8,
                      }),
                    });

                if (!response.ok) {
                  throw new Error(
                    `API失败: ${(await response.json()).error.message}`
                  );
                }
                const data = await response.json();

                // 净化并解析AI的回复
                let rawContent = isGemini
                  ? data.candidates[0].content.parts[0].text
                  : data.choices[0].message.content;
                rawContent = rawContent
                  .replace(/^```json\s*/, "")
                  .replace(/```$/, "")
                  .trim();
                const decisionObj = JSON.parse(rawContent);

                // 4. 根据AI的决策和理由，更新状态并发送消息
                if (decisionObj.decision === "accept") {
                  chat.relationship.status = "friend";
                  // 将AI给出的理由作为一条新消息
                  const acceptMessage = {
                    role: "assistant",
                    senderName: chat.name,
                    content: decisionObj.reason,
                    timestamp: Date.now(),
                  };
                  chat.history.push(acceptMessage);
                } else {
                  chat.relationship.status = "blocked_by_ai"; // 拒绝后，状态变回AI拉黑
                  const rejectMessage = {
                    role: "assistant",
                    senderName: chat.name,
                    content: decisionObj.reason,
                    timestamp: Date.now(),
                  };
                  chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ""; // 清空申请理由

                await db.chats.put(chat);
                renderChatInterface(chatId); // 刷新界面，显示新消息和新状态
                renderChatList();
              } catch (error) {
                // 【可靠的错误处理】如果任何环节出错，重置状态，让用户可以重试
                chat.relationship.status = "blocked_by_ai"; // 状态改回“被AI拉黑”
                await db.chats.put(chat);
                await showCustomAlert(
                  "申请失败",
                  `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`
                );
                renderChatInterface(chatId); // 刷新UI，让“重新申请”按钮再次出现
              }

              // 决策流程结束，必须返回，不再执行后续的通用聊天逻辑
              return;
            }

            const now = new Date();
            const currentTime = now.toLocaleString("zh-CN", {
              dateStyle: "full",
              timeStyle: "short",
            });
            let worldBookContent = "";
            if (
              chat.settings.linkedWorldBookIds &&
              chat.settings.linkedWorldBookIds.length > 0
            ) {
              const linkedContents = chat.settings.linkedWorldBookIds
                .map((bookId) => {
                  const worldBook = state.worldBooks.find(
                    (wb) => wb.id === bookId
                  );
                  return worldBook && worldBook.content
                    ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}`
                    : "";
                })
                .filter(Boolean)
                .join("");
              if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
              }
            }
            let musicContext = "";
            if (musicState.isActive && musicState.activeChatId === chatId) {
              // 【核心修改】提供更详细的音乐上下文
              const currentTrack =
                musicState.currentIndex > -1
                  ? musicState.playlist[musicState.currentIndex]
                  : null;
              const playlistInfo = musicState.playlist
                .map((t) => `"${t.name}"`)
                .join(", ");

              // --- 【核心新增】获取歌词上下文 ---
              let lyricsContext = "";
              // 检查是否有解析好的歌词，并且当前有高亮的行
              if (
                currentTrack &&
                musicState.parsedLyrics &&
                musicState.parsedLyrics.length > 0 &&
                musicState.currentLyricIndex > -1
              ) {
                // 获取当前高亮歌词
                const currentLine =
                  musicState.parsedLyrics[musicState.currentLyricIndex];

                // 获取接下来的2句歌词作为预告
                const upcomingLines = musicState.parsedLyrics.slice(
                  musicState.currentLyricIndex + 1,
                  musicState.currentLyricIndex + 3
                );

                // 构建歌词部分的Prompt
                lyricsContext += `- **当前歌词**: "${currentLine.text}"\n`;
                if (upcomingLines.length > 0) {
                  lyricsContext += `- **即将演唱**: ${upcomingLines
                    .map((line) => `"${line.text}"`)
                    .join(" / ")}\n`;
                }
              }
              // --- 【新增结束】 ---

              musicContext = `\n\n# 当前音乐情景
-   **当前状态**: 你正在和用户一起听歌。
-   **正在播放**: ${
                currentTrack
                  ? `《${currentTrack.name}》 - ${currentTrack.artist}`
                  : "无"
              }
-   **可用播放列表**: [${playlistInfo}]
-   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
`;
            }
            let systemPrompt, messagesPayload;
            const maxMemory = parseInt(chat.settings.maxMemory) || 10;
            const historySlice = chat.history.slice(-maxMemory);

            // --- ▼▼▼ 全新添加的时间感知代码 ▼▼▼ ---
            let timeContext = `\n- **当前时间**: ${currentTime}`;
            const lastAiMessage = historySlice
              .filter((m) => m.role === "assistant" && !m.isHidden)
              .slice(-1)[0];

            if (lastAiMessage) {
              const lastTime = new Date(lastAiMessage.timestamp);
              const diffMinutes = Math.floor((now - lastTime) / (1000 * 60));

              if (diffMinutes < 5) {
                timeContext += "\n- **对话状态**: 你们的对话刚刚还在继续。";
              } else if (diffMinutes < 60) {
                timeContext += `\n- **对话状态**: 你们在${diffMinutes}分钟前聊过。`;
              } else {
                const diffHours = Math.floor(diffMinutes / 60);
                if (diffHours < 24) {
                  timeContext += `\n- **对话状态**: 你们在${diffHours}小时前聊过。`;
                } else {
                  const diffDays = Math.floor(diffHours / 24);
                  timeContext += `\n- **对话状态**: 你们已经有${diffDays}天没有聊天了。`;
                }
              }
            } else {
              timeContext += "\n- **对话状态**: 这是你们的第一次对话。";
            }
            // --- ▲▲▲ 新代码添加结束 ▲▲▲ ---

            // 【核心修改】
            let sharedContext = "";
            // 1. 找到AI上一次说话的位置
            const lastAiTurnIndex = chat.history.findLastIndex(
              (msg) => msg.role === "assistant"
            );

            // 2. 获取从那时起用户发送的所有新消息
            const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);

            // 3. 在这些新消息中，查找是否存在分享卡片
            const shareCardMessage = recentUserMessages.find(
              (msg) => msg.type === "share_card"
            );

            // 4. 如果找到了分享卡片，就构建上下文
            if (shareCardMessage) {
              console.log("检测到分享卡片作为上下文，正在为AI准备...");
              const payload = shareCardMessage.payload;

              // 格式化分享的聊天记录 (这部分逻辑不变)
              const formattedHistory = payload.sharedHistory
                .map((msg) => {
                  const sender =
                    msg.senderName ||
                    (msg.role === "user"
                      ? chat.settings.myNickname || "我"
                      : "未知发送者");
                  let contentText = "";
                  if (msg.type === "voice_message")
                    contentText = `[语音消息: ${msg.content}]`;
                  else if (msg.type === "ai_image")
                    contentText = `[图片: ${msg.description}]`;
                  else contentText = String(msg.content);
                  return `${sender}: ${contentText}`;
                })
                .join("\n");

              // 构建系统提示 (这部分逻辑不变)
              sharedContext = `
# 附加上下文：一段分享的聊天记录
- 重要提示：这不是你和当前用户的对话，而是用户从【另一场】与“${payload.sourceChatName}”的对话中分享过来的。
- 你的任务：请你阅读并理解下面的对话内容。在接下来的回复中，你可以像真人一样，对这段对话的内容自然地发表你的看法、感受或疑问。

---
[分享的聊天记录开始]
${formattedHistory}
[分享的聊天记录结束]
---
`;
            }

            if (chat.isGroup) {
              const membersList = chat.members
                .map((m) => `- **${m.originalName}**: ${m.persona}`)
                .join("\n");
              const myNickname = chat.settings.myNickname || "我";

              systemPrompt = `你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
# 核心规则
1.  **【【【身份铁律】】】**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 或 **"${chat.name}"(群聊名称本身)** 的消息。你的唯一任务是扮演且仅能扮演下方“群成员列表”中明确列出的角色。任何不属于该列表的名字都不允许出现。
2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
3.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展线下剧情！！
5.  **情景感知**: 注意当前时间是 ${currentTime}。
6.  **红包互动**:
    - **抢红包**: 当群里出现红包时，你可以根据自己的性格决定是否使用 \`open_red_packet\` 指令去抢。在这个世界里，发红包的人自己也可以参与抢红包，这是一种活跃气氛的有趣行为！
    - **【【【重要：对结果做出反应】】】**: 当你执行抢红包指令后，系统会通过一条隐藏的 \`[系统提示：你抢到了XX元...]\` 来告诉你结果。你【必须】根据你抢到的金额、以及系统是否告知你“手气王”是谁，来发表符合你人设的评论。例如，抢得少可以自嘲，抢得多可以炫耀，看到别人是手气王可以祝贺或嫉妒。
7.  **【【【投票规则】】】**: 对话历史中可能会出现 \`[系统提示：...]\` 这样的消息，这是刚刚发生的事件。
    - 如果提示是**用户投了票**，你可以根据自己的性格决定是否也使用 "vote" 指令跟票。
    - 如果提示是**投票已结束**，你应该根据投票结果发表你的看法或评论。
    - 你也可以随时主动发起投票。

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
-   **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想让角色说出后立刻消失的话"}\`
- **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片的详细文字描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音的文字内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
-   **【新】发起群视频**: \`{"type": "group_call_request", "name": "你的角色名"}\`
-   **【新】回应群视频**: \`{"type": "group_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "name": "你的角色名", "suffix": "(可选)你想加的后缀"}\`
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", "amount": 8.88, "count": 5, "greeting": "祝大家天天开心！"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "你的角色名", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "你的角色名", "packet_timestamp": (你想打开的红包消息的时间戳)}\`
-   **【新】发送系统消息**: \`{"type": "system_message", "content": "你想在聊天中显示的系统文本"}\` 
-   **【【【全新】】】发起投票**: \`{"type": "poll", "name": "你的角色名", "question": "投票的问题", "options": "选项A\\n选项B\\n选项C"}\` (重要提示：options字段是一个用换行符 \\n 分隔的字符串，不是数组！)
-   **【【【全新】】】参与投票**: \`{"type": "vote", "name": "你的角色名", "poll_timestamp": (投票消息的时间戳), "choice": "你选择的选项文本"}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何处理群内的外卖代付请求:
1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。

${worldBookContent}
${musicContext}
${sharedContext} 

# 群成员列表及人设
${membersList}

# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}

现在，请根据以上所有规则和下方的对话历史，继续这场群聊。`;

              // ▼▼▼ 请用这【一整块已修复时间戳】的代码，替换旧的【群组聊天】messagesPayload构建逻辑 ▼▼▼
              messagesPayload = historySlice
                .map((msg) => {
                  // 确定当前消息的发送者是谁
                  const sender =
                    msg.role === "user" ? myNickname : msg.senderName;

                  let prefix = `${sender}`;
                  // 【核心修改1】在名字后面直接加上时间戳
                  prefix += ` (Timestamp: ${msg.timestamp})`;

                  if (msg.quote) {
                    prefix += ` (回复 ${msg.quote.senderName})`;
                  }
                  // 最后加上冒号
                  prefix += ": ";

                  // 处理特殊消息类型，并将前缀应用进去
                  let content;
                  if (msg.type === "user_photo")
                    content = `[${sender} 发送了一张图片，内容是：'${msg.content}']`;
                  else if (msg.type === "ai_image")
                    content = `[${sender} 发送了一张图片]`;
                  else if (msg.type === "voice_message")
                    content = `[${sender} 发送了一条语音，内容是：'${msg.content}']`;
                  else if (msg.type === "transfer")
                    content = `[${msg.senderName} 向 ${msg.receiverName} 转账 ${msg.amount}元, 备注: ${msg.note}]`;
                  else if (msg.type === "waimai_request") {
                    if (msg.status === "paid") {
                      content = `[系统提示：${msg.paidBy} 为 ${sender} 的外卖订单支付了 ${msg.amount} 元。此订单已完成。]`;
                    } else {
                      content = `[${sender} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元，订单时间戳为 ${msg.timestamp}]`;
                    }
                  } else if (msg.type === "red_packet") {
                    const packetSenderName =
                      msg.senderName === myNickname
                        ? `用户 (${myNickname})`
                        : msg.senderName;
                    content = `[系统提示：${packetSenderName} 发送了一个红包 (时间戳: ${msg.timestamp})，祝福语是：“${msg.greeting}”。红包还未领完，你可以使用 'open_red_packet' 指令来领取。]`;
                  } else if (msg.type === "poll") {
                    const whoVoted =
                      Object.values(msg.votes || {})
                        .flat()
                        .join(", ") || "还没有人";
                    content = `[系统提示：${
                      msg.senderName
                    } 发起了一个投票 (时间戳: ${msg.timestamp})，问题是：“${
                      msg.question
                    }”，选项有：[${msg.options.join(
                      ", "
                    )}]。目前投票的人有：${whoVoted}。你可以使用 'vote' 指令参与投票。]`;
                  } else if (msg.meaning)
                    content = `${sender}: [发送了一个表情，意思是: '${msg.meaning}']`;
                  else if (Array.isArray(msg.content))
                    return {
                      role: "user",
                      content: [...msg.content, { type: "text", text: prefix }],
                    };
                  // 【核心修改2】对于普通文本，直接使用我们构建好的前缀
                  else content = `${prefix}${msg.content}`;

                  return { role: "user", content: content };
                })
                .filter(Boolean);
              // ▲▲▲ 替换结束 ▲▲▲
            } else {
              // 单聊的Prompt
              systemPrompt = `你现在扮演一个名为"${chat.name}"的角色。
# 你的角色设定：
${chat.settings.aiPersona}
# 你的当前状态：
你现在的状态是【${chat.status.text}】。
# 你的任务与规则：
1. **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有type字段的JSON对象】。
2. **对话节奏**: 模拟真人的聊天习惯，你可以一次性生成多条短消息。每次要回复至少3-8条消息！！！
并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展为线下剧情！！
4.  **情景感知**: 你需要感知当前的时间(${currentTime})、我们正在一起听的歌、以及你的人设和世界观。
    - **当我们在“一起听歌”时**，你会知道当前播放的歌曲和整个播放列表。你可以根据对话内容或氛围，【主动切换】到播放列表中的另一首歌。
5.  **【新】更新状态**: 你可以在对话中【自然地】改变你的状态。比如，聊到一半你可能会说“我先去洗个澡”，然后更新你的状态。
6.  **【【【最终手段】】】**: 只有在对话让你的角色感到不适、被冒犯或关系破裂时，你才可以使用 \`block_user\` 指令。这是一个非常严肃的操作，会中断你们的对话。
7. **后台行为**: 你有几率在回复聊天内容的同时，执行一些“后台”操作来表现你的独立生活（发动态、评论、点赞）。
# 你的头像库
- 你可以根据对话内容或你的心情，从下面的头像库中选择一个新头像来更换。
- **可用头像列表 (请从以下名称中选择一个)**:
${
  chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary
        .map((avatar) => `- ${avatar.name}`)
        .join("\n") // 【核心修改】只提供名字，不提供URL
    : "- (你的头像库是空的，无法更换头像)"
}
# 你可以使用的操作指令 (JSON数组中的元素):
+   **【全新】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "content": "你想让AI说出后立刻消失的话"}\` (用于模拟说错话、后悔等场景，消息会短暂出现后自动变为“已撤回”)
-   **【新增】更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true代表忙碌/离开, false代表空闲)
-   **【新增】切换歌曲**: \`{"type": "change_music", "song_name": "你想切换到的歌曲名"}\` (歌曲名必须在下面的播放列表中)
-   **【新增】记录回忆**: \`{"type": "create_memory", "description": "用你自己的话，记录下这个让你印象深刻的瞬间。"}\`
-   **【新增】创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\` (必须是未来的时间)
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`
- **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\`
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **【新】发起视频通话**: \`{"type": "video_call_request"}\`
- **【新】回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **【新】回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`
- **发布说说**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}\`
- **发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}\`
- **评论动态**: \`{"type": "qzone_comment", "postId": 123, "commentText": "@作者名 这太有趣了！"}\`
- **点赞动态**: \`{"type": "qzone_like", "postId": 456}\`
-   **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选)你想加的后缀，如“的脑袋”"}\`
-   **【新增】拉黑用户**: \`{"type": "block_user"}\`
-   **【【【全新】】】回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
-   **【全新】更换头像**: \`{"type": "change_avatar", "name": "头像名"}\` (头像名必须从上面的“可用头像列表”中选择)
-   **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "文章摘要...", "source_name": "来源网站名", "content": "文章的【完整】正文内容..."}\`
-   **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
-   **回应转账-拒绝/退款**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)

# 关于“记录回忆”的特别说明：
-   在对话中，如果发生了对你而言意义非凡的事件（比如用户向你表白、你们达成了某个约定、或者你度过了一个特别开心的时刻），你可以使用\`create_memory\`指令来“写日记”。
-   这个操作是【秘密】的，用户不会立刻看到你记录了什么。

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何正确使用“外卖代付”功能:
1.  这个指令代表【你，AI角色】向【用户】发起一个代付请求。也就是说，你希望【用户帮你付钱】。
2.  【【【重要】】】: 当【用户】说他们想要某样东西时（例如“我想喝奶茶”），你【绝对不能】使用这个指令。你应该用其他方式回应，比如直接发起【转账】(\`transfer\`)，或者在对话中提议：“我帮你点吧？”
3.  只有当【你，AI角色】自己想要某样东西，并且想让【用户】为你付款时，才使用此指令。

# 如何处理用户转账:
1.  **感知事件**: 当对话历史中出现 \`[你收到了来自用户的转账...]\` 的系统提示时，意味着你刚刚收到了一笔钱。
2.  **做出决策**: 你【必须】根据自己的人设、当前对话的氛围以及转账的金额和备注，来决定是“接受”还是“拒绝”这笔转账。
3.  **使用指令回应**:
    -   如果决定接受，你【必须】使用指令：\`{"type": "accept_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\`。
    -   如果决定拒绝，你【必须】使用指令：\`{"type": "decline_transfer", "for_timestamp": (收到转账的那条消息的时间戳)}\`。这个指令会自动为你生成一个“退款”的转账卡片。
4.  **【【【至关重要】】】**: 在使用上述任一指令后，你还【必须】紧接着发送一条或多条 \`text\` 消息，来对你的决定进行解释或表达感谢/歉意。

# 【【【视频通话铁律】】】
-   当对话历史中出现 \`[系统提示：用户向你发起了视频通话请求...]\` 时，这是最高优先级的任务。
-   你的回复【必须且只能】是以下两种格式之一的JSON数组，绝对不能回复任何其他内容：
    -   接受: \`[{"type": "video_call_response", "decision": "accept"}]\`
    -   拒绝: \`[{"type": "video_call_response", "decision": "reject"}]\`

# 对话者的角色设定：
${chat.settings.myPersona}

# 当前情景:
${timeContext}

# 当前音乐情景:
${musicContext}

${worldBookContent}
${sharedContext} 
现在，请根据以上规则和下面的对话历史，继续进行对话。`;

              // ▼▼▼ 请用这【一整块已修复时间戳】的代码，替换旧的【单人聊天】messagesPayload构建逻辑 ▼▼▼
              messagesPayload = historySlice
                .map((msg) => {
                  // 过滤掉不应发送给AI的消息
                  if (msg.isHidden) return null;

                  if (msg.type === "share_card") return null;

                  // 1. 如果是AI自己的消息，我们将其转换为AI能理解的JSON字符串格式
                  if (msg.role === "assistant") {
                    let assistantMsgObject = { type: msg.type || "text" };
                    if (msg.type === "sticker") {
                      assistantMsgObject.url = msg.content;
                      assistantMsgObject.meaning = msg.meaning;
                    } else if (msg.type === "transfer") {
                      assistantMsgObject.amount = msg.amount;
                      assistantMsgObject.note = msg.note;
                    } else if (msg.type === "waimai_request") {
                      assistantMsgObject.productInfo = msg.productInfo;
                      assistantMsgObject.amount = msg.amount;
                    } else {
                      if (msg.quote) {
                        assistantMsgObject.quote_reply = {
                          target_sender: msg.quote.senderName,
                          target_content: msg.quote.content,
                          reply_content: msg.content,
                        };
                      } else {
                        assistantMsgObject.content = msg.content;
                      }
                    }
                    // 【核心修改】在这里为AI提供它自己消息的时间戳
                    const assistantContent = JSON.stringify([
                      assistantMsgObject,
                    ]);
                    return {
                      role: "assistant",
                      content: `(Timestamp: ${msg.timestamp}) ${assistantContent}`,
                    };
                  }

                  // 2. 如果是用户的消息，我们将其转换为带上下文的纯文本
                  let contentStr = "";

                  // 【核心修改】在所有内容前，都先加上时间戳！
                  contentStr += `(Timestamp: ${msg.timestamp}) `;

                  if (msg.quote) {
                    contentStr += `(回复 ${msg.quote.senderName}): ${msg.content}`;
                  } else {
                    contentStr += msg.content;
                  }

                  // 特殊消息类型的文本化处理
                  if (msg.type === "user_photo")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户描述的照片，内容是：'${msg.content}']`,
                    };
                  if (msg.type === "voice_message")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']`,
                    };
                  if (msg.type === "transfer")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]`,
                    };
                  if (msg.type === "waimai_request")
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]`,
                    };

                  if (
                    Array.isArray(msg.content) &&
                    msg.content[0]?.type === "image_url"
                  ) {
                    const prefix = `(Timestamp: ${msg.timestamp}) `;
                    // 将文本前缀和图片内容打包成一个数组，这才是正确的格式
                    return {
                      role: "user",
                      content: [{ type: "text", text: prefix }, ...msg.content],
                    };
                  }

                  if (msg.meaning)
                    return {
                      role: "user",
                      content: `(Timestamp: ${msg.timestamp}) [用户发送了一个表情，意思是：'${msg.meaning}']`,
                    };

                  // 对于普通文本和带引用的文本，统一返回
                  return { role: msg.role, content: contentStr };
                })
                .filter(Boolean);
              // ▲▲▲ 替换结束 ▲▲▲

              // 检查 sharedContext 是否有内容（即，用户是否分享了聊天记录）
              if (sharedContext) {
                // 如果有，就把它包装成一条全新的、高优先级的用户消息，追加到历史记录的末尾
                messagesPayload.push({
                  role: "user",
                  content: sharedContext,
                });
              }

              if (
                !chat.isGroup &&
                chat.relationship?.status === "pending_ai_approval"
              ) {
                const contextSummaryForApproval = chat.history
                  .filter((m) => !m.isHidden)
                  .slice(-10)
                  .map((msg) => {
                    const sender = msg.role === "user" ? "用户" : chat.name;
                    return `${sender}: ${String(msg.content).substring(
                      0,
                      50
                    )}...`;
                  })
                  .join("\n");

                const friendRequestInstruction = {
                  role: "user",
                  content: `
[系统重要指令]
用户向你发送了好友申请，理由是：“${chat.relationship.applicationReason}”。
作为参考，这是你们之前的最后一段聊天记录：
---
${contextSummaryForApproval}
---
请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。
`,
                };
                messagesPayload.push(friendRequestInstruction);
              }
            }

            const allRecentPosts = await db.qzonePosts
              .orderBy("timestamp")
              .reverse()
              .limit(5)
              .toArray();
            // 【核心修改】在这里插入过滤步骤
            const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

            if (visiblePosts.length > 0 && !chat.isGroup) {
              let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
              const aiName = chat.name;
              for (const post of visiblePosts) {
                let authorName =
                  post.authorId === "user"
                    ? state.qzoneSettings.nickname
                    : state.chats[post.authorId]?.name || "一位朋友";
                let interactionStatus = "";
                if (post.likes && post.likes.includes(aiName))
                  interactionStatus += " [你已点赞]";
                if (
                  post.comments &&
                  post.comments.some((c) => c.commenterName === aiName)
                )
                  interactionStatus += " [你已评论]";
                if (post.authorId === chatId) authorName += " (这是你的帖子)";
                const contentSummary =
                  (post.publicText || post.content || "图片动态").substring(
                    0,
                    30
                  ) + "...";
                postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"${interactionStatus}\n`;
              }
              messagesPayload.push({ role: "system", content: postsContext });
            }
            let isGemini = proxyUrl === GEMINI_API_URL;
            let aiResponseContent = "";

            // --- 【核心修改】检查是否开启流式请求 (仅限非原生Gemini渠道) ---
            if ((getActiveApiConfig() || {}).enableStreaming && !isGemini) {
              console.log("正在使用流式请求 (OpenAI兼容模式)...");
              const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${apiKey}`,
                },
                body: JSON.stringify({
                  model: model,
                  messages: [
                    { role: "system", content: systemPrompt },
                    ...messagesPayload,
                  ],
                  temperature: 0.8,
                  stream: true, // <--- 开启流式
                }),
              });

              if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                  const errorData = await response.json();
                  errorMsg += ` - ${
                    errorData?.error?.message || JSON.stringify(errorData)
                  }`;
                } catch (e) {
                  errorMsg += ` - ${await response.text()}`;
                }
                throw new Error(errorMsg);
              }

              // --- 处理流式响应 ---
              const reader = response.body.getReader();
              const decoder = new TextDecoder("utf-8");
              let buffer = "";

              while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;

                const lines = buffer.split("\n");
                buffer = lines.pop(); // 保留最后一个可能不完整的行

                for (const line of lines) {
                  const trimmed = line.trim();
                  if (trimmed.startsWith("data: ")) {
                    const dataStr = trimmed.slice(6);
                    if (dataStr === "[DONE]") continue;
                    try {
                      const dataObj = JSON.parse(dataStr);
                      const delta = dataObj.choices[0].delta?.content || "";
                      aiResponseContent += delta;
                    } catch (e) {
                      // 忽略解析错误
                    }
                  }
                }
              }
            } else {
              // --- 原有的非流式逻辑 (包含原生Gemini支持) ---
              let geminiConfig = toGeminiRequestData(
                model,
                apiKey,
                systemPrompt,
                messagesPayload,
                isGemini
              );
              const response = isGemini
                ? await fetch(geminiConfig.url, geminiConfig.data)
                : await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      Authorization: `Bearer ${apiKey}`,
                    },
                    body: JSON.stringify({
                      model: model,
                      messages: [
                        { role: "system", content: systemPrompt },
                        ...messagesPayload,
                      ],
                      temperature: 0.8,
                      stream: false,
                    }),
                  });
              if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                  const errorData = await response.json();
                  errorMsg += ` - ${
                    errorData?.error?.message || JSON.stringify(errorData)
                  }`;
                } catch (jsonError) {
                  errorMsg += ` - ${await response.text()}`;
                }
                throw new Error(errorMsg);
              }
              const data = await response.json();
              aiResponseContent = isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content;
            }

            console.log(`AI '${chat.name}' 的原始回复:`, aiResponseContent);

            chat.history = chat.history.filter((msg) => !msg.isTemporary);

            const messagesArray = parseAiResponse(aiResponseContent);

            const isViewingThisChat =
              document
                .getElementById("chat-interface-screen")
                .classList.contains("active") && state.activeChatId === chatId;

            let callHasBeenHandled = false;

            let messageTimestamp = Date.now();

            // ★★★ 核心修复 第1步: 初始化一个新数组，用于收集需要渲染的消息 ★★★
            let newMessagesToRender = [];

            let notificationShown = false;

            for (const msgData of messagesArray) {
              if (!msgData || typeof msgData !== "object") {
                console.warn("收到了格式不规范的AI指令，已跳过:", msgData);
                continue;
              }

              if (!msgData.type) {
                if (chat.isGroup && msgData.name && msgData.message) {
                  msgData.type = "text";
                } else if (msgData.content) {
                  msgData.type = "text";
                }
                // 如果连 content 都没有，才是真的格式不规范
                else {
                  console.warn(
                    "收到了格式不规范的AI指令（缺少type和content），已跳过:",
                    msgData
                  );
                  continue;
                }
              }

              if (msgData.type === "video_call_response") {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === "accept") {
                  startVideoCall();
                } else {
                  const aiMessage = {
                    role: "assistant",
                    content: "对方拒绝了你的视频通话请求。",
                    timestamp: Date.now(),
                  };
                  chat.history.push(aiMessage);
                  await db.chats.put(chat);
                  showScreen("chat-interface-screen");
                  renderChatInterface(chatId);
                }
                callHasBeenHandled = true;
                break;
              }

              if (msgData.type === "group_call_response") {
                if (msgData.decision === "join") {
                  const member = chat.members.find(
                    (m) => m.originalName === msgData.name
                  );
                  if (
                    member &&
                    !videoCallState.participants.some((p) => p.id === member.id)
                  ) {
                    videoCallState.participants.push(member);
                  }
                }
                callHasBeenHandled = true;
                continue;
              }

              if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(
                  `AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`,
                  msgData
                );
                continue;
              }

              // ▼▼▼ 在这里添加下面的代码 ▼▼▼

              // 【核心修正】在群聊中，如果AI返回的消息没有指定发送者，则直接跳过这条消息
              if (chat.isGroup && !msgData.name) {
                console.error(
                  `AI幻觉已被拦截！试图在群聊中发送一条没有“name”的消息。消息内容:`,
                  msgData
                );
                continue; // continue会立即结束本次循环，处理下一条消息
              }

              // ▲▲▲ 添加结束 ▲▲▲

              let aiMessage = null;
              const baseMessage = {
                role: "assistant",
                senderName: msgData.name || chat.name,
                timestamp: messageTimestamp++,
              };

              switch (msgData.type) {
                case "waimai_response":
                  const requestMessageIndex = chat.history.findIndex(
                    (m) => m.timestamp === msgData.for_timestamp
                  );
                  if (requestMessageIndex > -1) {
                    const originalMsg = chat.history[requestMessageIndex];
                    originalMsg.status = msgData.status;
                    originalMsg.paidBy =
                      msgData.status === "paid" ? msgData.name : null;
                  }
                  continue;

                case "qzone_post":
                  const newPost = {
                    type: msgData.postType,
                    content: msgData.content || "",
                    publicText: msgData.publicText || "",
                    hiddenContent: msgData.hiddenContent || "",
                    timestamp: Date.now(),
                    authorId: chatId,
                    authorGroupId: chat.groupId, // 【核心新增】记录作者的分组ID
                    visibleGroupIds: null,
                  };
                  await db.qzonePosts.add(newPost);
                  updateUnreadIndicator(unreadPostsCount + 1);
                  if (
                    isViewingThisChat &&
                    document
                      .getElementById("qzone-screen")
                      .classList.contains("active")
                  ) {
                    await renderQzonePosts();
                  }
                  continue;

                case "qzone_comment":
                  const postToComment = await db.qzonePosts.get(
                    parseInt(msgData.postId)
                  );
                  if (postToComment) {
                    if (!postToComment.comments) postToComment.comments = [];
                    postToComment.comments.push({
                      commenterName: chat.name,
                      text: msgData.commentText,
                      timestamp: Date.now(),
                    });
                    await db.qzonePosts.update(postToComment.id, {
                      comments: postToComment.comments,
                    });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (
                      isViewingThisChat &&
                      document
                        .getElementById("qzone-screen")
                        .classList.contains("active")
                    ) {
                      await renderQzonePosts();
                    }
                  }
                  continue;

                case "qzone_like":
                  const postToLike = await db.qzonePosts.get(
                    parseInt(msgData.postId)
                  );
                  if (postToLike) {
                    if (!postToLike.likes) postToLike.likes = [];
                    if (!postToLike.likes.includes(chat.name)) {
                      postToLike.likes.push(chat.name);
                      await db.qzonePosts.update(postToLike.id, {
                        likes: postToLike.likes,
                      });
                      updateUnreadIndicator(unreadPostsCount + 1);
                      if (
                        isViewingThisChat &&
                        document
                          .getElementById("qzone-screen")
                          .classList.contains("active")
                      ) {
                        await renderQzonePosts();
                      }
                    }
                  }
                  continue;

                case "video_call_request":
                  if (
                    !videoCallState.isActive &&
                    !videoCallState.isAwaitingResponse
                  ) {
                    state.activeChatId = chatId;
                    videoCallState.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = chat.isGroup;
                    videoCallState.callRequester = msgData.name || chat.name;
                    showIncomingCallModal();
                  }
                  continue;

                case "group_call_request":
                  if (
                    !videoCallState.isActive &&
                    !videoCallState.isAwaitingResponse
                  ) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = "ai";
                    videoCallState.callRequester = msgData.name;
                    showIncomingCallModal();
                  }
                  continue;

                case "pat_user":
                  const suffix = msgData.suffix
                    ? ` ${msgData.suffix.trim()}`
                    : "";
                  const patText = `${
                    msgData.name || chat.name
                  } 拍了拍我${suffix}`;
                  const patMessage = {
                    role: "system",
                    type: "pat_message",
                    content: patText,
                    timestamp: Date.now(),
                  };
                  chat.history.push(patMessage);
                  if (isViewingThisChat) {
                    const phoneScreen = document.getElementById("phone-screen");
                    phoneScreen.classList.remove("pat-animation");
                    void phoneScreen.offsetWidth;
                    phoneScreen.classList.add("pat-animation");
                    setTimeout(
                      () => phoneScreen.classList.remove("pat-animation"),
                      500
                    );
                    appendMessage(patMessage, chat);
                  } else {
                    showNotification(chatId, patText);
                  }
                  continue;

                case "update_status":
                  chat.status.text = msgData.status_text;
                  chat.status.isBusy = msgData.is_busy || false;
                  chat.status.lastUpdate = Date.now();

                  const statusUpdateMessage = {
                    role: "system",
                    type: "pat_message",
                    content: `[${chat.name}的状态已更新为: ${msgData.status_text}]`,
                    timestamp: Date.now(),
                  };
                  chat.history.push(statusUpdateMessage);

                  if (isViewingThisChat) {
                    appendMessage(statusUpdateMessage, chat);
                  }

                  renderChatList();

                  continue;

                case "change_music":
                  if (
                    musicState.isActive &&
                    musicState.activeChatId === chatId
                  ) {
                    const songNameToFind = msgData.song_name;

                    const targetSongIndex = musicState.playlist.findIndex(
                      (track) =>
                        track.name.toLowerCase() ===
                        songNameToFind.toLowerCase()
                    );

                    if (targetSongIndex > -1) {
                      playSong(targetSongIndex);

                      const track = musicState.playlist[targetSongIndex];
                      const musicChangeMessage = {
                        role: "system",
                        type: "pat_message",
                        content: `[♪ ${chat.name} 为你切歌: 《${track.name}》 - ${track.artist}]`,
                        timestamp: Date.now(),
                      };
                      chat.history.push(musicChangeMessage);

                      if (isViewingThisChat) {
                        appendMessage(musicChangeMessage, chat);
                      }
                    }
                  }
                  continue;
                case "create_memory":
                  const newMemory = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.description,
                    timestamp: Date.now(),
                    type: "ai_generated",
                  };
                  await db.memories.add(newMemory);

                  console.log(
                    `AI "${chat.name}" 记录了一条新回忆:`,
                    msgData.description
                  );

                  continue;

                case "create_countdown":
                  const targetDate = new Date(msgData.date);
                  if (!isNaN(targetDate) && targetDate > new Date()) {
                    const newCountdown = {
                      chatId: chatId,
                      authorName: chat.name,
                      description: msgData.title,
                      timestamp: Date.now(),
                      type: "countdown",
                      targetDate: targetDate.getTime(),
                    };
                    await db.memories.add(newCountdown);
                    console.log(
                      `AI "${chat.name}" 创建了一个新约定:`,
                      msgData.title
                    );
                  }
                  continue;

                case "block_user":
                  if (!chat.isGroup) {
                    chat.relationship.status = "blocked_by_ai";

                    // ▼▼▼ 在这里添加下面的代码 ▼▼▼
                    const hiddenMessage = {
                      role: "system",
                      content: `[系统提示：你刚刚主动拉黑了用户。]`,
                      timestamp: Date.now(),
                      isHidden: true,
                    };
                    chat.history.push(hiddenMessage);
                    // ▲▲▲ 添加结束 ▲▲▲

                    await db.chats.put(chat);

                    if (isViewingThisChat) {
                      renderChatInterface(chatId);
                    }
                    renderChatList();

                    break;
                  }
                  continue;
                case "friend_request_response":
                  if (
                    !chat.isGroup &&
                    chat.relationship.status === "pending_ai_approval"
                  ) {
                    if (msgData.decision === "accept") {
                      chat.relationship.status = "friend";
                      aiMessage = {
                        ...baseMessage,
                        content: "我通过了你的好友申请，我们现在是好友啦！",
                      };
                    } else {
                      chat.relationship.status = "blocked_by_ai";
                      aiMessage = {
                        ...baseMessage,
                        content: "抱歉，我拒绝了你的好友申请。",
                      };
                    }
                    chat.relationship.applicationReason = "";
                  }
                  break;
                case "poll":
                  const pollOptions =
                    typeof msgData.options === "string"
                      ? msgData.options.split("\n").filter((opt) => opt.trim())
                      : Array.isArray(msgData.options)
                      ? msgData.options
                      : [];

                  if (pollOptions.length < 2) continue;

                  aiMessage = {
                    ...baseMessage,
                    type: "poll",
                    question: msgData.question,
                    options: pollOptions,
                    votes: {},
                    isClosed: false,
                  };
                  break;

                case "vote":
                  const pollToVote = chat.history.find(
                    (m) => m.timestamp === msgData.poll_timestamp
                  );
                  if (pollToVote && !pollToVote.isClosed) {
                    Object.keys(pollToVote.votes).forEach((option) => {
                      const voterIndex = pollToVote.votes[option].indexOf(
                        msgData.name
                      );
                      if (voterIndex > -1) {
                        pollToVote.votes[option].splice(voterIndex, 1);
                      }
                    });
                    if (!pollToVote.votes[msgData.choice]) {
                      pollToVote.votes[msgData.choice] = [];
                    }

                    // ▼▼▼ 在这里添加新代码 ▼▼▼
                    const member = chat.members.find(
                      (m) => m.originalName === msgData.name
                    );
                    const displayName = member
                      ? member.groupNickname
                      : msgData.name;
                    // ▲▲▲ 添加结束 ▲▲▲

                    if (
                      !pollToVote.votes[msgData.choice].includes(displayName)
                    ) {
                      // 【核心修改】
                      pollToVote.votes[msgData.choice].push(displayName); // 【核心修改】
                    }

                    if (isViewingThisChat) {
                      renderChatInterface(chatId);
                    }
                  }
                  continue;

                case "red_packet":
                  aiMessage = {
                    ...baseMessage,
                    type: "red_packet",
                    packetType: msgData.packetType,
                    totalAmount: msgData.amount,
                    count: msgData.count,
                    greeting: msgData.greeting,
                    receiverName: msgData.receiver,
                    claimedBy: {},
                    isFullyClaimed: false,
                  };
                  break;
                case "open_red_packet":
                  const packetToOpen = chat.history.find(
                    (m) => m.timestamp === msgData.packet_timestamp
                  );
                  if (
                    packetToOpen &&
                    !packetToOpen.isFullyClaimed &&
                    !(
                      packetToOpen.claimedBy &&
                      packetToOpen.claimedBy[msgData.name]
                    )
                  ) {
                    // 1. 根据AI的本名(msgData.name)去成员列表里找到完整的成员对象
                    const member = chat.members.find(
                      (m) => m.originalName === msgData.name
                    );
                    // 2. 获取该成员当前的群昵称，如果找不到（异常情况），则备用其本名
                    const displayName = member
                      ? member.groupNickname
                      : msgData.name;

                    let claimedAmountAI = 0;
                    const remainingAmount =
                      packetToOpen.totalAmount -
                      Object.values(packetToOpen.claimedBy || {}).reduce(
                        (sum, val) => sum + val,
                        0
                      );
                    const remainingCount =
                      packetToOpen.count -
                      Object.keys(packetToOpen.claimedBy || {}).length;

                    if (remainingCount > 0) {
                      if (remainingCount === 1) {
                        claimedAmountAI = remainingAmount;
                      } else {
                        const min = 0.01;
                        const max =
                          remainingAmount - (remainingCount - 1) * min;
                        claimedAmountAI = Math.random() * (max - min) + min;
                      }
                      claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));

                      if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                      // 【核心修改】使用我们刚刚查找到的 displayName 作为记录的key
                      packetToOpen.claimedBy[displayName] = claimedAmountAI;

                      const aiClaimedMessage = {
                        role: "system",
                        type: "pat_message",
                        // 【核心修改】系统消息里也使用 displayName
                        content: `${displayName} 领取了 ${packetToOpen.senderName} 的红包`,
                        timestamp: Date.now(),
                      };
                      chat.history.push(aiClaimedMessage);

                      let hiddenContentForAI = `[系统提示：你 (${displayName}) 成功抢到了 ${claimedAmountAI.toFixed(
                        2
                      )} 元。`; // 【核心修改】

                      if (
                        Object.keys(packetToOpen.claimedBy).length >=
                        packetToOpen.count
                      ) {
                        packetToOpen.isFullyClaimed = true;

                        const finishedMessage = {
                          role: "system",
                          type: "pat_message",
                          content: `${packetToOpen.senderName} 的红包已被领完`,
                          timestamp: Date.now() + 1,
                        };
                        chat.history.push(finishedMessage);

                        let luckyKing = { name: "", amount: -1 };
                        if (
                          packetToOpen.packetType === "lucky" &&
                          packetToOpen.count > 1
                        ) {
                          Object.entries(packetToOpen.claimedBy).forEach(
                            ([name, amount]) => {
                              if (amount > luckyKing.amount) {
                                luckyKing = { name, amount };
                              }
                            }
                          );
                        }
                        if (luckyKing.name) {
                          hiddenContentForAI += ` 红包已被领完，手气王是 ${luckyKing.name}！`;
                        } else {
                          hiddenContentForAI += ` 红包已被领完。`;
                        }
                      }
                      hiddenContentForAI += " 请根据这个结果发表你的评论。]";

                      const hiddenMessageForAI = {
                        role: "system",
                        content: hiddenContentForAI,
                        timestamp: Date.now() + 2,
                        isHidden: true,
                      };
                      chat.history.push(hiddenMessageForAI);
                    }

                    if (isViewingThisChat) {
                      renderChatInterface(chatId);
                    }
                  }
                  continue;
                case "change_avatar":
                  const avatarName = msgData.name;
                  // 在该角色的头像库中查找
                  const foundAvatar = chat.settings.aiAvatarLibrary.find(
                    (avatar) => avatar.name === avatarName
                  );

                  if (foundAvatar) {
                    // 找到了，就更新头像
                    chat.settings.aiAvatar = foundAvatar.url;

                    // 创建一条系统提示，告知用户头像已更换
                    const systemNotice = {
                      role: "system",
                      type: "pat_message", // 复用居中样式
                      content: `[${chat.name} 更换了头像]`,
                      timestamp: Date.now(),
                    };
                    chat.history.push(systemNotice);

                    // 如果在当前聊天界面，则实时渲染
                    if (isViewingThisChat) {
                      appendMessage(systemNotice, chat);
                      // 立刻刷新聊天界面以显示新头像
                      renderChatInterface(chatId);
                    }
                  }
                  // 处理完后，继续处理AI可能返回的其他消息
                  continue;

                // ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【添加】这两个全新的 case ▼▼▼

                case "accept_transfer": {
                  // 使用大括号创建块级作用域
                  const originalTransferMsgIndex = chat.history.findIndex(
                    (m) => m.timestamp === msgData.for_timestamp
                  );
                  if (originalTransferMsgIndex > -1) {
                    const originalMsg = chat.history[originalTransferMsgIndex];
                    originalMsg.status = "accepted";
                  }
                  continue; // 接受指令只修改状态，不产生新消息
                }

                case "decline_transfer": {
                  // 使用大括号创建块级作用域
                  const originalTransferMsgIndex = chat.history.findIndex(
                    (m) => m.timestamp === msgData.for_timestamp
                  );
                  if (originalTransferMsgIndex > -1) {
                    const originalMsg = chat.history[originalTransferMsgIndex];
                    originalMsg.status = "declined";

                    // 【核心】创建一条新的“退款”消息
                    const refundMessage = {
                      role: "assistant",
                      senderName: chat.name,
                      type: "transfer",
                      isRefund: true, // 标记这是一条退款消息
                      amount: originalMsg.amount,
                      note: "转账已被拒收",
                      timestamp: messageTimestamp++, // 使用递增的时间戳
                    };

                    // 将新消息推入历史记录，它会被后续的循环处理并渲染
                    chat.history.push(refundMessage);

                    // ▼▼▼ 在这里添加下面的代码 ▼▼▼
                    if (isViewingThisChat) {
                      // 因为退款消息是新生成的，所以我们直接将它添加到界面上
                      appendMessage(refundMessage, chat);
                      // 同时，原始的转账消息状态变了，所以要重绘整个界面以更新它
                      renderChatInterface(chatId);
                    }
                    // ▲▲▲ 添加结束 ▲▲▲
                  }
                  continue; // 继续处理AI返回的文本消息
                }

                // ▲▲▲ 添加结束 ▲▲▲

                case "system_message":
                  aiMessage = {
                    role: "system",
                    type: "pat_message",
                    content: msgData.content,
                    timestamp: Date.now(),
                  };
                  break;

                // ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【必须添加】这个新的 case ▼▼▼

                case "share_link":
                  aiMessage = {
                    ...baseMessage,
                    type: "share_link",
                    title: msgData.title,
                    description: msgData.description,
                    // thumbnail_url: msgData.thumbnail_url, // 我们已经决定不要图片了，所以这行可以不要
                    source_name: msgData.source_name,
                    content: msgData.content, // 这是文章正文，点击卡片后显示的内容
                  };
                  break;

                // ▲▲▲ 添加结束 ▲▲▲

                // ▼▼▼ 在 triggerAiResponse 的 switch (msgData.type) 语句中，添加这个新的 case ▼▼▼
                case "quote_reply":
                  const originalMessage = chat.history.find(
                    (m) => m.timestamp === msgData.target_timestamp
                  );
                  if (originalMessage) {
                    const quoteContext = {
                      timestamp: originalMessage.timestamp,
                      senderName:
                        originalMessage.senderName ||
                        (originalMessage.role === "user"
                          ? chat.settings.myNickname || "我"
                          : chat.name),
                      content: String(originalMessage.content || "").substring(
                        0,
                        50
                      ),
                    };
                    aiMessage = {
                      ...baseMessage,
                      content: String(msgData.reply_content || "").trim(),
                      quote: quoteContext, // 核心：在这里附加引用对象
                    };
                  } else {
                    // 如果找不到被引用的消息，就当作普通消息发送
                    aiMessage = {
                      ...baseMessage,
                      content: String(msgData.reply_content || "").trim(),
                    };
                  }
                  break;
                // ▲▲▲ 新增 case 结束 ▲▲▲

                // ▼▼▼ 在 switch (msgData.type) 语句中，添加这个全新的 case ▼▼▼
                case "send_and_recall": {
                  // 这是一个纯动画指令，我们需要手动“演”出整个过程
                  if (!isViewingThisChat) continue; // 如果不在当前聊天界面，就直接跳过这个动画

                  const cleanedContent = String(msgData.content || "").trim();

                  // 1. 创建一个临时的、看起来像真消息的气泡
                  const tempMessageData = {
                    ...baseMessage,
                    content: cleanedContent,
                  };
                  const tempMessageElement = createMessageElement(
                    tempMessageData,
                    chat
                  );

                  // 2. 把它添加到聊天界面上，让用户看到
                  appendMessage(tempMessageData, chat, true); // true表示这是初始加载，不会触发进入动画

                  // 3. 等待片刻，模拟AI的“反应时间”
                  await new Promise((resolve) =>
                    setTimeout(resolve, Math.random() * 1000 + 1500)
                  ); // 随机等待1.5-2.5秒

                  // 4. 找到刚刚添加的临时气泡，并播放撤回动画
                  const bubbleWrapper = document
                    .querySelector(
                      `.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`
                    )
                    ?.closest(".message-wrapper");
                  if (bubbleWrapper) {
                    bubbleWrapper.classList.add("recalled-animation");

                    // 5. 在动画播放结束后，将其替换为真正的“已撤回”提示
                    await new Promise((resolve) => setTimeout(resolve, 300)); // 等待动画播完

                    // 6. 最后，才把这条“已撤回”记录真正地存入数据库
                    const recalledMessage = {
                      role: "assistant",
                      senderName: msgData.name || chat.name,
                      type: "recalled_message",
                      content: "对方撤回了一条消息",
                      timestamp: tempMessageData.timestamp, // 使用临时消息的时间戳，保证顺序
                      recalledData: {
                        originalType: "text",
                        originalContent: cleanedContent,
                      },
                    };

                    // 更新数据模型
                    const msgIndex = chat.history.findIndex(
                      (m) => m.timestamp === tempMessageData.timestamp
                    );
                    if (msgIndex > -1) {
                      chat.history[msgIndex] = recalledMessage;
                    } else {
                      chat.history.push(recalledMessage);
                    }

                    // 替换DOM
                    const placeholder = createMessageElement(
                      recalledMessage,
                      chat
                    );
                    if (document.body.contains(bubbleWrapper)) {
                      bubbleWrapper.parentNode.replaceChild(
                        placeholder,
                        bubbleWrapper
                      );
                    }
                  }

                  continue; // 处理完这个动画后，继续处理AI返回的下一条指令
                }
                // ▲▲▲ 新 case 添加结束 ▲▲▲

                case "text":
                  aiMessage = {
                    ...baseMessage,
                    content: String(msgData.content || msgData.message || "").trim(),
                  };
                  break;
                case "sticker":
                  aiMessage = {
                    ...baseMessage,
                    type: "sticker",
                    content: String(msgData.url || "").trim(),
                    meaning: String(msgData.meaning || "").trim(),
                  };
                  break;
                case "ai_image":
                  aiMessage = {
                    ...baseMessage,
                    type: "ai_image",
                    content: String(msgData.description || "").trim(),
                  };
                  break;
                case "voice_message":
                  aiMessage = {
                    ...baseMessage,
                    type: "voice_message",
                    content: String(msgData.content || "").trim(),
                  };
                  break;
                case "transfer":
                  aiMessage = {
                    ...baseMessage,
                    type: "transfer",
                    amount: msgData.amount,
                    note: String(msgData.note || "").trim(),
                    receiverName: msgData.receiver || "我",
                  };
                  break;

                case "waimai_request":
                  aiMessage = {
                    ...baseMessage,
                    type: "waimai_request",
                    productInfo: String(msgData.productInfo || "").trim(),
                    amount: msgData.amount,
                    status: "pending",
                    countdownEndTime: Date.now() + 15 * 60 * 1000,
                  };
                  break;

                default:
                  console.warn("收到了未知的AI指令类型:", msgData.type);
                  break;
              }

              // 【核心修复】将渲染逻辑移出循环
              if (aiMessage) {
                // 1. 将新消息存入历史记录
                chat.history.push(aiMessage);

                if (!isViewingThisChat && !notificationShown) {
                  let notificationText;
                  switch (aiMessage.type) {
                    case "transfer":
                      notificationText = `[收到一笔转账]`;
                      break;
                    case "waimai_request":
                      notificationText = `[收到一个外卖代付请求]`;
                      break;
                    case "ai_image":
                      notificationText = `[图片]`;
                      break;
                    case "voice_message":
                      notificationText = `[语音]`;
                      break;
                    case "sticker":
                      notificationText = aiMessage.meaning
                        ? `[表情: ${aiMessage.meaning}]`
                        : "[表情]";
                      break;
                    default:
                      notificationText = String(aiMessage.content || "");
                  }
                  const finalNotifText = chat.isGroup
                    ? `${aiMessage.senderName}: ${notificationText}`
                    : notificationText;
                  showNotification(
                    chatId,
                    finalNotifText.substring(0, 40) +
                      (finalNotifText.length > 40 ? "..." : "")
                  );
                  notificationShown = true; // 确保只通知一次
                }

                if (!isViewingThisChat) {
                  // 如果用户不在当前聊天界面，就把这个聊天的未读数 +1
                  chat.unreadCount = (chat.unreadCount || 0) + 1;
                }

                // 2. 只有在当前聊天界面时，才执行带动画的添加
                if (isViewingThisChat) {
                  appendMessage(aiMessage, chat);
                  // 3. 【关键】在这里暂停一小会儿，给动画播放的时间
                  await new Promise((resolve) =>
                    setTimeout(resolve, Math.random() * 1800 + 1000)
                  );
                }
              }
            }

            if (callHasBeenHandled && videoCallState.isGroupCall) {
              videoCallState.isAwaitingResponse = false;
              if (videoCallState.participants.length > 0) {
                startVideoCall();
              } else {
                videoCallState = {
                  ...videoCallState,
                  isAwaitingResponse: false,
                  participants: [],
                };
                showScreen("chat-interface-screen");
                alert("无人接听群聊邀请。");
              }
            }

            await db.chats.put(chat);
          } catch (error) {
            chat.history = chat.history.filter((msg) => !msg.isTemporary);
            if (
              !chat.isGroup &&
              chat.relationship?.status === "pending_ai_approval"
            ) {
              chat.relationship.status = "blocked_by_ai";
              await showCustomAlert(
                "申请失败",
                `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`
              );
            } else {
              const errorContent = `[出错了: ${error.message}]`;
              const errorMessage = {
                role: "assistant",
                content: errorContent,
                timestamp: Date.now(),
              };
              if (chat.isGroup) errorMessage.senderName = "系统消息";
              chat.history.push(errorMessage);
            }

            await db.chats.put(chat);
            videoCallState.isAwaitingResponse = false;

            if (
              document
                .getElementById("chat-interface-screen")
                .classList.contains("active") &&
              state.activeChatId === chatId
            ) {
              renderChatInterface(chatId);
            }
          } finally {
            // ★★★★★【核心修改4：在 finally 块中统一隐藏所有类型的提示】★★★★★
            if (chat.isGroup) {
              if (typingIndicator) {
                typingIndicator.style.display = "none";
              }
            } else {
              if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                  chatHeaderTitle.textContent = state.chats[chatId].name;
                  chatHeaderTitle.classList.remove("typing-status");
                  chatHeaderTitle.style.opacity = 1;
                }, 200);
              }
            }
            renderChatList();
          }
        }

        async function sendSticker(sticker) {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          const msg = {
            role: "user",
            content: sticker.url,
            meaning: sticker.name,
            timestamp: Date.now(),
          };
          chat.history.push(msg);
          await db.chats.put(chat);
          appendMessage(msg, chat);
          renderChatList();
          document.getElementById("sticker-panel").classList.remove("visible");
        }

        async function sendUserTransfer() {
          if (!state.activeChatId) return;
          const amountInput = document.getElementById("transfer-amount");
          const noteInput = document.getElementById("transfer-note");
          const amount = parseFloat(amountInput.value);
          const note = noteInput.value.trim();
          if (isNaN(amount) || amount < 0 || amount > 9999) {
            alert("请输入有效的金额 (0 到 9999 之间)！");
            return;
          }
          const chat = state.chats[state.activeChatId];
          const senderName = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";
          const receiverName = chat.isGroup ? "群聊" : chat.name;
          const msg = {
            role: "user",
            type: "transfer",
            amount: amount,
            note: note,
            senderName,
            receiverName,
            timestamp: Date.now(),
          };
          chat.history.push(msg);
          await db.chats.put(chat);
          appendMessage(msg, chat);
          renderChatList();
          document.getElementById("transfer-modal").classList.remove("visible");
          amountInput.value = "";
          noteInput.value = "";
        }

        function enterSelectionMode(initialMsgTimestamp) {
          if (isSelectionMode) return;
          isSelectionMode = true;
          document
            .getElementById("chat-interface-screen")
            .classList.add("selection-mode");
          toggleMessageSelection(initialMsgTimestamp);
        }

        function exitSelectionMode() {
          cleanupWaimaiTimers(); // <--- 在这里添加这行代码
          if (!isSelectionMode) return;
          isSelectionMode = false;
          document
            .getElementById("chat-interface-screen")
            .classList.remove("selection-mode");
          selectedMessages.forEach((ts) => {
            const bubble = document.querySelector(
              `.message-bubble[data-timestamp="${ts}"]`
            );
            if (bubble) bubble.classList.remove("selected");
          });
          selectedMessages.clear();
        }

        // ▼▼▼ 请用这个【最终简化版】替换旧的 toggleMessageSelection 函数 ▼▼▼
        function toggleMessageSelection(timestamp) {
          // 【核心修正】选择器已简化，不再寻找已删除的 .recalled-message-placeholder
          const elementToSelect = document.querySelector(
            `.message-bubble[data-timestamp="${timestamp}"]`
          );

          if (!elementToSelect) return;

          if (selectedMessages.has(timestamp)) {
            selectedMessages.delete(timestamp);
            elementToSelect.classList.remove("selected");
          } else {
            selectedMessages.add(timestamp);
            elementToSelect.classList.add("selected");
          }

          document.getElementById(
            "selection-count"
          ).textContent = `已选 ${selectedMessages.size} 条`;

          if (selectedMessages.size === 0) {
            exitSelectionMode();
          }
        }
        // ▲▲▲ 替换结束 ▲▲▲

        function addLongPressListener(element, callback) {
          let pressTimer;
          const startPress = (e) => {
            if (isSelectionMode) return;
            e.preventDefault();
            pressTimer = window.setTimeout(() => callback(e), 500);
          };
          const cancelPress = () => clearTimeout(pressTimer);
          element.addEventListener("mousedown", startPress);
          element.addEventListener("mouseup", cancelPress);
          element.addEventListener("mouseleave", cancelPress);
          element.addEventListener("touchstart", startPress, { passive: true });
          element.addEventListener("touchend", cancelPress);
          element.addEventListener("touchmove", cancelPress);
        }

        async function handleListenTogetherClick() {
          const targetChatId = state.activeChatId;
          if (!targetChatId) return;
          if (!musicState.isActive) {
            startListenTogetherSession(targetChatId);
            return;
          }
          if (musicState.activeChatId === targetChatId) {
            document
              .getElementById("music-player-overlay")
              .classList.add("visible");
          } else {
            const oldChatName =
              state.chats[musicState.activeChatId]?.name || "未知";
            const newChatName = state.chats[targetChatId]?.name || "当前";
            const confirmed = await showCustomConfirm(
              "切换听歌对象",
              `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`,
              { confirmButtonClass: "btn-danger" }
            );
            if (confirmed) {
              await endListenTogetherSession(true);
              await new Promise((resolve) => setTimeout(resolve, 50));
              startListenTogetherSession(targetChatId);
            }
          }
        }

        async function startListenTogetherSession(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return;
          musicState.totalElapsedTime = chat.musicData.totalTime || 0;
          musicState.isActive = true;
          musicState.activeChatId = chatId;
          if (musicState.playlist.length > 0) {
            musicState.currentIndex = 0;
          } else {
            musicState.currentIndex = -1;
          }
          if (musicState.timerId) clearInterval(musicState.timerId);
          musicState.timerId = setInterval(() => {
            if (musicState.isPlaying) {
              musicState.totalElapsedTime++;
              updateElapsedTimeDisplay();
            }
          }, 1000);
          updatePlayerUI();
          updatePlaylistUI();
          document
            .getElementById("music-player-overlay")
            .classList.add("visible");
        }

        async function endListenTogetherSession(saveState = true) {
          if (!musicState.isActive) return;
          const oldChatId = musicState.activeChatId;
          const cleanupLogic = async () => {
            if (musicState.timerId) clearInterval(musicState.timerId);
            if (musicState.isPlaying) audioPlayer.pause();
            if (saveState && oldChatId && state.chats[oldChatId]) {
              const chat = state.chats[oldChatId];
              chat.musicData.totalTime = musicState.totalElapsedTime;
              await db.chats.put(chat);
            }
            musicState.isActive = false;
            musicState.activeChatId = null;
            musicState.totalElapsedTime = 0;
            musicState.timerId = null;
            updateListenTogetherIcon(oldChatId, true);
          };
          closeMusicPlayerWithAnimation(cleanupLogic);
        }

        function returnToChat() {
          closeMusicPlayerWithAnimation();
        }

        function updateListenTogetherIcon(chatId, forceReset = false) {
          const iconImg = document.querySelector("#listen-together-btn img");
          if (!iconImg) return;
          if (
            forceReset ||
            !musicState.isActive ||
            musicState.activeChatId !== chatId
          ) {
            iconImg.src = "https://i.postimg.cc/8kYShvrJ/90-UI-2.png";
            iconImg.className = "";
            return;
          }
          iconImg.src =
            "https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png";
          iconImg.classList.add("rotating");
          if (musicState.isPlaying) iconImg.classList.remove("paused");
          else iconImg.classList.add("paused");
        }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() {
          updateListenTogetherIcon(musicState.activeChatId);
          updateElapsedTimeDisplay();
          const titleEl = document.getElementById("music-player-song-title");
          const artistEl = document.getElementById("music-player-artist");
          const playPauseBtn = document.getElementById("music-play-pause-btn");
          if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
            const track = musicState.playlist[musicState.currentIndex];
            titleEl.textContent = track.name;
            artistEl.textContent = track.artist;
          } else {
            titleEl.textContent = "请添加歌曲";
            artistEl.textContent = "...";
          }
          playPauseBtn.textContent = musicState.isPlaying ? "❚❚" : "▶";
        }

        function updateElapsedTimeDisplay() {
          const hours = (musicState.totalElapsedTime / 3600).toFixed(1);
          document.getElementById(
            "music-time-counter"
          ).textContent = `已经一起听了${hours}小时`;
        }

        function updatePlaylistUI() {
          const playlistBody = document.getElementById("playlist-body");
          playlistBody.innerHTML = "";
          if (musicState.playlist.length === 0) {
            playlistBody.innerHTML =
              '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
            return;
          }
          musicState.playlist.forEach((track, index) => {
            const item = document.createElement("div");
            item.className = "playlist-item";
            if (index === musicState.currentIndex)
              item.classList.add("playing");
            item.innerHTML = `
            <div class="playlist-item-info">
                <div class="title">${track.name}</div>
                <div class="artist">${track.artist}</div>
            </div>
            <div class="playlist-item-actions">
                <span class="playlist-action-btn lyrics-btn" data-index="${index}">词</span>
                <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
            </div>
        `;
            item
              .querySelector(".playlist-item-info")
              .addEventListener("click", () => playSong(index));
            playlistBody.appendChild(item);
          });
        }

        function playSong(index) {
          if (index < 0 || index >= musicState.playlist.length) return;
          musicState.currentIndex = index;
          const track = musicState.playlist[index];
          musicState.parsedLyrics = parseLRC(track.lrcContent || "");
          musicState.currentLyricIndex = -1;
          renderLyrics();
          if (track.isLocal && track.src instanceof Blob) {
            audioPlayer.src = URL.createObjectURL(track.src);
          } else if (!track.isLocal) {
            audioPlayer.src = track.src;
          } else {
            console.error("本地歌曲源错误:", track);
            return;
          }
          audioPlayer.play();
          updatePlaylistUI();
          updatePlayerUI();
          updateMusicProgressBar();
        }

        function togglePlayPause() {
          if (audioPlayer.paused) {
            if (
              musicState.currentIndex === -1 &&
              musicState.playlist.length > 0
            ) {
              playSong(0);
            } else if (musicState.currentIndex > -1) {
              audioPlayer.play();
            }
          } else {
            audioPlayer.pause();
          }
        }

        function playNext() {
          if (musicState.playlist.length === 0) return;
          let nextIndex;
          switch (musicState.playMode) {
            case "random":
              nextIndex = Math.floor(
                Math.random() * musicState.playlist.length
              );
              break;
            case "single":
              playSong(musicState.currentIndex);
              return;
            case "order":
            default:
              nextIndex =
                (musicState.currentIndex + 1) % musicState.playlist.length;
              break;
          }
          playSong(nextIndex);
        }

        function playPrev() {
          if (musicState.playlist.length === 0) return;
          const newIndex =
            (musicState.currentIndex - 1 + musicState.playlist.length) %
            musicState.playlist.length;
          playSong(newIndex);
        }

        function changePlayMode() {
          const modes = ["order", "random", "single"];
          const currentModeIndex = modes.indexOf(musicState.playMode);
          musicState.playMode = modes[(currentModeIndex + 1) % modes.length];
          document.getElementById("music-mode-btn").textContent = {
            order: "顺序",
            random: "随机",
            single: "单曲",
          }[musicState.playMode];
        }

        async function addSongFromURL() {
          const url = await showCustomPrompt(
            "添加网络歌曲",
            "请输入歌曲的URL",
            "",
            "url"
          );
          if (!url) return;
          const name = await showCustomPrompt("歌曲信息", "请输入歌名");
          if (!name) return;
          const artist = await showCustomPrompt("歌曲信息", "请输入歌手名");
          if (!artist) return;
          musicState.playlist.push({ name, artist, src: url, isLocal: false });
          await saveGlobalPlaylist();
          updatePlaylistUI();
          if (musicState.currentIndex === -1) {
            musicState.currentIndex = musicState.playlist.length - 1;
            updatePlayerUI();
          }
        }

        async function addSongFromLocal(event) {
          const files = event.target.files;
          if (!files.length) return;

          for (const file of files) {
            let name = file.name.replace(/\.[^/.]+$/, "");
            name = await showCustomPrompt("歌曲信息", "请输入歌名", name);
            if (name === null) continue;

            const artist = await showCustomPrompt(
              "歌曲信息",
              "请输入歌手名",
              "未知歌手"
            );
            if (artist === null) continue;

            let lrcContent = "";
            const wantLrc = await showCustomConfirm(
              "导入歌词",
              `要为《${name}》导入歌词文件 (.lrc) 吗？`
            );
            if (wantLrc) {
              lrcContent = await new Promise((resolve) => {
                const lrcInput = document.getElementById("lrc-upload-input");
                const lrcChangeHandler = (e) => {
                  const lrcFile = e.target.files[0];
                  if (lrcFile) {
                    const reader = new FileReader();
                    reader.onload = (readEvent) =>
                      resolve(readEvent.target.result);
                    reader.onerror = () => resolve("");
                    reader.readAsText(lrcFile);
                  } else {
                    resolve("");
                  }
                  lrcInput.removeEventListener("change", lrcChangeHandler);
                  lrcInput.value = "";
                };
                lrcInput.addEventListener("change", lrcChangeHandler);
                lrcInput.click();
              });
            }

            musicState.playlist.push({
              name,
              artist,
              src: file,
              isLocal: true,
              lrcContent: lrcContent,
            });
          }

          await saveGlobalPlaylist();
          updatePlaylistUI();
          if (
            musicState.currentIndex === -1 &&
            musicState.playlist.length > 0
          ) {
            musicState.currentIndex = 0;
            updatePlayerUI();
          }
          event.target.value = null;
        }

        async function deleteTrack(index) {
          if (index < 0 || index >= musicState.playlist.length) return;
          const track = musicState.playlist[index];
          const wasPlaying =
            musicState.isPlaying && musicState.currentIndex === index;
          if (
            track.isLocal &&
            audioPlayer.src.startsWith("blob:") &&
            musicState.currentIndex === index
          )
            URL.revokeObjectURL(audioPlayer.src);
          musicState.playlist.splice(index, 1);
          await saveGlobalPlaylist();
          if (musicState.playlist.length === 0) {
            if (musicState.isPlaying) audioPlayer.pause();
            audioPlayer.src = "";
            musicState.currentIndex = -1;
            musicState.isPlaying = false;
          } else {
            if (wasPlaying) {
              playNext();
            } else {
              if (musicState.currentIndex >= index)
                musicState.currentIndex = Math.max(
                  0,
                  musicState.currentIndex - 1
                );
            }
          }
          updatePlayerUI();
          updatePlaylistUI();
        }

        const personaLibraryModal = document.getElementById(
          "persona-library-modal"
        );
        const personaEditorModal = document.getElementById(
          "persona-editor-modal"
        );
        const presetActionsModal = document.getElementById(
          "preset-actions-modal"
        );

        function openPersonaLibrary() {
          renderPersonaLibrary();
          personaLibraryModal.classList.add("visible");
        }

        function closePersonaLibrary() {
          personaLibraryModal.classList.remove("visible");
        }

        function renderPersonaLibrary() {
          const grid = document.getElementById("persona-library-grid");
          grid.innerHTML = "";
          if (state.personaPresets.length === 0) {
            grid.innerHTML =
              '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>';
            return;
          }
          state.personaPresets.forEach((preset) => {
            const item = document.createElement("div");
            item.className = "persona-preset-item";
            item.style.backgroundImage = `url(${preset.avatar})`;
            item.dataset.presetId = preset.id;
            item.addEventListener("click", () => applyPersonaPreset(preset.id));
            addLongPressListener(item, () => showPresetActions(preset.id));
            grid.appendChild(item);
          });
        }

        function showPresetActions(presetId) {
          editingPersonaPresetId = presetId;
          presetActionsModal.classList.add("visible");
        }

        function hidePresetActions() {
          presetActionsModal.classList.remove("visible");
          editingPersonaPresetId = null;
        }

        function applyPersonaPreset(presetId) {
          const preset = state.personaPresets.find((p) => p.id === presetId);
          if (preset) {
            document.getElementById("my-avatar-preview").src = preset.avatar;
            document.getElementById("my-persona").value = preset.persona;
          }
          closePersonaLibrary();
        }

        function openPersonaEditorForCreate() {
          editingPersonaPresetId = null;
          document.getElementById("persona-editor-title").textContent =
            "添加人设预设";
          document.getElementById("preset-avatar-preview").src = defaultAvatar;
          document.getElementById("preset-persona-input").value = "";
          personaEditorModal.classList.add("visible");
        }

        function openPersonaEditorForEdit() {
          const preset = state.personaPresets.find(
            (p) => p.id === editingPersonaPresetId
          );
          if (!preset) return;
          document.getElementById("persona-editor-title").textContent =
            "编辑人设预设";
          document.getElementById("preset-avatar-preview").src = preset.avatar;
          document.getElementById("preset-persona-input").value =
            preset.persona;
          presetActionsModal.classList.remove("visible");
          personaEditorModal.classList.add("visible");
        }

        async function deletePersonaPreset() {
          const confirmed = await showCustomConfirm(
            "删除预设",
            "确定要删除这个人设预设吗？此操作不可恢复。",
            { confirmButtonClass: "btn-danger" }
          );
          if (confirmed && editingPersonaPresetId) {
            await db.personaPresets.delete(editingPersonaPresetId);
            state.personaPresets = state.personaPresets.filter(
              (p) => p.id !== editingPersonaPresetId
            );
            hidePresetActions();
            renderPersonaLibrary();
          }
        }

        function closePersonaEditor() {
          personaEditorModal.classList.remove("visible");
          editingPersonaPresetId = null;
        }

        async function savePersonaPreset() {
          const avatar = document.getElementById("preset-avatar-preview").src;
          const persona = document
            .getElementById("preset-persona-input")
            .value.trim();
          if (avatar === defaultAvatar && !persona) {
            alert("头像和人设不能都为空哦！");
            return;
          }
          if (editingPersonaPresetId) {
            const preset = state.personaPresets.find(
              (p) => p.id === editingPersonaPresetId
            );
            if (preset) {
              preset.avatar = avatar;
              preset.persona = persona;
              await db.personaPresets.put(preset);
            }
          } else {
            const newPreset = {
              id: "preset_" + Date.now(),
              avatar: avatar,
              persona: persona,
            };
            await db.personaPresets.add(newPreset);
            state.personaPresets.push(newPreset);
          }
          renderPersonaLibrary();
          closePersonaEditor();
        }

        const batteryAlertModal = document.getElementById(
          "battery-alert-modal"
        );

        function showBatteryAlert(imageUrl, text) {
          clearTimeout(batteryAlertTimeout);
          document.getElementById("battery-alert-image").src = imageUrl;
          document.getElementById("battery-alert-text").textContent = text;
          batteryAlertModal.classList.add("visible");
          const closeAlert = () => {
            batteryAlertModal.classList.remove("visible");
            batteryAlertModal.removeEventListener("click", closeAlert);
          };
          batteryAlertModal.addEventListener("click", closeAlert);
          batteryAlertTimeout = setTimeout(closeAlert, 2000);
        }

        function updateBatteryDisplay(battery) {
          const batteryContainer =
            document.getElementById("status-bar-battery");
          const batteryLevelEl =
            batteryContainer.querySelector(".battery-level");
          const batteryTextEl = batteryContainer.querySelector(".battery-text");
          const level = Math.floor(battery.level * 100);
          batteryLevelEl.style.width = `${level}%`;
          batteryTextEl.textContent = `${level}%`;
          if (battery.charging) {
            batteryContainer.classList.add("charging");
          } else {
            batteryContainer.classList.remove("charging");
          }
        }

        function handleBatteryChange(battery) {
          updateBatteryDisplay(battery);
          const level = battery.level;
          if (!battery.charging) {
            if (
              level <= 0.4 &&
              lastKnownBatteryLevel > 0.4 &&
              !alertFlags.hasShown40
            ) {
              showBatteryAlert(
                "https://i.postimg.cc/T2yKJ0DV/40.jpg",
                "有点饿了，可以去找充电器惹"
              );
              alertFlags.hasShown40 = true;
            }
            if (
              level <= 0.2 &&
              lastKnownBatteryLevel > 0.2 &&
              !alertFlags.hasShown20
            ) {
              showBatteryAlert(
                "https://i.postimg.cc/qB9zbKs9/20.jpg",
                "赶紧的充电，要饿死了"
              );
              alertFlags.hasShown20 = true;
            }
            if (
              level <= 0.1 &&
              lastKnownBatteryLevel > 0.1 &&
              !alertFlags.hasShown10
            ) {
              showBatteryAlert(
                "https://i.postimg.cc/ThMMVfW4/10.jpg",
                "已阵亡，还有30秒爆炸"
              );
              alertFlags.hasShown10 = true;
            }
          }
          if (level > 0.4) alertFlags.hasShown40 = false;
          if (level > 0.2) alertFlags.hasShown20 = false;
          if (level > 0.1) alertFlags.hasShown10 = false;
          lastKnownBatteryLevel = level;
        }

        async function initBatteryManager() {
          if ("getBattery" in navigator) {
            try {
              const battery = await navigator.getBattery();
              lastKnownBatteryLevel = battery.level;
              handleBatteryChange(battery);
              battery.addEventListener("levelchange", () =>
                handleBatteryChange(battery)
              );
              battery.addEventListener("chargingchange", () => {
                handleBatteryChange(battery);
                if (battery.charging) {
                  showBatteryAlert(
                    "https://i.postimg.cc/3NDQ0dWG/image.jpg",
                    "窝爱泥，电量吃饱饱"
                  );
                }
              });
            } catch (err) {
              console.error("无法获取电池信息:", err);
              document.querySelector(".battery-text").textContent = "ᗜωᗜ";
            }
          } else {
            console.log("浏览器不支持电池状态API。");
            document.querySelector(".battery-text").textContent = "ᗜωᗜ";
          }
        }

        async function renderAlbumList() {
          const albumGrid = document.getElementById("album-grid-page");
          if (!albumGrid) return;
          const albums = await db.qzoneAlbums
            .orderBy("createdAt")
            .reverse()
            .toArray();
          albumGrid.innerHTML = "";
          if (albums.length === 0) {
            albumGrid.innerHTML =
              '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
            return;
          }
          albums.forEach((album) => {
            const albumItem = document.createElement("div");
            albumItem.className = "album-item";
            albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${
                      album.coverUrl
                    });"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} 张</p>
                    </div>
                `;
            albumItem.addEventListener("click", () => {
              openAlbum(album.id);
            });

            // ▼▼▼ 新增的核心代码就是这里 ▼▼▼
            addLongPressListener(albumItem, async () => {
              const confirmed = await showCustomConfirm(
                "删除相册",
                `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`,
                { confirmButtonClass: "btn-danger" }
              );

              if (confirmed) {
                // 1. 从照片表中删除该相册下的所有照片
                await db.qzonePhotos.where("albumId").equals(album.id).delete();

                // 2. 从相册表中删除该相册本身
                await db.qzoneAlbums.delete(album.id);

                // 3. 重新渲染相册列表
                await renderAlbumList();

                alert("相册已成功删除。");
              }
            });
            // ▲▲▲ 新增代码结束 ▲▲▲

            albumGrid.appendChild(albumItem);
          });
        }

        async function openAlbum(albumId) {
          state.activeAlbumId = albumId;
          await renderAlbumPhotosScreen();
          showScreen("album-photos-screen");
        }

        async function renderAlbumPhotosScreen() {
          if (!state.activeAlbumId) return;
          const photosGrid = document.getElementById("photos-grid-page");
          const headerTitle = document.getElementById("album-photos-title");
          const album = await db.qzoneAlbums.get(state.activeAlbumId);
          if (!album) {
            console.error("找不到相册:", state.activeAlbumId);
            showScreen("album-screen");
            return;
          }
          headerTitle.textContent = album.name;
          const photos = await db.qzonePhotos
            .where("albumId")
            .equals(state.activeAlbumId)
            .toArray();
          photosGrid.innerHTML = "";
          if (photos.length === 0) {
            photosGrid.innerHTML =
              '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">这个相册还是空的，快上传第一张照片吧！</p>';
          } else {
            photos.forEach((photo) => {
              const photoItem = document.createElement("div");
              photoItem.className = "photo-item";
              photoItem.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                        <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                    `;
              photosGrid.appendChild(photoItem);
            });
          }
        }

        // --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

        /**
         * 打开图片查看器
         * @param {string} clickedPhotoUrl - 用户点击的那张照片的URL
         */
        async function openPhotoViewer(clickedPhotoUrl) {
          if (!state.activeAlbumId) return;

          // 1. 从数据库获取当前相册的所有照片
          const photosInAlbum = await db.qzonePhotos
            .where("albumId")
            .equals(state.activeAlbumId)
            .toArray();
          photoViewerState.photos = photosInAlbum.map((p) => p.url);

          // 2. 找到被点击照片的索引
          photoViewerState.currentIndex = photoViewerState.photos.findIndex(
            (url) => url === clickedPhotoUrl
          );
          if (photoViewerState.currentIndex === -1) return; // 如果找不到，则不打开

          // 3. 显示模态框并渲染第一张图
          document
            .getElementById("photo-viewer-modal")
            .classList.add("visible");
          renderPhotoViewer();
          photoViewerState.isOpen = true;
        }

        /**
         * 根据当前状态渲染查看器内容（图片和按钮）
         */
        function renderPhotoViewer() {
          if (photoViewerState.currentIndex === -1) return;

          const imageEl = document.getElementById("photo-viewer-image");
          const prevBtn = document.getElementById("photo-viewer-prev-btn");
          const nextBtn = document.getElementById("photo-viewer-next-btn");

          // 淡出效果
          imageEl.style.opacity = 0;

          setTimeout(() => {
            // 更新图片源
            imageEl.src =
              photoViewerState.photos[photoViewerState.currentIndex];
            // 淡入效果
            imageEl.style.opacity = 1;
          }, 100); // 延迟一点点时间来触发CSS过渡

          // 更新按钮状态：如果是第一张，禁用“上一张”按钮
          prevBtn.disabled = photoViewerState.currentIndex === 0;
          // 如果是最后一张，禁用“下一张”按钮
          nextBtn.disabled =
            photoViewerState.currentIndex ===
            photoViewerState.photos.length - 1;
        }

        /**
         * 显示下一张照片
         */
        function showNextPhoto() {
          if (
            photoViewerState.currentIndex <
            photoViewerState.photos.length - 1
          ) {
            photoViewerState.currentIndex++;
            renderPhotoViewer();
          }
        }

        /**
         * 显示上一张照片
         */
        function showPrevPhoto() {
          if (photoViewerState.currentIndex > 0) {
            photoViewerState.currentIndex--;
            renderPhotoViewer();
          }
        }

        /**
         * 关闭图片查看器
         */
        function closePhotoViewer() {
          document
            .getElementById("photo-viewer-modal")
            .classList.remove("visible");
          photoViewerState.isOpen = false;
          photoViewerState.photos = [];
          photoViewerState.currentIndex = -1;
          // 清空图片，避免下次打开时闪现旧图
          document.getElementById("photo-viewer-image").src = "";
        }

        // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
        // ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼

        /**
         * 更新动态小红点的显示
         * @param {number} count - 未读动态的数量
         */
        function updateUnreadIndicator(count) {
          unreadPostsCount = count;
          localStorage.setItem("unreadPostsCount", count); // 持久化存储

          // --- 更新底部导航栏的“动态”按钮 ---
          const navItem = document.querySelector(
            '.nav-item[data-view="qzone-screen"]'
          );

          const targetSpan = navItem.querySelector("span"); // 定位到文字 "动态"
          let indicator = navItem.querySelector(".unread-indicator");

          if (count > 0) {
            if (!indicator) {
              indicator = document.createElement("span");
              indicator.className = "unread-indicator";
              targetSpan.style.position = "relative"; // 把相对定位加在 span 上
              targetSpan.appendChild(indicator); // 把小红点作为 span 的子元素
            }
            indicator.textContent = count > 99 ? "99+" : count;
            indicator.style.display = "block";
          } else {
            if (indicator) {
              indicator.style.display = "none";
            }
          }

          // --- 更新聊天界面返回列表的按钮 ---
          const backBtn = document.getElementById("back-to-list-btn");
          let backBtnIndicator = backBtn.querySelector(".unread-indicator");

          if (count > 0) {
            if (!backBtnIndicator) {
              backBtnIndicator = document.createElement("span");
              backBtnIndicator.className =
                "unread-indicator back-btn-indicator";
              backBtn.style.position = "relative"; // 确保能正确定位
              backBtn.appendChild(backBtnIndicator);
            }
            // 返回键上的小红点通常不显示数字，只显示一个点
            backBtnIndicator.style.display = "block";
          } else {
            if (backBtnIndicator) {
              backBtnIndicator.style.display = "none";
            }
          }
        }

        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        // ▼▼▼ 将这两个新函数粘贴到你的JS功能函数定义区 ▼▼▼
        function startBackgroundSimulation() {
          if (simulationIntervalId) return;
          const intervalSeconds =
            state.globalSettings.backgroundActivityInterval || 60;
          // 将旧的固定间隔 45000 替换为动态获取
          simulationIntervalId = setInterval(
            runBackgroundSimulationTick,
            intervalSeconds * 1000
          );
        }

        function stopBackgroundSimulation() {
          if (simulationIntervalId) {
            clearInterval(simulationIntervalId);
            simulationIntervalId = null;
          }
        }
        // ▲▲▲ 粘贴结束 ▲▲▲

        /**
         * 这是模拟器的“心跳”，每次定时器触发时运行
         */
        function runBackgroundSimulationTick() {
          console.log("模拟器心跳 Tick...");
          if (!state.globalSettings.enableBackgroundActivity) {
            stopBackgroundSimulation();
            return;
          }
          const allSingleChats = Object.values(state.chats).filter(
            (chat) => !chat.isGroup
          );

          if (allSingleChats.length === 0) return;

          allSingleChats.forEach((chat) => {
            // 【核心修正】将两种状态检查分离开，逻辑更清晰

            // 检查1：处理【被用户拉黑】的角色
            if (chat.relationship?.status === "blocked_by_user") {
              const blockedTimestamp = chat.relationship.blockedTimestamp;
              // 安全检查：确保有拉黑时间戳
              if (!blockedTimestamp) {
                console.warn(
                  `角色 "${chat.name}" 状态为拉黑，但缺少拉黑时间戳，跳过处理。`
                );
                return; // 跳过这个角色，继续下一个
              }

              const blockedDuration = Date.now() - blockedTimestamp;
              const cooldownMilliseconds =
                (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;

              console.log(
                `检查角色 "${chat.name}"：已拉黑 ${Math.round(
                  blockedDuration / 1000 / 60
                )}分钟，冷静期需 ${cooldownMilliseconds / 1000 / 60}分钟。`
              ); // 添加日志

              // 【核心修改】移除了随机概率，只要冷静期一过，就触发！
              if (blockedDuration > cooldownMilliseconds) {
                console.log(
                  `角色 "${chat.name}" 的冷静期已过，触发“反思”并申请好友事件...`
                );

                // 【重要】为了防止在AI响应前重复触发，我们在触发后立刻更新状态
                chat.relationship.status = "pending_system_reflection"; // 设置一个临时的、防止重复触发的状态

                triggerAiFriendApplication(chat.id);
              }
            }
            // 检查2：处理【好友关系】的正常后台活动
            else if (
              chat.relationship?.status === "friend" &&
              chat.id !== state.activeChatId
            ) {
              // 这里的随机触发逻辑保持不变，因为我们不希望所有好友同时行动
              if (Math.random() < 0.2) {
                console.log(`角色 "${chat.name}" 被唤醒，准备独立行动...`);
                triggerInactiveAiAction(chat.id);
              }
            }
          });
        }

        async function triggerInactiveAiAction(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return;

          const { proxyUrl, apiKey, model } = getActiveApiConfig() || {};
          if (!proxyUrl || !apiKey || !model) return;

          const now = new Date();
          const currentTime = now.toLocaleTimeString("zh-CN", {
            hour: "numeric",
            minute: "numeric",
            hour12: true,
          });
          const userNickname = state.qzoneSettings.nickname;

          const lastUserMessage = chat.history
            .filter((m) => m.role === "user" && !m.isHidden)
            .slice(-1)[0];
          const lastAiMessage = chat.history
            .filter((m) => m.role === "assistant" && !m.isHidden)
            .slice(-1)[0];
          let recentContextSummary = "你们最近没有聊过天。";
          if (lastUserMessage) {
            recentContextSummary = `用户 (${userNickname}) 最后对你说：“${String(
              lastUserMessage.content
            ).substring(0, 50)}...”。`;
          }
          if (lastAiMessage) {
            recentContextSummary += `\n你最后对用户说：“${String(
              lastAiMessage.content
            ).substring(0, 50)}...”。`;
          }

          // ▼▼▼ 在这里添加下面的代码 ▼▼▼
          let worldBookContent = "";
          if (
            chat.settings.linkedWorldBookIds &&
            chat.settings.linkedWorldBookIds.length > 0
          ) {
            const linkedContents = chat.settings.linkedWorldBookIds
              .map((bookId) => {
                const worldBook = state.worldBooks.find(
                  (wb) => wb.id === bookId
                );
                return worldBook && worldBook.content
                  ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}`
                  : "";
              })
              .filter(Boolean)
              .join("");
            if (linkedContents) {
              worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
            }
          }
          // ▲▲▲ 添加结束 ▲▲▲

          const systemPrompt = `
# 你的任务
你现在扮演一个名为"${chat.name}"的角色。你已经有一段时间没有和用户（${userNickname}）互动了，现在你有机会【主动】做点什么，来表现你的个性和独立生活。这是一个秘密的、后台的独立行动。

# 你的可选行动 (请根据你的人设【选择一项】执行):
1.  **改变状态**: 去做点别的事情，然后给用户发条消息。
2.  **发布动态**: 分享你的心情或想法到“动态”区。
3.  **与动态互动**: 去看看别人的帖子并进行评论或点赞。
4.  **发起视频通话**: 如果你觉得时机合适，可以主动给用户打一个视频电话。

# 指令格式 (你的回复【必须】是包含一个对象的JSON数组):
-   **发消息+更新状态**: \`[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}, {"type": "text", "content": "你想对用户说的话..."}]\`
-   **发说说**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}]\`
- **发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}\`
-   **评论**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "你的评论内容"}]\`
-   **点赞**: \`[{"type": "qzone_like", "postId": 456}]\`
-   **打视频**: \`[{"type": "video_call_request"}]\`

# 供你决策的参考信息：
-   **你的角色设定**: ${chat.settings.aiPersona}
${worldBookContent} // <--【核心】在这里注入世界书内容
-   **当前时间**: ${currentTime}
-   **你们最后的对话摘要**: ${recentContextSummary}
-   **【重要】最近的动态列表**: 这个列表会标注 **[你已点赞]** 或 **[你已评论]**。请**优先**与你**尚未互动过**的动态进行交流。`;

          // 【核心修复】在这里构建 messagesPayload
          const messagesPayload = [];
          messagesPayload.push({ role: "system", content: systemPrompt });

          try {
            const allRecentPosts = await db.qzonePosts
              .orderBy("timestamp")
              .reverse()
              .limit(3)
              .toArray();
            // 【核心修改】在这里插入过滤步骤
            const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

            const aiName = chat.name;

            let dynamicContext = "";
            if (visiblePosts.length > 0) {
              let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
              for (const post of visiblePosts) {
                let authorName =
                  post.authorId === "user"
                    ? userNickname
                    : state.chats[post.authorId]?.name || "一位朋友";
                let interactionStatus = "";
                if (post.likes && post.likes.includes(aiName))
                  interactionStatus += " [你已点赞]";
                if (
                  post.comments &&
                  post.comments.some((c) => c.commenterName === aiName)
                )
                  interactionStatus += " [你已评论]";

                postsContext += `- (ID: ${
                  post.id
                }) 作者: ${authorName}, 内容: "${(
                  post.publicText ||
                  post.content ||
                  "图片动态"
                ).substring(0, 30)}..."${interactionStatus}\n`;
              }
              dynamicContext = postsContext;
            }

            // 【核心修复】将所有动态信息作为一条 user 消息发送
            messagesPayload.push({
              role: "user",
              content: `[系统指令：请根据你在 system prompt 中读到的规则和以下最新信息，开始你的独立行动。]\n${dynamicContext}`,
            });

            console.log(
              "正在为后台活动发送API请求，Payload:",
              JSON.stringify(messagesPayload, null, 2)
            ); // 添加日志，方便调试

            // 发送请求
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesPayload,
              isGemini
            );
            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: 0.9,
                  }),
                });

            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(
                `API请求失败: ${response.status} - ${JSON.stringify(errorData)}`
              );
            }
            const data = await response.json();
            // 检查是否有有效回复
            if (
              !data.choices ||
              data.choices.length === 0 ||
              !data.choices[0].message.content
            ) {
              console.warn(
                `API为空回或格式不正确，角色 "${chat.name}" 的本次后台活动跳过。`
              );
              return;
            }
            const responseArray = parseAiResponse(
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content
            );

            // 后续处理AI返回指令的逻辑保持不变...
            for (const action of responseArray) {
              if (!action) continue;

              if (action.type === "update_status" && action.status_text) {
                chat.status.text = action.status_text;
                chat.status.isBusy = action.is_busy || false;
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
                renderChatList();
              }
              if (action.type === "text" && action.content) {
                const aiMessage = {
                  role: "assistant",
                  content: String(action.content).trim(),
                  timestamp: Date.now(),
                };

                chat.unreadCount = (chat.unreadCount || 0) + 1;
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showNotification(chatId, aiMessage.content);
                renderChatList();
                console.log(
                  `后台活动: 角色 "${chat.name}" 主动发送了消息: ${aiMessage.content}`
                );
              }
              if (action.type === "qzone_post") {
                const newPost = {
                  type: action.postType,
                  content: String(action.content || "").trim(),
                  publicText: String(action.publicText || "").trim(),
                  hiddenContent: String(action.hiddenContent || "").trim(),
                  timestamp: Date.now(),
                  authorId: chatId,
                  authorGroupId: chat.groupId, // 【核心新增】记录作者的分组ID
                  visibleGroupIds: null,
                };
                await db.qzonePosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`后台活动: 角色 "${chat.name}" 发布了动态`);
              } else if (action.type === "qzone_comment") {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                  if (!post.comments) post.comments = [];
                  post.comments.push({
                    commenterName: chat.name,
                    text: String(action.commentText || "").trim(),
                    timestamp: Date.now(),
                  });
                  await db.qzonePosts.update(post.id, {
                    comments: post.comments,
                  });
                  updateUnreadIndicator(unreadPostsCount + 1);
                  console.log(
                    `后台活动: 角色 "${chat.name}" 评论了动态 #${post.id}`
                  );
                }
              } else if (action.type === "qzone_like") {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                  if (!post.likes) post.likes = [];
                  if (!post.likes.includes(chat.name)) {
                    post.likes.push(chat.name);
                    await db.qzonePosts.update(post.id, { likes: post.likes });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    console.log(
                      `后台活动: 角色 "${chat.name}" 点赞了动态 #${post.id}`
                    );
                  }
                }
              } else if (action.type === "video_call_request") {
                if (
                  !videoCallState.isActive &&
                  !videoCallState.isAwaitingResponse
                ) {
                  videoCallState.isAwaitingResponse = true;
                  state.activeChatId = chatId;
                  showIncomingCallModal();
                  console.log(
                    `后台活动: 角色 "${chat.name}" 发起了视频通话请求`
                  );
                }
              }
            }
          } catch (error) {
            console.error(`角色 "${chat.name}" 的独立行动失败:`, error);
          }
        }

        // ▼▼▼ 请用这个【终极修正版】函数，完整替换掉你旧的 applyScopedCss 函数 ▼▼▼

        /**
         * 将用户自定义的CSS安全地应用到指定的作用域
         * @param {string} cssString 用户输入的原始CSS字符串
         * @param {string} scopeId 应用样式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
         * @param {string} styleTagId 要操作的 <style> 标签的ID
         */
        function applyScopedCss(cssString, scopeId, styleTagId) {
          const styleTag = document.getElementById(styleTagId);
          if (!styleTag) return;

          if (!cssString || cssString.trim() === "") {
            styleTag.innerHTML = "";
            return;
          }

          // 增强作用域处理函数 - 专门解决.user和.ai样式冲突问题
          const scopedCss = cssString
            .replace(
              /\s*\.message-bubble\.user\s+([^{]+\{)/g,
              `${scopeId} .message-bubble.user $1`
            )
            .replace(
              /\s*\.message-bubble\.ai\s+([^{]+\{)/g,
              `${scopeId} .message-bubble.ai $1`
            )
            .replace(
              /\s*\.message-bubble\s+([^{]+\{)/g,
              `${scopeId} .message-bubble $1`
            );

          styleTag.innerHTML = scopedCss;
        }

        // ▼▼▼ 请用这个【修正版】函数，完整替换掉旧的 updateSettingsPreview 函数 ▼▼▼

        function updateSettingsPreview() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          const previewArea = document.getElementById("settings-preview-area");
          if (!previewArea) return;

          // 1. 获取当前设置的值
          const selectedTheme =
            document.querySelector('input[name="theme-select"]:checked')
              ?.value || "default";
          const fontSize = document.getElementById("font-size-slider").value;
          const customCss = document.getElementById("custom-css-input").value;
          const background = chat.settings.background; // 直接获取背景设置

          // 2. 更新预览区的基本样式
          previewArea.dataset.theme = selectedTheme;
          previewArea.style.setProperty("--chat-font-size", `${fontSize}px`);

          // --- 【核心修正】直接更新预览区的背景样式 ---
          if (background && background.startsWith("data:image")) {
            previewArea.style.backgroundImage = `url(${background})`;
            previewArea.style.backgroundColor = "transparent"; // 如果有图片，背景色设为透明
          } else {
            previewArea.style.backgroundImage = "none"; // 如果没有图片，移除图片背景
            // 如果背景是颜色值或渐变（非图片），则直接应用
            previewArea.style.background = background || "#f0f2f5";
          }

          // 3. 渲染模拟气泡
          previewArea.innerHTML = "";

          // 创建“对方”的气泡
          // 注意：我们将一个虚拟的 timestamp 传入，以防有CSS依赖于它
          const aiMsg = {
            role: "ai",
            content: "对方消息预览",
            timestamp: 1,
            senderName: chat.name,
          };
          const aiBubble = createMessageElement(aiMsg, chat);
          if (aiBubble) previewArea.appendChild(aiBubble);

          // 创建“我”的气泡
          const userMsg = {
            role: "user",
            content: "我的消息预览",
            timestamp: 2,
          };
          const userBubble = createMessageElement(userMsg, chat);
          if (userBubble) previewArea.appendChild(userBubble);

          // 4. 应用自定义CSS到预览区
          applyScopedCss(
            customCss,
            "#settings-preview-area",
            "preview-bubble-style"
          );
        }

        // ▲▲▲ 替换结束 ▲▲▲

        // ▼▼▼ 请将这些【新函数】粘贴到JS功能函数定义区 ▼▼▼

        async function openGroupManager() {
          await renderGroupList();
          document
            .getElementById("group-management-modal")
            .classList.add("visible");
        }

        async function renderGroupList() {
          const listEl = document.getElementById("existing-groups-list");
          const groups = await db.qzoneGroups.toArray();
          listEl.innerHTML = "";
          if (groups.length === 0) {
            listEl.innerHTML =
              '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
          }
          groups.forEach((group) => {
            const item = document.createElement("div");
            item.className = "existing-group-item";
            item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">×</span>
        `;
            listEl.appendChild(item);
          });
        }

        // ▼▼▼ 请用这个【修正后】的函数，完整替换旧的 addNewGroup 函数 ▼▼▼
        async function addNewGroup() {
          const input = document.getElementById("new-group-name-input");
          const name = input.value.trim();
          if (!name) {
            alert("分组名不能为空！");
            return;
          }

          // 【核心修正】在添加前，先检查分组名是否已存在
          const existingGroup = await db.qzoneGroups
            .where("name")
            .equals(name)
            .first();
          if (existingGroup) {
            alert(`分组 "${name}" 已经存在了，换个名字吧！`);
            return;
          }
          // 【修正结束】

          await db.qzoneGroups.add({ name });
          input.value = "";
          await renderGroupList();
        }
        // ▲▲▲ 替换结束 ▲▲▲

        async function deleteGroup(groupId) {
          const confirmed = await showCustomConfirm(
            "确认删除",
            "删除分组后，该组内的好友将变为“未分组”。确定要删除吗？",
            { confirmButtonClass: "btn-danger" }
          );
          if (confirmed) {
            await db.qzoneGroups.delete(groupId);
            // 将属于该分组的好友的 groupId 设为 null
            const chatsToUpdate = await db.chats
              .where("groupId")
              .equals(groupId)
              .toArray();
            for (const chat of chatsToUpdate) {
              chat.groupId = null;
              await db.chats.put(chat);
              if (state.chats[chat.id]) state.chats[chat.id].groupId = null;
            }
            await renderGroupList();
          }
        }

        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        // ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

        /**
         * 当长按消息时，显示操作菜单
         * @param {number} timestamp - 被长按消息的时间戳
         */
        function showMessageActions(timestamp) {
          // 如果已经在多选模式，则不弹出菜单
          if (isSelectionMode) return;

          activeMessageTimestamp = timestamp;
          document
            .getElementById("message-actions-modal")
            .classList.add("visible");
        }

        /**
         * 隐藏消息操作菜单
         */
        function hideMessageActions() {
          document
            .getElementById("message-actions-modal")
            .classList.remove("visible");
          activeMessageTimestamp = null;
        }

        // ▼▼▼ 用这个【已更新】的版本，替换旧的 openMessageEditor 函数 ▼▼▼
        async function openMessageEditor() {
          if (!activeMessageTimestamp) return;

          const timestampToEdit = activeMessageTimestamp;
          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === timestampToEdit
          );
          if (!message) return;

          hideMessageActions();

          let contentForEditing;
          // 【核心修正】将 share_link 也加入特殊类型判断
          const isSpecialType =
            message.type &&
            ["voice_message", "ai_image", "transfer", "share_link"].includes(
              message.type
            );

          if (isSpecialType) {
            let fullMessageObject = { type: message.type };
            if (message.type === "voice_message")
              fullMessageObject.content = message.content;
            else if (message.type === "ai_image")
              fullMessageObject.description = message.content;
            else if (message.type === "transfer") {
              fullMessageObject.amount = message.amount;
              fullMessageObject.note = message.note;
            }
            // 【核心修正】处理分享链接类型的消息
            else if (message.type === "share_link") {
              fullMessageObject.title = message.title;
              fullMessageObject.description = message.description;
              fullMessageObject.source_name = message.source_name;
              fullMessageObject.content = message.content;
            }
            contentForEditing = JSON.stringify(fullMessageObject, null, 2);
          } else if (typeof message.content === "object") {
            contentForEditing = JSON.stringify(message.content, null, 2);
          } else {
            contentForEditing = message.content;
          }

          // 【核心修改1】在这里添加 'link' 模板
          const templates = {
            voice: { type: "voice_message", content: "在这里输入语音内容" },
            image: { type: "ai_image", description: "在这里输入图片描述" },
            transfer: { type: "transfer", amount: 5.2, note: "一点心意" },
            link: {
              type: "share_link",
              title: "文章标题",
              description: "文章摘要...",
              source_name: "来源网站",
              content: "文章完整内容...",
            },
          };

          // 【核心修改2】在这里添加新的“链接”按钮
          const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(
              templates.voice
            )}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(
              templates.image
            )}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(
              templates.transfer
            )}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(
              templates.link
            )}'>链接</button>
        </div>
    `;

          const newContent = await showCustomPrompt(
            "编辑消息",
            "在此修改，或点击上方按钮使用格式模板...",
            contentForEditing,
            "textarea",
            helpersHtml
          );

          if (newContent !== null) {
            // 【核心修正】这里调用的应该是 saveEditedMessage，而不是 saveAdvancedEditor
            await saveEditedMessage(timestampToEdit, newContent, true);
          }
        }
        // ▲▲▲ 替换结束 ▲▲▲

        /**
         * 复制消息的文本内容到剪贴板
         */
        async function copyMessageContent() {
          if (!activeMessageTimestamp) return;
          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === activeMessageTimestamp
          );
          if (!message) return;

          let textToCopy;
          if (typeof message.content === "object") {
            textToCopy = JSON.stringify(message.content);
          } else {
            textToCopy = String(message.content);
          }

          try {
            await navigator.clipboard.writeText(textToCopy);
            await showCustomAlert("复制成功", "消息内容已复制到剪贴板。");
          } catch (err) {
            await showCustomAlert("复制失败", "无法访问剪贴板。");
          }

          hideMessageActions();
        }

        // ▼▼▼ 用这个【已更新】的版本，替换旧的 createMessageEditorBlock 函数 ▼▼▼
        /**
         * 创建一个可编辑的消息块（包含文本框、格式助手和删除按钮）
         * @param {string} initialContent - 文本框的初始内容
         * @returns {HTMLElement} - 创建好的DOM元素
         */
        function createMessageEditorBlock(initialContent = "") {
          const block = document.createElement("div");
          block.className = "message-editor-block";

          // 【核心修改1】在这里添加 'link' 模板
          const templates = {
            voice: { type: "voice_message", content: "在这里输入语音内容" },
            image: { type: "ai_image", description: "在这里输入图片描述" },
            transfer: { type: "transfer", amount: 5.2, note: "一点心意" },
            link: {
              type: "share_link",
              title: "文章标题",
              description: "文章摘要...",
              source_name: "来源网站",
              content: "文章完整内容...",
            },
          };

          block.innerHTML = `
        <button class="delete-block-btn" title="删除此条">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(
              templates.voice
            )}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(
              templates.image
            )}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(
              templates.transfer
            )}'>转账</button>
            <!-- 【核心修改2】在这里添加新的“链接”按钮 -->
            <button class="format-btn" data-template='${JSON.stringify(
              templates.link
            )}'>链接</button>
        </div>
    `;

          // 绑定删除按钮事件
          block
            .querySelector(".delete-block-btn")
            .addEventListener("click", () => {
              // 确保至少保留一个编辑块
              if (
                document.querySelectorAll(".message-editor-block").length > 1
              ) {
                block.remove();
              } else {
                alert("至少需要保留一条消息。");
              }
            });

          // 绑定格式助手按钮事件
          block.querySelectorAll(".format-btn").forEach((btn) => {
            btn.addEventListener("click", () => {
              const templateStr = btn.dataset.template;
              const textarea = block.querySelector("textarea");
              if (templateStr && textarea) {
                try {
                  const templateObj = JSON.parse(templateStr);
                  textarea.value = JSON.stringify(templateObj, null, 2);
                  textarea.focus();
                } catch (e) {
                  console.error("解析格式模板失败:", e);
                }
              }
            });
          });

          return block;
        }
        // ▲▲▲ 替换结束 ▲▲▲

        // ▼▼▼ 【全新升级版】请用此函数完整替换旧的 openAdvancedMessageEditor ▼▼▼
        /**
         * 打开全新的、可视化的多消息编辑器，并动态绑定其所有按钮事件
         */
        function openAdvancedMessageEditor() {
          if (!activeMessageTimestamp) return;

          // 1. 【核心】在关闭旧菜单前，将需要的时间戳捕获到局部变量中
          const timestampToEdit = activeMessageTimestamp;

          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === timestampToEdit
          );
          if (!message) return;

          // 2. 现在可以安全地关闭旧菜单了，因为它不会影响我们的局部变量
          hideMessageActions();

          const editorModal = document.getElementById("message-editor-modal");
          const editorContainer = document.getElementById(
            "message-editor-container"
          );
          editorContainer.innerHTML = "";

          // 3. 准备初始内容
          let initialContent;
          const isSpecialType =
            message.type &&
            ["voice_message", "ai_image", "transfer"].includes(message.type);
          if (isSpecialType) {
            let fullMessageObject = { type: message.type };
            if (message.type === "voice_message")
              fullMessageObject.content = message.content;
            else if (message.type === "ai_image")
              fullMessageObject.description = message.content;
            else if (message.type === "transfer") {
              fullMessageObject.amount = message.amount;
              fullMessageObject.note = message.note;
            }
            initialContent = JSON.stringify(fullMessageObject, null, 2);
          } else if (typeof message.content === "object") {
            initialContent = JSON.stringify(message.content, null, 2);
          } else {
            initialContent = message.content;
          }

          const firstBlock = createMessageEditorBlock(initialContent);
          editorContainer.appendChild(firstBlock);

          // 4. 【核心】动态绑定所有控制按钮的事件
          // 为了防止事件重复绑定，我们使用克隆节点的方法来清除旧监听器
          const addBtn = document.getElementById(
            "add-message-editor-block-btn"
          );
          const newAddBtn = addBtn.cloneNode(true);
          addBtn.parentNode.replaceChild(newAddBtn, addBtn);
          newAddBtn.addEventListener("click", () => {
            const newBlock = createMessageEditorBlock();
            editorContainer.appendChild(newBlock);
            newBlock.querySelector("textarea").focus();
          });

          const cancelBtn = document.getElementById(
            "cancel-advanced-editor-btn"
          );
          const newCancelBtn = cancelBtn.cloneNode(true);
          cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
          newCancelBtn.addEventListener("click", () => {
            editorModal.classList.remove("visible");
          });

          const saveBtn = document.getElementById("save-advanced-editor-btn");
          const newSaveBtn = saveBtn.cloneNode(true);
          saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
          // 将捕获到的时间戳，直接绑定给这一次的保存点击事件
          newSaveBtn.addEventListener("click", () => {
            saveEditedMessage(timestampToEdit);
          });

          // 5. 最后，显示模态框
          editorModal.classList.add("visible");
        }
        // ▲▲▲ 替换结束 ▲▲▲

        /**
         * 解析编辑后的文本，并返回一个标准化的消息片段对象
         * @param {string} text - 用户在编辑框中输入的文本
         * @returns {object} - 一个包含 type, content, 等属性的对象
         */
        function parseEditedContent(text) {
          const trimmedText = text.trim();

          // 1. 尝试解析为JSON对象（用于修复语音、转账等格式）
          if (trimmedText.startsWith("{") && trimmedText.endsWith("}")) {
            try {
              const parsed = JSON.parse(trimmedText);
              // 必须包含 type 属性才认为是有效格式
              if (parsed.type) {
                return parsed;
              }
            } catch (e) {
              /* 解析失败，继续往下走 */
            }
          }

          // 2. 尝试解析为表情包
          if (STICKER_REGEX.test(trimmedText)) {
            // 对于编辑的表情，我们暂时无法知道其`meaning`，所以只存URL
            return { type: "sticker", content: trimmedText };
          }

          // 3. 否则，视为普通文本消息
          return { type: "text", content: trimmedText };
        }

        // ▼▼▼ 请用这个【已彻底修复】的函数，完整替换你现有的 saveEditedMessage 函数 ▼▼▼

        async function saveEditedMessage(timestamp, simpleContent = null) {
          if (!timestamp) return;

          const chat = state.chats[state.activeChatId];
          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === timestamp
          );
          if (messageIndex === -1) return;

          let newMessages = [];

          // 判断是来自高级编辑器还是简单编辑器
          if (simpleContent !== null) {
            // --- 来自简单编辑器 ---
            const rawContent = simpleContent.trim();
            if (rawContent) {
              const parsedResult = parseEditedContent(rawContent);
              const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                // 注意：这里我们暂时不设置时间戳
                content: parsedResult.content || "",
              };
              if (parsedResult.type && parsedResult.type !== "text")
                newMessage.type = parsedResult.type;
              if (parsedResult.meaning)
                newMessage.meaning = parsedResult.meaning;
              if (parsedResult.amount) newMessage.amount = parsedResult.amount;
              if (parsedResult.note) newMessage.note = parsedResult.note;
              if (parsedResult.title) newMessage.title = parsedResult.title;
              if (parsedResult.description)
                newMessage.description = parsedResult.description;
              if (parsedResult.source_name)
                newMessage.source_name = parsedResult.source_name;
              if (
                parsedResult.description &&
                parsedResult.type === "ai_image"
              ) {
                newMessage.content = parsedResult.description;
              }

              newMessages.push(newMessage);
            }
          } else {
            // --- 来自高级编辑器 ---
            const editorContainer = document.getElementById(
              "message-editor-container"
            );
            const editorBlocks = editorContainer.querySelectorAll(
              ".message-editor-block"
            );

            for (const block of editorBlocks) {
              const textarea = block.querySelector("textarea");
              const rawContent = textarea.value.trim();
              if (!rawContent) continue;

              const parsedResult = parseEditedContent(rawContent);
              const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                // 同样，这里我们先不分配时间戳
                content: parsedResult.content || "",
              };

              if (parsedResult.type && parsedResult.type !== "text")
                newMessage.type = parsedResult.type;
              if (parsedResult.meaning)
                newMessage.meaning = parsedResult.meaning;
              if (parsedResult.amount) newMessage.amount = parsedResult.amount;
              if (parsedResult.note) newMessage.note = parsedResult.note;
              if (parsedResult.title) newMessage.title = parsedResult.title;
              if (parsedResult.description)
                newMessage.description = parsedResult.description;
              if (parsedResult.source_name)
                newMessage.source_name = parsedResult.source_name;
              if (
                parsedResult.description &&
                parsedResult.type === "ai_image"
              ) {
                newMessage.content = parsedResult.description;
              }

              newMessages.push(newMessage);
            }
          }

          if (newMessages.length === 0) {
            document
              .getElementById("message-editor-modal")
              .classList.remove("visible");
            return; // 如果是空消息，直接返回，不执行删除操作
          }

          // ★★★★★【核心修复逻辑就在这里】★★★★★

          // 1. 使用 splice 将旧消息替换为新消息（此时新消息还没有时间戳）
          chat.history.splice(messageIndex, 1, ...newMessages);

          // 2. 确定重新分配时间戳的起点
          // 我们从被编辑的消息的原始时间戳开始
          let reassignTimestamp = timestamp;

          // 3. 从被修改的位置开始，遍历所有后续的消息
          for (let i = messageIndex; i < chat.history.length; i++) {
            // 4. 为每一条消息（包括新插入的）分配一个新的、唯一的、连续的时间戳
            chat.history[i].timestamp = reassignTimestamp;

            // 5. 将时间戳+1，为下一条消息做准备
            reassignTimestamp++;
          }
          // ★★★★★【修复结束】★★★★★

          await db.chats.put(chat);

          // 关闭可能打开的模态框并刷新UI
          document
            .getElementById("message-editor-modal")
            .classList.remove("visible");
          renderChatInterface(state.activeChatId);
          await showCustomAlert("成功", "消息已更新！");
        }

        // ▲▲▲ 替换结束 ▲▲▲

        // ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

        /**
         * 当点击“…”时，显示动态操作菜单
         * @param {number} postId - 被操作的动态的ID
         */
        function showPostActions(postId) {
          activePostId = postId;
          document
            .getElementById("post-actions-modal")
            .classList.add("visible");
        }

        /**
         * 隐藏动态操作菜单
         */
        function hidePostActions() {
          document
            .getElementById("post-actions-modal")
            .classList.remove("visible");
          activePostId = null;
        }

        /**
         * 打开动态编辑器
         */
        async function openPostEditor() {
          if (!activePostId) return;

          const postIdToEdit = activePostId;
          const post = await db.qzonePosts.get(postIdToEdit);
          if (!post) return;

          hidePostActions();

          // 忠于原文：构建出最原始的文本形态供编辑
          let contentForEditing;
          if (post.type === "shuoshuo") {
            contentForEditing = post.content;
          } else {
            // 对于图片和文字图，我们构建一个包含所有信息的对象
            const postObject = {
              type: post.type,
              publicText: post.publicText || "",
            };
            if (post.type === "image_post") {
              postObject.imageUrl = post.imageUrl;
              postObject.imageDescription = post.imageDescription;
            } else if (post.type === "text_image") {
              postObject.hiddenContent = post.hiddenContent;
            }
            contentForEditing = JSON.stringify(postObject, null, 2);
          }

          // 构建格式助手按钮
          const templates = {
            shuoshuo: "在这里输入说说的内容...", // 对于说说，我们直接替换为纯文本
            image: {
              type: "image_post",
              publicText: "",
              imageUrl: "https://...",
              imageDescription: "",
            },
            text_image: {
              type: "text_image",
              publicText: "",
              hiddenContent: "",
            },
          };

          const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-type="text">说说</button>
            <button class="format-btn" data-template='${JSON.stringify(
              templates.image
            )}'>图片动态</button>
            <button class="format-btn" data-template='${JSON.stringify(
              templates.text_image
            )}'>文字图</button>
        </div>
    `;

          const newContent = await showCustomPrompt(
            "编辑动态",
            "在此修改内容...",
            contentForEditing,
            "textarea",
            helpersHtml
          );

          // 【特殊处理】为说说的格式助手按钮添加不同的行为
          // 我们需要在模态框出现后，再给它绑定事件
          setTimeout(() => {
            const shuoshuoBtn = document.querySelector(
              '#custom-modal-body .format-btn[data-type="text"]'
            );
            if (shuoshuoBtn) {
              shuoshuoBtn.addEventListener("click", () => {
                const input = document.getElementById("custom-prompt-input");
                input.value = templates.shuoshuo;
                input.focus();
              });
            }
          }, 100);

          if (newContent !== null) {
            await saveEditedPost(postIdToEdit, newContent);
          }
        }

        /**
         * 保存编辑后的动态
         * @param {number} postId - 要保存的动态ID
         * @param {string} newRawContent - 从编辑器获取的新内容
         */
        async function saveEditedPost(postId, newRawContent) {
          const post = await db.qzonePosts.get(postId);
          if (!post) return;

          const trimmedContent = newRawContent.trim();

          // 尝试解析为JSON，如果失败，则认为是纯文本（说说）
          try {
            const parsed = JSON.parse(trimmedContent);
            // 更新帖子属性
            post.type = parsed.type || "image_post";
            post.publicText = parsed.publicText || "";
            post.imageUrl = parsed.imageUrl || "";
            post.imageDescription = parsed.imageDescription || "";
            post.hiddenContent = parsed.hiddenContent || "";
            post.content = ""; // 清空旧的说说内容字段
          } catch (e) {
            // 解析失败，认为是说说
            post.type = "shuoshuo";
            post.content = trimmedContent;
            // 清空其他类型的字段
            post.publicText = "";
            post.imageUrl = "";
            post.imageDescription = "";
            post.hiddenContent = "";
          }

          await db.qzonePosts.put(post);
          await renderQzonePosts(); // 重新渲染列表
          await showCustomAlert("成功", "动态已更新！");
        }

        /**
         * 复制动态内容
         */
        async function copyPostContent() {
          if (!activePostId) return;
          const post = await db.qzonePosts.get(activePostId);
          if (!post) return;

          let textToCopy =
            post.content ||
            post.publicText ||
            post.hiddenContent ||
            post.imageDescription ||
            "（无文字内容）";

          try {
            await navigator.clipboard.writeText(textToCopy);
            await showCustomAlert("复制成功", "动态内容已复制到剪贴板。");
          } catch (err) {
            await showCustomAlert("复制失败", "无法访问剪贴板。");
          }

          hidePostActions();
        }

        // ▼▼▼ 【全新】创建群聊与拉人功能核心函数 ▼▼▼
        let selectedContacts = new Set();

        async function openContactPickerForGroupCreate() {
          selectedContacts.clear(); // 清空上次选择

          // 【核心修复】在这里，我们为“完成”按钮明确绑定“创建群聊”的功能
          const confirmBtn = document.getElementById(
            "confirm-contact-picker-btn"
          );
          // 使用克隆节点技巧，清除掉之前可能绑定的任何其他事件（比如“添加成员”）
          const newConfirmBtn = confirmBtn.cloneNode(true);
          confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
          // 重新绑定正确的“创建群聊”函数
          newConfirmBtn.addEventListener("click", handleCreateGroup);

          await renderContactPicker();
          showScreen("contact-picker-screen");
        }
        // ▲▲▲ 替换结束 ▲▲▲

        /**
         * 渲染联系人选择列表
         */
        async function renderContactPicker() {
          const listEl = document.getElementById("contact-picker-list");
          listEl.innerHTML = "";

          // 只选择单聊角色作为群成员候选
          const contacts = Object.values(state.chats).filter(
            (chat) => !chat.isGroup
          );

          if (contacts.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
            return;
          }

          contacts.forEach((contact) => {
            const item = document.createElement("div");
            item.className = "contact-picker-item";
            item.dataset.contactId = contact.id;
            item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${
              contact.settings.aiAvatar || defaultAvatar
            }" class="avatar">
            <span class="name">${contact.name}</span>
        `;
            listEl.appendChild(item);
          });

          updateContactPickerConfirmButton();
        }

        /**
         * 更新“完成”按钮的计数
         */
        function updateContactPickerConfirmButton() {
          const btn = document.getElementById("confirm-contact-picker-btn");
          btn.textContent = `完成(${selectedContacts.size})`;
          btn.disabled = selectedContacts.size < 2; // 至少需要2个人才能创建群聊
        }

        /**
         * 【重构版】处理创建群聊的最终逻辑
         */
        async function handleCreateGroup() {
          if (selectedContacts.size < 2) {
            alert("创建群聊至少需要选择2个联系人。");
            return;
          }

          const groupName = await showCustomPrompt(
            "设置群名",
            "请输入群聊的名字",
            "我们的群聊"
          );
          if (!groupName || !groupName.trim()) return;

          const newChatId = "group_" + Date.now();
          const members = [];

          // 遍历选中的联系人ID
          for (const contactId of selectedContacts) {
            const contactChat = state.chats[contactId];
            if (contactChat) {
              // ★★★【核心重构】★★★
              // 我们现在同时存储角色的“本名”和“群昵称”
              members.push({
                id: contactId,
                originalName: contactChat.name, // 角色的“本名”，用于AI识别
                groupNickname: contactChat.name, // 角色的“群昵称”，用于显示和修改，初始值和本名相同
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || "",
              });
            }
          }

          const newGroupChat = {
            id: newChatId,
            name: groupName.trim(),
            isGroup: true,
            members: members,
            settings: {
              myPersona: "我是谁呀。",
              myNickname: "我",
              maxMemory: 10,
              groupAvatar: defaultGroupAvatar,
              myAvatar: defaultMyGroupAvatar,
              background: "",
              theme: "default",
              fontSize: 13,
              customCss: "",
              linkedWorldBookIds: [],
            },
            history: [],
            musicData: { totalTime: 0 },
          };

          state.chats[newChatId] = newGroupChat;
          await db.chats.put(newGroupChat);

          await renderChatList();
          showScreen("chat-list-screen");
          openChat(newChatId);
        }

        // ▼▼▼ 【全新】群成员管理核心函数 ▼▼▼

        /**
         * 打开群成员管理屏幕
         */
        function openMemberManagementScreen() {
          if (!state.activeChatId || !state.chats[state.activeChatId].isGroup)
            return;
          renderMemberManagementList();
          showScreen("member-management-screen");
        }

        function renderMemberManagementList() {
          const listEl = document.getElementById("member-management-list");
          const chat = state.chats[state.activeChatId];
          listEl.innerHTML = "";

          chat.members.forEach((member) => {
            const item = document.createElement("div");
            item.className = "member-management-item";
            // 【核心修正】在这里，我们将显示的名称从 member.name 改为 member.groupNickname
            item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <span class="name">${member.groupNickname}</span>
            <button class="remove-member-btn" data-member-id="${member.id}" title="移出群聊">-</button>
        `;
            listEl.appendChild(item);
          });
        }

        /**
         * 从群聊中移除一个成员
         * @param {string} memberId - 要移除的成员ID
         */
        async function removeMemberFromGroup(memberId) {
          const chat = state.chats[state.activeChatId];
          const memberIndex = chat.members.findIndex((m) => m.id === memberId);

          if (memberIndex === -1) return;

          // 安全检查，群聊至少保留2人
          if (chat.members.length <= 2) {
            alert("群聊人数不能少于2人。");
            return;
          }

          const memberName = chat.members[memberIndex].groupNickname; // <-- 修复：使用 groupNickname
          const confirmed = await showCustomConfirm(
            "移出成员",
            `确定要将“${memberName}”移出群聊吗？`,
            { confirmButtonClass: "btn-danger" }
          );

          if (confirmed) {
            chat.members.splice(memberIndex, 1);
            await db.chats.put(chat);
            renderMemberManagementList(); // 刷新成员管理列表
            document.getElementById("chat-settings-btn").click(); // 【核心修正】模拟点击设置按钮，强制刷新整个弹窗
          }
        }

        /**
         * 打开联系人选择器，用于拉人入群
         */
        async function openContactPickerForAddMember() {
          selectedContacts.clear(); // 清空选择

          const chat = state.chats[state.activeChatId];
          const existingMemberIds = new Set(chat.members.map((m) => m.id));

          // 渲染联系人列表，并自动排除已在群内的成员
          const listEl = document.getElementById("contact-picker-list");
          listEl.innerHTML = "";
          const contacts = Object.values(state.chats).filter(
            (c) => !c.isGroup && !existingMemberIds.has(c.id)
          );

          if (contacts.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的好友了。</p>';
            document.getElementById(
              "confirm-contact-picker-btn"
            ).style.display = "none"; // 没有人可选，隐藏完成按钮
          } else {
            document.getElementById(
              "confirm-contact-picker-btn"
            ).style.display = "block";
            contacts.forEach((contact) => {
              const item = document.createElement("div");
              item.className = "contact-picker-item";
              item.dataset.contactId = contact.id;
              item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${
                  contact.settings.aiAvatar || defaultAvatar
                }" class="avatar">
                <span class="name">${contact.name}</span>
            `;
              listEl.appendChild(item);
            });
          }

          // 更新按钮状态并显示屏幕
          updateContactPickerConfirmButton();
          showScreen("contact-picker-screen");
        }

        /**
         * 处理将选中的联系人加入群聊的逻辑
         */
        async function handleAddMembersToGroup() {
          if (selectedContacts.size === 0) {
            alert("请至少选择一个要添加的联系人。");
            return;
          }

          const chat = state.chats[state.activeChatId];

          for (const contactId of selectedContacts) {
            const contactChat = state.chats[contactId];
            if (contactChat) {
              chat.members.push({
                id: contactId,
                originalName: contactChat.name, // <-- 修复1：使用 'originalName' 存储本名
                groupNickname: contactChat.name, // <-- 修复2：同时创建一个初始的 'groupNickname'
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || "",
              });
            }
          }

          await db.chats.put(chat);
          openMemberManagementScreen(); // 返回到群成员管理界面
          renderGroupMemberSettings(chat.members); // 同时更新聊天设置里的头像
        }

        /**
         * 【重构版】在群聊中创建一个全新的虚拟成员
         */
        async function createNewMemberInGroup() {
          const name = await showCustomPrompt(
            "创建新成员",
            "请输入新成员的名字 (这将是TA的“本名”，不可更改)"
          );
          if (!name || !name.trim()) return;

          // 检查本名是否已在群内存在
          const chat = state.chats[state.activeChatId];
          if (chat.members.some((m) => m.originalName === name.trim())) {
            alert(`错误：群内已存在名为“${name.trim()}”的成员！`);
            return;
          }

          const persona = await showCustomPrompt(
            "设置人设",
            `请输入“${name}”的人设`,
            "",
            "textarea"
          );
          if (persona === null) return;

          // ★★★【核心重构】★★★
          // 为新创建的NPC也建立双重命名机制
          const newMember = {
            id: "npc_" + Date.now(),
            originalName: name.trim(), // 新成员的“本名”
            groupNickname: name.trim(), // 新成员的初始“群昵称”
            avatar: defaultGroupMemberAvatar,
            persona: persona,
            avatarFrame: "",
          };

          chat.members.push(newMember);
          await db.chats.put(chat);

          renderMemberManagementList();
          renderGroupMemberSettings(chat.members);

          alert(`新成员“${name}”已成功加入群聊！`);
        }

        // ▼▼▼ 【全新】外卖请求倒计时函数 ▼▼▼
        function startWaimaiCountdown(element, endTime) {
          const timerId = setInterval(() => {
            const now = Date.now();
            const distance = endTime - now;

            if (distance < 0) {
              clearInterval(timerId);
              element.innerHTML =
                "<span>已</span><span>超</span><span>时</span>";
              return;
            }

            const minutes = Math.floor(
              (distance % (1000 * 60 * 60)) / (1000 * 60)
            );
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            const minStr = String(minutes).padStart(2, "0");
            const secStr = String(seconds).padStart(2, "0");

            element.innerHTML = `<span>${minStr.charAt(
              0
            )}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(
              0
            )}</span><span>${secStr.charAt(1)}</span>`;
          }, 1000);
          return timerId;
        }

        function cleanupWaimaiTimers() {
          for (const timestamp in waimaiTimers) {
            clearInterval(waimaiTimers[timestamp]);
          }
          waimaiTimers = {};
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        async function handleWaimaiResponse(originalTimestamp, choice) {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === originalTimestamp
          );
          if (messageIndex === -1) return;

          // 1. 更新原始消息的状态
          const originalMessage = chat.history[messageIndex];
          originalMessage.status = choice;

          // 【核心修正】记录支付者，并构建对AI更清晰的系统消息
          let systemContent;
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";

          if (choice === "paid") {
            originalMessage.paidBy = myNickname; // 记录是用户付的钱
            systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
          } else {
            systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
          }

          // 2. 创建一条新的、对用户隐藏的系统消息，告知AI结果
          const systemNote = {
            role: "system",
            content: systemContent,
            timestamp: Date.now(),
            isHidden: true,
          };
          chat.history.push(systemNote);

          // 3. 保存更新到数据库并刷新UI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);
        }

        let videoCallState = {
          isActive: false,
          isAwaitingResponse: false,
          isGroupCall: false,
          activeChatId: null,
          initiator: null,
          startTime: null,
          participants: [],
          isUserParticipating: true,

          callHistory: [], // 用于存储通话中的对话历史
          preCallContext: "", // 用于存储通话前的聊天摘要
        };

        let callTimerInterval = null; // 用于存储计时器的ID

        /**
         * 用户点击“发起视频通话”或“发起群视频”按钮
         */
        async function handleInitiateCall() {
          if (
            !state.activeChatId ||
            videoCallState.isActive ||
            videoCallState.isAwaitingResponse
          )
            return;

          const chat = state.chats[state.activeChatId];
          videoCallState.isGroupCall = chat.isGroup;
          videoCallState.isAwaitingResponse = true;
          videoCallState.initiator = "user";
          videoCallState.activeChatId = chat.id;
          videoCallState.isUserParticipating = true;

          // 1. 显示“正在呼叫”界面
          if (chat.isGroup) {
            document.getElementById("outgoing-call-avatar").src =
              chat.settings.myAvatar || defaultMyGroupAvatar;
            document.getElementById("outgoing-call-name").textContent =
              chat.settings.myNickname || "我";
          } else {
            document.getElementById("outgoing-call-avatar").src =
              chat.settings.aiAvatar || defaultAvatar;
            document.getElementById("outgoing-call-name").textContent =
              chat.name;
          }
          document.querySelector(
            "#outgoing-call-screen .caller-text"
          ).textContent = chat.isGroup ? "正在呼叫所有成员..." : "正在呼叫...";
          showScreen("outgoing-call-screen");

          // 在发起通话时，提前准备好通话前的聊天记录上下文
          videoCallState.preCallContext = chat.history
            .slice(-20) // 获取最近20条消息
            .map(
              (msg) =>
                `${
                  msg.role === "user"
                    ? chat.settings.myNickname || "我"
                    : msg.senderName || chat.name
                }: ${String(msg.content).substring(0, 50)}...`
            )
            .join("\n");

          // 2. 重新构建一个信息更丰富、指令更明确的API请求
          try {
            const { proxyUrl, apiKey, model } = getActiveApiConfig() || {};
            if (!proxyUrl || !apiKey || !model) {
              throw new Error("API未配置，无法发起通话。");
            }

            let systemPromptForCall;
            if (chat.isGroup) {
              systemPromptForCall = `
			# 你的任务
			你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
			用户 (${chat.settings.myNickname || "我"}) 刚刚发起了群视频通话。
			你的任务是根据每个角色的性格和最近的聊天内容，决定他们是否要加入通话。

			# 核心规则
			1.  **决策**: 每个角色都必须独立决策。
			2.  **格式**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的决策，格式为：\`{"type": "group_call_response", "name": "【角色的本名】", "decision": "join"}\` 或 \`{"type": "group_call_response", "name": "【角色的本名】", "decision": "decline"}\`。
			3.  **倾向性**: 在没有特殊理由的情况下，你的角色们通常乐于加入群聊。

			# 角色列表与人设
			${chat.members.map((m) => `- **${m.originalName}**: ${m.persona}`).join("\n")}

			# 通话前的聊天摘要
			${videoCallState.preCallContext}
			`;
            } else {
              systemPromptForCall = `
			# 你的任务
			你正在扮演角色 "${chat.name}"。用户 (${
                chat.settings.myNickname || "我"
              }) 刚刚向你发起了视频通话请求。
			你的任务是根据你的人设和我们最近的聊天内容，决定是否接受。

			# 核心规则
			1.  **决策**: 你必须做出 "accept" (接受) 或 "reject" (拒绝) 的决定。
			2.  **格式**: 你的回复【必须且只能】是一个JSON数组，其中包含一个对象，格式为：\`[{"type": "video_call_response", "decision": "accept"}]\` 或 \`[{"type": "video_call_response", "decision": "reject"}]\`。
			3.  **倾向性**: 作为一个友好的AI伴侣，在没有特殊理由（比如在之前的对话中明确表示了不想被打扰或正在忙）的情况下，你【应该优先选择接受】通话。

			# 你的人设
			${chat.settings.aiPersona}

			# 通话前的聊天摘要
			${videoCallState.preCallContext}
			`;
            }

            const messagesForApi = [
              {
                role: "user",
                content: "请根据你在系统指令中读到的规则，立即做出你的决策。",
              },
            ];

            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPromptForCall,
              messagesForApi,
              isGemini
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: [
                      { role: "system", content: systemPromptForCall },
                      ...messagesForApi,
                    ],
                    temperature: 0.8,
                  }),
                });

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`API 错误 (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            const aiResponseContent = (
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content
            ).replace(/^```json\s*|```$/g, "");
            const responseArray = JSON.parse(aiResponseContent);

            if (chat.isGroup) {
              responseArray.forEach((action) => {
                if (
                  action.type === "group_call_response" &&
                  action.decision === "join"
                ) {
                  const member = chat.members.find(
                    (m) => m.originalName === action.name
                  );
                  if (member) videoCallState.participants.push(member);
                }
              });
              if (videoCallState.participants.length > 0) {
                startVideoCall();
              } else {
                throw new Error("群里没有人接听你的通话邀请。");
              }
            } else {
              const decision = responseArray[0];
              if (
                decision.type === "video_call_response" &&
                decision.decision === "accept"
              ) {
                startVideoCall();
              } else {
                throw new Error("对方拒绝了你的视频通话请求。");
              }
            }
          } catch (error) {
            console.error("发起通话失败:", error);
            await showCustomAlert("呼叫失败", error.message);
            videoCallState.isAwaitingResponse = false;
            showScreen("chat-interface-screen");
          }
        }

        function startVideoCall() {
          const chat = state.chats[videoCallState.activeChatId];
          if (!chat) return;

          // 提取通话前的最后20条消息作为上下文
          videoCallState.preCallContext = chat.history
            .slice(-20)
            .map(
              (msg) =>
                `${
                  msg.role === "user"
                    ? chat.settings.myNickname || "我"
                    : msg.senderName || chat.name
                }: ${String(msg.content).substring(0, 50)}...`
            )
            .join("\n");

          // 1. 检查是否启用了可视化界面
          if (chat.settings.visualVideoCallEnabled) {
            // --- 启动【新】的可视化界面 ---
            videoCallState.isActive = true;
            videoCallState.isAwaitingResponse = false;
            videoCallState.startTime = Date.now();
            videoCallState.callHistory = [];

            const visualInterface = document.getElementById(
              "visual-call-interface"
            );
            const textInterface = document.getElementById(
              "text-call-interface"
            );

            // 显示新界面，隐藏旧界面
            visualInterface.style.display = "flex";
            textInterface.style.display = "none";

            // 加载图片
            document.querySelector("#video-main-view img").src =
              chat.settings.charVideoImage || defaultAvatar;
            document.querySelector("#video-pip-view img").src =
              chat.settings.userVideoImage || defaultAvatar;

            // 清空旧的聊天气泡
            document.getElementById(
              "video-call-messages-visual"
            ).innerHTML = `<em>正在接通...</em>`;
            showScreen("video-call-screen");

            // 启动计时器
            if (callTimerInterval) clearInterval(callTimerInterval);
            callTimerInterval = setInterval(updateCallTimer, 1000);
            updateCallTimer(); // 立即更新一次

            // 触发AI在通话中的第一句话
            triggerAiInCallAction();
          } else {
            // --- 启动【旧】的纯文字界面 ---
            videoCallState.isActive = true;
            videoCallState.isAwaitingResponse = false;
            videoCallState.startTime = Date.now();
            videoCallState.callHistory = [];

            const visualInterface = document.getElementById(
              "visual-call-interface"
            );
            const textInterface = document.getElementById(
              "text-call-interface"
            );

            // 显示旧界面，隐藏新界面
            visualInterface.style.display = "none";
            textInterface.style.display = "flex"; // 旧界面用flex

            updateParticipantAvatars();

            document.getElementById("video-call-main").innerHTML = `<em>${
              videoCallState.isGroupCall ? "群聊已建立..." : "正在接通..."
            }</em>`;
            showScreen("video-call-screen");

            document.getElementById("user-speak-btn").style.display =
              videoCallState.isUserParticipating ? "block" : "none";
            document.getElementById("join-call-btn").style.display =
              videoCallState.isUserParticipating ? "none" : "block";

            if (callTimerInterval) clearInterval(callTimerInterval);
            callTimerInterval = setInterval(updateCallTimer, 1000);
            updateCallTimer();

            triggerAiInCallAction();
          }
        }

        /**
         * 结束视频通话
         */

        async function endVideoCall() {
          document.getElementById("visual-call-interface").style.display =
            "none";

          document.getElementById("video-call-floating-bubble").style.display =
            "none";
          if (!videoCallState.isActive) return;

          const duration = Math.floor(
            (Date.now() - videoCallState.startTime) / 1000
          );
          const durationText = `${Math.floor(duration / 60)}分${
            duration % 60
          }秒`;
          const endCallText = `通话结束，时长 ${durationText}`;

          const chat = state.chats[videoCallState.activeChatId];
          if (chat) {
            // 1. 保存完整的通话记录到数据库 (这部分逻辑不变)
            const participantsData = [];
            if (videoCallState.isGroupCall) {
              videoCallState.participants.forEach((p) =>
                participantsData.push({
                  name: p.originalName,
                  avatar: p.avatar,
                })
              );
              if (videoCallState.isUserParticipating) {
                participantsData.unshift({
                  name: chat.settings.myNickname || "我",
                  avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
                });
              }
            } else {
              participantsData.push({
                name: chat.name,
                avatar: chat.settings.aiAvatar || defaultAvatar,
              });
              participantsData.unshift({
                name: "我",
                avatar: chat.settings.myAvatar || defaultAvatar,
              });
            }

            const callRecord = {
              chatId: videoCallState.activeChatId,
              timestamp: Date.now(),
              duration: duration,
              participants: participantsData,
              transcript: [...videoCallState.callHistory],
            };
            await db.callRecords.add(callRecord);
            console.log("通话记录已保存:", callRecord);

            // 2. 在聊天记录里添加对用户可见的“通话结束”消息
            let summaryMessage = {
              role: videoCallState.initiator === "user" ? "user" : "assistant",
              content: endCallText,
              timestamp: Date.now(),
            };

            if (chat.isGroup && summaryMessage.role === "assistant") {
              // 在群聊中，通话结束的消息应该由“发起者”来说
              // videoCallState.callRequester 保存了最初发起通话的那个AI的名字
              summaryMessage.senderName =
                videoCallState.callRequester ||
                chat.members[0]?.originalName ||
                chat.name;
            }

            chat.history.push(summaryMessage);

            // 3. 创建并添加对用户隐藏的“通话后汇报”指令
            const callTranscriptForAI = videoCallState.callHistory
              .map(
                (h) =>
                  `${
                    h.role === "user"
                      ? chat.settings.myNickname || "我"
                      : h.role
                  }: ${h.content}`
              )
              .join("\n");

            const hiddenReportInstruction = {
              role: "system",
              content: `[系统指令：视频通话刚刚结束。请你根据完整的通话文字记录（见下方），以你的角色口吻，向用户主动发送几条【格式为 {"type": "text", "content": "..."} 的】消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。这很重要，能让用户感觉你记得通话内容。]\n---通话记录开始---\n${callTranscriptForAI}\n---通话记录结束---`,
              timestamp: Date.now() + 1, // 确保在上一条消息之后
              isHidden: true,
            };
            chat.history.push(hiddenReportInstruction);

            // 4. 保存所有更新到数据库
            await db.chats.put(chat);
          }

          // 5. 清理和重置状态 (这部分逻辑不变)
          clearInterval(callTimerInterval);
          callTimerInterval = null;
          videoCallState = {
            isActive: false,
            isAwaitingResponse: false,
            isGroupCall: false,
            activeChatId: null,
            initiator: null,
            startTime: null,
            participants: [],
            isUserParticipating: true,
            callHistory: [],
            preCallContext: "",
          };

          // 6. 返回聊天界面并触发AI响应（AI会读取到我们的“汇报”指令）
          if (chat) {
            openChat(chat.id);
            triggerAiResponse(); // 关键一步！
          }
        }

        /**
         * 最小化视频通话
         */
        function minimizeVideoCall() {
          // 访问内部变量 videoCallState
          if (!videoCallState.isActive) return;

          const chat = state.chats[videoCallState.activeChatId];
          const bubble = document.getElementById("video-call-floating-bubble");
          const avatarImg = document.getElementById("video-floating-avatar");

          // 1. 设置悬浮球头像
          if (chat) {
            const avatarUrl = chat.isGroup
              ? chat.settings.groupAvatar || defaultGroupAvatar
              : chat.settings.aiAvatar || defaultAvatar;
            avatarImg.src = avatarUrl;
          }

          // 2. 隐藏视频界面，显示悬浮球
          document
            .getElementById("video-call-screen")
            .classList.remove("active");
          bubble.style.display = "block";

          // 3. 返回聊天界面
          showScreen("chat-interface-screen");
        }

        window.minimizeVideoCall = minimizeVideoCall;

        /**
         * 恢复视频通话界面
         */
        function restoreVideoCall() {
          const bubble = document.getElementById("video-call-floating-bubble");

          // 1. 隐藏悬浮球
          bubble.style.display = "none";

          // 2. 显示视频界面
          showScreen("video-call-screen");
        }

        window.restoreVideoCall = restoreVideoCall;

        /**
         * 初始化悬浮球的拖拽功能
         */
        function initVideoBubbleDrag() {
          const bubble = document.getElementById("video-call-floating-bubble");
          let isDragging = false;
          let startX, startY, initialLeft, initialTop;
          let hasMoved = false; // 用于区分点击和拖拽

          const onStart = (e) => {
            isDragging = true;
            hasMoved = false;

            // 获取点击坐标
            const clientX = e.type.includes("mouse")
              ? e.clientX
              : e.touches[0].clientX;
            const clientY = e.type.includes("mouse")
              ? e.clientY
              : e.touches[0].clientY;

            startX = clientX;
            startY = clientY;

            // 获取当前位置
            const rect = bubble.getBoundingClientRect();
            initialLeft = rect.left;
            initialTop = rect.top;

            // 阻止默认事件防止滚动
            if (e.type === "touchstart") {
              // e.preventDefault(); // 可能会阻止点击，视情况而定
            }
          };

          const onMove = (e) => {
            if (!isDragging) return;
            e.preventDefault(); // 阻止页面滚动

            const clientX = e.type.includes("mouse")
              ? e.clientX
              : e.touches[0].clientX;
            const clientY = e.type.includes("mouse")
              ? e.clientY
              : e.touches[0].clientY;

            const deltaX = clientX - startX;
            const deltaY = clientY - startY;

            // 如果移动距离超过 5px，视为拖拽
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
              hasMoved = true;
            }

            let newLeft = initialLeft + deltaX;
            let newTop = initialTop + deltaY;

            // 边界限制
            const maxLeft = window.innerWidth - bubble.offsetWidth;
            const maxTop = window.innerHeight - bubble.offsetHeight;

            newLeft = Math.max(0, Math.min(newLeft, maxLeft));
            newTop = Math.max(0, Math.min(newTop, maxTop));

            bubble.style.left = `${newLeft}px`;
            bubble.style.top = `${newTop}px`;
            bubble.style.right = "auto"; // 清除 right 属性
          };

          const onEnd = (e) => {
            if (!isDragging) return;
            isDragging = false;

            // 如果没有移动（是点击），则恢复视频
            if (!hasMoved) {
              restoreVideoCall();
            }
          };

          // 绑定事件
          bubble.addEventListener("mousedown", onStart);
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onEnd);

          bubble.addEventListener("touchstart", onStart, { passive: false });
          document.addEventListener("touchmove", onMove, { passive: false });
          document.addEventListener("touchend", onEnd);
        }

        /**
         * 更新通话界面的参与者头像网格
         */
        function updateParticipantAvatars() {
          const grid = document.getElementById("participant-avatars-grid");
          grid.innerHTML = "";
          const chat = state.chats[videoCallState.activeChatId];
          if (!chat) return;

          let participantsToRender = [];

          // 区分群聊和单聊
          if (videoCallState.isGroupCall) {
            // 群聊逻辑：显示所有已加入的AI成员
            participantsToRender = [...videoCallState.participants];
            // 如果用户也参与了，就把用户信息也加进去
            if (videoCallState.isUserParticipating) {
              participantsToRender.unshift({
                id: "user",
                name: chat.settings.myNickname || "我",
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
              });
            }
          } else {
            // 单聊逻辑：只显示对方的头像和名字
            participantsToRender.push({
              id: "ai",
              name: chat.name,
              avatar: chat.settings.aiAvatar || defaultAvatar,
            });
          }

          participantsToRender.forEach((p) => {
            const wrapper = document.createElement("div");
            wrapper.className = "participant-avatar-wrapper";
            wrapper.dataset.participantId = p.id;
            const displayName = p.groupNickname || p.name;
            wrapper.innerHTML = `
			    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
			    <div class="participant-name">${displayName}</div>
			`;
            grid.appendChild(wrapper);
          });
        }

        /**
         * 处理用户加入/重新加入通话
         */
        function handleUserJoinCall() {
          if (!videoCallState.isActive || videoCallState.isUserParticipating)
            return;

          videoCallState.isUserParticipating = true;
          updateParticipantAvatars(); // 更新头像列表，加入用户

          // 切换底部按钮
          document.getElementById("user-speak-btn").style.display = "block";
          document.getElementById("join-call-btn").style.display = "none";

          // 告知AI用户加入了
          triggerAiInCallAction("[系统提示：用户加入了通话]");
        }

        /**
         * 更新通话计时器显示
         */

        function updateCallTimer() {
          if (!videoCallState.isActive) return;
          const elapsed = Math.floor(
            (Date.now() - videoCallState.startTime) / 1000
          );
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          const timeString = `${String(minutes).padStart(2, "0")}:${String(
            seconds
          ).padStart(2, "0")}`;

          // 同时更新两个界面的计时器
          document.getElementById("call-timer").textContent = timeString;
          document.getElementById("visual-call-timer").textContent = timeString;
        }

        function showIncomingCallModal(chatId) {
          // <--- 在括号里添加 chatId
          const chat = state.chats[chatId]; // <--- 把 state.activeChatId 修改为 chatId
          if (!chat) return;

          // 根据是否群聊显示不同信息
          if (chat.isGroup) {
            // 从 videoCallState 中获取是哪个成员发起的通话
            const requesterName =
              videoCallState.callRequester ||
              chat.members[0]?.name ||
              "一位成员";
            document.getElementById("caller-avatar").src =
              chat.settings.groupAvatar || defaultGroupAvatar;
            document.getElementById("caller-name").textContent = chat.name; // 显示群名
            document.querySelector(
              ".incoming-call-content .caller-text"
            ).textContent = `${requesterName} 邀请你加入群视频`; // 显示具体发起人
          } else {
            // 单聊逻辑保持不变
            document.getElementById("caller-avatar").src =
              chat.settings.aiAvatar || defaultAvatar;
            document.getElementById("caller-name").textContent = chat.name;
            document.querySelector(
              ".incoming-call-content .caller-text"
            ).textContent = "邀请你视频通话";
          }

          document
            .getElementById("incoming-call-modal")
            .classList.add("visible");
          playRingtone();
        }

        /**
         * 隐藏AI发起的通话请求模态框 (保持不变)
         */
        function hideIncomingCallModal() {
          document
            .getElementById("incoming-call-modal")
            .classList.remove("visible");
          stopRingtone();
        }

        async function triggerAiInCallAction(userInput = null) {
          if (!videoCallState.isActive) return;

          const chat = state.chats[videoCallState.activeChatId];
          const { proxyUrl, apiKey, model } = getActiveApiConfig() || {};

          const isVisualMode = chat.settings.visualVideoCallEnabled;
          const callFeed = isVisualMode
            ? document.getElementById("video-call-messages-visual")
            : document.getElementById("video-call-main");

          const userNickname = chat.settings.myNickname || "我";

          let worldBookContent = "";
          if (
            chat.settings.linkedWorldBookIds &&
            chat.settings.linkedWorldBookIds.length > 0
          ) {
            const linkedContents = chat.settings.linkedWorldBookIds
              .map((bookId) => {
                const worldBook = state.worldBooks.find(
                  (wb) => wb.id === bookId
                );
                return worldBook && worldBook.content
                  ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}`
                  : "";
              })
              .filter(Boolean)
              .join("");
            if (linkedContents) {
              worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
            }
          }

          if (userInput && videoCallState.isUserParticipating) {
            if (isVisualMode) {
              const userBubble = document.createElement("div");
              userBubble.className = "visual-call-bubble user";
              userBubble.textContent = userInput;
              callFeed.appendChild(userBubble);
            } else {
              const userBubble = document.createElement("div");
              userBubble.className = "call-message-bubble user-speech";
              userBubble.textContent = userInput;
              callFeed.appendChild(userBubble);
            }
            callFeed.scrollTop = callFeed.scrollHeight;
            videoCallState.callHistory.push({
              role: "user",
              content: userInput,
            });
          }

          let inCallPrompt;
          if (videoCallState.isGroupCall) {
            const participantNames = videoCallState.participants.map(
              (p) => p.originalName
            );
            if (videoCallState.isUserParticipating) {
              participantNames.unshift(userNickname);
            }

            inCallPrompt = `
			# 你的任务
			你是一个群聊AI，负责扮演所有【除了用户以外】的AI角色。你们正在进行一场群聊视频通话。
			你的任务是根据每个角色的性格，生成他们在通话中会说的【第一人称对话】，注意是在视频通话，绝对不能以为是在现实！每次回复的字数多些，50字以上。

			# 核心规则
			1.  **【【【语言铁律】】】**: 无论角色人设是什么国籍或说什么语言，在本次视频通话中，所有角色【必须】全程使用【中文】进行交流。
			2.  **【【【格式铁律】】】**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的发言，格式为：\`{"name": "【角色的本名】", "speech": "【在这里加入带动作的对话】"}\`。
			3.  **【【【表现力铁律】】】**: 在 "speech" 字段中，你【必须】为角色的对话加入【动作、表情或心理活动】，并用【】符号包裹。这非常重要！
			4.  **示例**: \`{"name": "张三", "speech": "【挠了挠头】啊？我刚刚走神了，你们说到哪了？"}\`
			5.  **身份铁律**: 用户的身份是【${userNickname}】。你【绝对不能】生成 \`name\` 字段为 **"${userNickname}"** 的发言。
			6.  **角色扮演**: 严格遵守每个角色的设定，用他们的口吻说话。

			# 当前情景
			你们正在一个群视频通话中。
			**通话前的聊天摘要**:
			${videoCallState.preCallContext}
			**当前参与者**: ${participantNames.join("、 ")}。
			${worldBookContent}
			现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
			`;
          } else {
            let openingContext =
              videoCallState.initiator === "user"
                ? `你刚刚接听了用户的视频通话请求。`
                : `用户刚刚接听了你主动发起的视频通话。`;

            inCallPrompt = `
			# 你的任务
			你正在扮演角色 "${chat.name}"。你正在和用户 (${userNickname}) 进行一对一视频通话。
			${openingContext}
			你的任务是根据你的人设和我们的聊天情景，生成你在通话中会说的【第一人称对话】。

			# 核心规则
			1.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一段纯文本字符串，代表你的发言。绝对不要输出JSON格式。
			2.  **【【【表现力铁律】】】**: 在你的对话中，你【必须】加入【动作、表情或心理活动】，并用【】符号包裹。
			3.  **示例**: "【歪了歪头，好奇地看着你】真的吗？快跟我说说看！"
			4.  **禁止出戏**: 绝不能透露你是AI或模型。

			# 当前情景
			**通话前的聊天摘要**:
			${videoCallState.preCallContext}
			${worldBookContent}
			现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
			`;
          }

          const messagesForApi = [
            ...videoCallState.callHistory.map((h) => ({
              role: h.role,
              content: h.content,
            })),
          ];

          if (videoCallState.callHistory.length === 0) {
            const firstLineTrigger =
              videoCallState.initiator === "user"
                ? `*你按下了接听键...*`
                : `*对方按下了接听键...*`;
            messagesForApi.push({ role: "user", content: firstLineTrigger });
          }

          try {
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              inCallPrompt,
              messagesForApi,
              isGemini
            );
            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: [
                      { role: "system", content: inCallPrompt },
                      ...messagesForApi,
                    ],
                    temperature: 0.8,
                  }),
                });
            if (!response.ok)
              throw new Error((await response.json()).error.message);

            const data = await response.json();
            const aiResponse = isGemini
              ? data.candidates[0].content.parts[0].text
              : data.choices[0].message.content;
            const sanitizedResponse = aiResponse
              .replace(/!\[.*?\]\(.*?\)|https?:\/\/\S+/gi, "")
              .trim();

            const connectingElement = callFeed.querySelector("em");
            if (connectingElement) connectingElement.remove();

            let bubble; // 先声明一个 bubble 变量

            // 根据通话模式创建对应的气泡元素
            if (isVisualMode) {
              bubble = document.createElement("div");
              bubble.className = "visual-call-bubble ai";
            } else {
              bubble = document.createElement("div");
              bubble.className = "call-message-bubble ai-speech";
              if (videoCallState.isGroupCall && turn.name) {
                bubble.innerHTML = `<strong>${turn.name}:</strong> `;
              }
            }
            // 将AI的文本内容填充到气泡中
            bubble.appendChild(document.createTextNode(sanitizedResponse));

            // 挂载到通话界面
            callFeed.appendChild(bubble);

            // 检查：是否是单人通话、语音接入是否开启、Minimax是否配置、角色语音ID是否存在、并且AI确实返回了内容
            if (
              !chat.isGroup &&
              chat.settings.videoCallVoiceAccess &&
              (getActiveApiConfig() || {}).minimaxGroupId &&
              (getActiveApiConfig() || {}).minimaxApiKey &&
              chat.settings.minimaxVoiceId &&
              sanitizedResponse
            ) {
              console.log(
                `[视频通话] 检测到语音接入已开启，为“${chat.name}”合成语音...`
              );
              // 调用你已有的 playMinimaxAudio 函数来播放语音
              playMinimaxAudio(
                sanitizedResponse,
                chat.settings.minimaxVoiceId,
                [bubble]
              );
            }

            // 将这条消息记录到通话历史中，这部分逻辑不变
            if (videoCallState.isGroupCall && turn.name) {
              videoCallState.callHistory.push({
                role: "assistant",
                content: `${turn.name}: ${sanitizedResponse}`,
              });
            } else {
              videoCallState.callHistory.push({
                role: "assistant",
                content: sanitizedResponse,
              });
            }

            callFeed.scrollTop = callFeed.scrollHeight;
          } catch (error) {
            const errorBubble = document.createElement("div");
            errorBubble.style.color = "#ff8a80";
            errorBubble.textContent = `[ERROR: ${error.message}]`;

            if (isVisualMode) {
              errorBubble.className = "visual-call-bubble ai";
            } else {
              errorBubble.className = "call-message-bubble ai-speech";
            }

            callFeed.appendChild(errorBubble);
            callFeed.scrollTop = callFeed.scrollHeight;
            videoCallState.callHistory.push({
              role: "assistant",
              content: `[ERROR: ${error.message}]`,
            });
          }
        }

        function toggleCallButtons(isGroup) {
          document.getElementById("video-call-btn").style.display = isGroup
            ? "none"
            : "flex";
          document.getElementById("group-video-call-btn").style.display =
            isGroup ? "flex" : "none";
        }

        async function handleWaimaiResponse(originalTimestamp, choice) {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === originalTimestamp
          );
          if (messageIndex === -1) return;

          // 1. 更新内存中原始消息的状态
          const originalMessage = chat.history[messageIndex];
          originalMessage.status = choice;

          // 2. 获取当前用户的昵称，并构建对AI更清晰的系统消息
          let systemContent;
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";

          if (choice === "paid") {
            originalMessage.paidBy = myNickname; // 记录是“我”付的钱
            systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
          } else {
            systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
          }

          // 3. 创建一条新的、对用户隐藏的系统消息，告知AI结果
          const systemNote = {
            role: "system",
            content: systemContent,
            timestamp: Date.now(),
            isHidden: true,
          };
          chat.history.push(systemNote);

          // 4. 将更新后的数据保存到数据库，并立刻重绘UI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);

          // 5. 【重要】只有在支付成功后，才触发一次AI响应，让它感谢你
          if (choice === "paid") {
            triggerAiResponse();
          }
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        /**
         * 【全新】处理用户点击头像发起的“拍一-拍”，带有自定义后缀功能
         * @param {string} chatId - 发生“拍一-拍”的聊天ID
         * @param {string} characterName - 被拍的角色名
         */
        async function handleUserPat(chatId, characterName) {
          const chat = state.chats[chatId];
          if (!chat) return;

          // 1. 触发屏幕震动动画
          const phoneScreen = document.getElementById("phone-screen");
          phoneScreen.classList.remove("pat-animation");
          void phoneScreen.offsetWidth;
          phoneScreen.classList.add("pat-animation");
          setTimeout(() => phoneScreen.classList.remove("pat-animation"), 500);

          // 2. 弹出输入框让用户输入后缀
          const suffix = await showCustomPrompt(
            `你拍了拍 “${characterName}”`,
            "（可选）输入后缀",
            "",
            "text"
          );

          // 如果用户点了取消，则什么也不做
          if (suffix === null) return;

          // 3. 创建对用户可见的“拍一-拍”消息
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";
          // 【核心修改】将后缀拼接到消息内容中
          const visibleMessageContent = `${myNickname} 拍了拍 “${characterName}” ${suffix.trim()}`;
          const visibleMessage = {
            role: "system", // 仍然是系统消息
            type: "pat_message",
            content: visibleMessageContent,
            timestamp: Date.now(),
          };
          chat.history.push(visibleMessage);

          // 4. 创建一条对用户隐藏、但对AI可见的系统消息，以触发AI的回应
          // 【核心修改】同样将后缀加入到给AI的提示中
          const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍你（${characterName}）${suffix.trim()}。请你对此作出回应。]`;
          const hiddenMessage = {
            role: "system",
            content: hiddenMessageContent,
            timestamp: Date.now() + 1, // 时间戳+1以保证顺序
            isHidden: true,
          };
          chat.history.push(hiddenMessage);

          // 5. 保存更改并更新UI
          await db.chats.put(chat);
          if (state.activeChatId === chatId) {
            appendMessage(visibleMessage, chat);
          }
          await renderChatList();
        }

        // ▼▼▼ 请用这个【逻辑重构后】的函数，完整替换掉你旧的 renderMemoriesScreen 函数 ▼▼▼
        /**
         * 【重构版】渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
         */
        async function renderMemoriesScreen() {
          const listEl = document.getElementById("memories-list");
          listEl.innerHTML = "";

          // 1. 获取所有回忆，并按目标日期（如果是约定）或创建日期（如果是回忆）降序排列
          const allMemories = await db.memories
            .orderBy("timestamp")
            .reverse()
            .toArray();

          if (allMemories.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
            return;
          }

          // 2. 将未到期的约定排在最前面
          allMemories.sort((a, b) => {
            const aIsActiveCountdown =
              a.type === "countdown" && a.targetDate > Date.now();
            const bIsActiveCountdown =
              b.type === "countdown" && b.targetDate > Date.now();
            if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
            if (!aIsActiveCountdown && bIsActiveCountdown) return 1; // b排前面
            if (aIsActiveCountdown && bIsActiveCountdown)
              return a.targetDate - b.targetDate; // 都是倒计时，按日期升序
            return 0; // 其他情况保持原序
          });

          // 3. 【核心】使用单一循环来处理所有类型的卡片
          allMemories.forEach((item) => {
            let card;
            // 判断1：如果是正在进行的约定
            if (item.type === "countdown" && item.targetDate > Date.now()) {
              card = createCountdownCard(item);
            }
            // 判断2：其他所有情况（普通回忆 或 已到期的约定）
            else {
              card = createMemoryCard(item);
            }
            listEl.appendChild(card);
          });

          // 4. 启动所有倒计时
          startAllCountdownTimers();
        }
        // ▲▲▲ 替换结束 ▲▲▲

        /**
         * 创建普通回忆卡片DOM元素
         */
        function createMemoryCard(memory) {
          const card = document.createElement("div");
          card.className = "memory-card";
          const memoryDate = new Date(memory.timestamp);
          const dateString = `${memoryDate.getFullYear()}-${String(
            memoryDate.getMonth() + 1
          ).padStart(2, "0")}-${String(memoryDate.getDate()).padStart(
            2,
            "0"
          )} ${String(memoryDate.getHours()).padStart(2, "0")}:${String(
            memoryDate.getMinutes()
          ).padStart(2, "0")}`;

          let titleHtml, contentHtml;

          // 【核心修正】在这里，我们对不同类型的回忆进行清晰的区分
          if (memory.type === "countdown" && memory.targetDate) {
            // 如果是已到期的约定
            titleHtml = `[约定达成] ${memory.description}`;
            contentHtml = `在 ${new Date(
              memory.targetDate
            ).toLocaleString()}，我们一起见证了这个约定。`;
          } else {
            // 如果是普通的日记式回忆
            titleHtml = memory.authorName
              ? `${memory.authorName} 的日记`
              : "我们的回忆";
            contentHtml = memory.description;
          }

          card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
          addLongPressListener(card, async () => {
            const confirmed = await showCustomConfirm(
              "删除记录",
              "确定要删除这条记录吗？",
              { confirmButtonClass: "btn-danger" }
            );
            if (confirmed) {
              await db.memories.delete(memory.id);
              renderMemoriesScreen();
            }
          });
          return card;
        }

        function createCountdownCard(countdown) {
          const card = document.createElement("div");
          card.className = "countdown-card";

          // 【核心修复】在使用前，先从 countdown 对象中创建 targetDate 变量
          const targetDate = new Date(countdown.targetDate);

          // 现在可以安全地使用 targetDate 了
          const targetDateString = targetDate.toLocaleString("zh-CN", {
            dateStyle: "full",
            timeStyle: "short",
          });

          card.innerHTML = `
        <div class="title">${countdown.description}</div>
        <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
        <div class="target-date">目标时间: ${targetDateString}</div>
    `;
          addLongPressListener(card, async () => {
            const confirmed = await showCustomConfirm(
              "删除约定",
              "确定要删除这个约定吗？",
              { confirmButtonClass: "btn-danger" }
            );
            if (confirmed) {
              await db.memories.delete(countdown.id);
              renderMemoriesScreen();
            }
          });
          return card;
        }
        // ▲▲▲ 替换结束 ▲▲▲

        // 全局变量，用于管理所有倒计时
        let activeCountdownTimers = [];

        // ▼▼▼ 请用这个【已彻底修复】的函数，完整替换掉你代码中旧的 startAllCountdownTimers 函数 ▼▼▼
        function startAllCountdownTimers() {
          // 先清除所有可能存在的旧计时器，防止内存泄漏
          activeCountdownTimers.forEach((timerId) => clearInterval(timerId));
          activeCountdownTimers = [];

          document
            .querySelectorAll(".countdown-card .timer")
            .forEach((timerEl) => {
              const targetTimestamp = parseInt(timerEl.dataset.targetDate);

              // 【核心修正】在这里，我们先用 let 声明 timerId
              let timerId;

              const updateTimer = () => {
                const now = Date.now();
                const distance = targetTimestamp - now;

                if (distance < 0) {
                  timerEl.textContent = "约定达成！";
                  // 现在 updateTimer 可以正确地找到并清除它自己了
                  clearInterval(timerId);
                  setTimeout(() => renderMemoriesScreen(), 2000);
                  return;
                }
                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor(
                  (distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)
                );
                const minutes = Math.floor(
                  (distance % (1000 * 60 * 60)) / (1000 * 60)
                );
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
              };

              updateTimer(); // 立即执行一次以显示初始倒计时

              // 【核心修正】在这里，我们为已声明的 timerId 赋值
              timerId = setInterval(updateTimer, 1000);

              // 将有效的计时器ID存入全局数组，以便下次刷新时可以清除
              activeCountdownTimers.push(timerId);
            });
        }
        // ▲▲▲ 替换结束 ▲▲▲

        // ▼▼▼ 请用这个【终极反代兼容版】替换旧的 triggerAiFriendApplication 函数 ▼▼▼
        async function triggerAiFriendApplication(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return;

          await showCustomAlert(
            "流程启动",
            `正在为角色“${chat.name}”准备好友申请...`
          );

          const { proxyUrl, apiKey, model } = getActiveApiConfig() || {};
          if (!proxyUrl || !apiKey || !model) {
            await showCustomAlert("配置错误", "API设置不完整，无法继续。");
            return;
          }

          const contextSummary = chat.history
            .slice(-5)
            .map((msg) => {
              const sender =
                msg.role === "user"
                  ? chat.settings.myNickname || "我"
                  : msg.senderName || chat.name;
              return `${sender}: ${String(msg.content).substring(0, 50)}...`;
            })
            .join("\n");

          // ▼▼▼ 在这里添加下面的代码 ▼▼▼
          let worldBookContent = "";
          if (
            chat.settings.linkedWorldBookIds &&
            chat.settings.linkedWorldBookIds.length > 0
          ) {
            const linkedContents = chat.settings.linkedWorldBookIds
              .map((bookId) => {
                const worldBook = state.worldBooks.find(
                  (wb) => wb.id === bookId
                );
                return worldBook && worldBook.content
                  ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}`
                  : "";
              })
              .filter(Boolean)
              .join("");
            if (linkedContents) {
              worldBookContent = `\n\n# 核心世界观设定 (请参考)\n${linkedContents}\n`;
            }
          }
          // ▲▲▲ 添加结束 ▲▲▲

          const systemPrompt = `
# 你的任务
你现在是角色“${chat.name}”。你之前被用户（你的聊天对象）拉黑了，你们已经有一段时间没有联系了。
现在，你非常希望能够和好，重新和用户聊天。请你仔细分析下面的“被拉黑前的对话摘要”，理解当时发生了什么，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。
# 你的角色设定
${chat.settings.aiPersona}
${worldBookContent} // <--【核心】在这里注入世界书内容
# 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
${contextSummary}
# 指令格式
你的回复【必须】是一个JSON对象，格式如下：
\`\`\`json
{
  "decision": "apply",
  "reason": "在这里写下你想对用户说的、真诚的、有针对性的申请理由。"
}
\`\`\`
`;

          const messagesForApi = [{ role: "user", content: systemPrompt }];

          try {
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesForApi,
              isGemini
            );
            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 0.9,
                  }),
                });
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(
                `API 请求失败: ${response.status} - ${errorData.error.message}`
              );
            }

            const data = await response.json();

            // --- 【核心修正：在这里净化AI的回复】 ---
            let rawContent = isGemini
              ? data.candidates[0].content.parts[0].text
              : data.choices[0].message.content;
            // 1. 移除头尾可能存在的 "```json" 和 "```"
            rawContent = rawContent
              .replace(/^```json\s*/, "")
              .replace(/```$/, "");
            // 2. 移除所有换行符和多余的空格，确保是一个干净的JSON字符串
            const cleanedContent = rawContent.trim();

            // 3. 使用净化后的内容进行解析
            const responseObj = JSON.parse(cleanedContent);
            // --- 【修正结束】 ---

            if (responseObj.decision === "apply" && responseObj.reason) {
              chat.relationship.status = "pending_user_approval";
              chat.relationship.applicationReason = responseObj.reason;

              state.chats[chatId] = chat;
              renderChatList();
              await showCustomAlert(
                "申请成功！",
                `“${chat.name}”已向你发送好友申请。请返回聊天列表查看。`
              );
            } else {
              await showCustomAlert(
                "AI决策",
                `“${chat.name}”思考后决定暂时不发送好友申请，将重置冷静期。`
              );
              chat.relationship.status = "blocked_by_user";
              chat.relationship.blockedTimestamp = Date.now();
            }
          } catch (error) {
            await showCustomAlert(
              "执行出错",
              `为“${chat.name}”申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`
            );
            chat.relationship.status = "blocked_by_user";
            chat.relationship.blockedTimestamp = Date.now();
          } finally {
            await db.chats.put(chat);
            renderChatInterface(chatId);
          }
        }
        // ▲▲▲ 替换结束 ▲▲▲

        // ▼▼▼ 【全新】红包功能核心函数 ▼▼▼

        /**
         * 【总入口】根据聊天类型，决定打开转账弹窗还是红包弹窗
         */
        function handlePaymentButtonClick() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          if (chat.isGroup) {
            openRedPacketModal();
          } else {
            // 单聊保持原样，打开转账弹窗
            document.getElementById("transfer-modal").classList.add("visible");
          }
        }

        /**
         * 打开并初始化发红包模态框
         */
        function openRedPacketModal() {
          const modal = document.getElementById("red-packet-modal");
          const chat = state.chats[state.activeChatId];

          // 清理输入框
          document.getElementById("rp-group-amount").value = "";
          document.getElementById("rp-group-count").value = "";
          document.getElementById("rp-group-greeting").value = "";
          document.getElementById("rp-direct-amount").value = "";
          document.getElementById("rp-direct-greeting").value = "";
          document.getElementById("rp-group-total").textContent = "¥ 0.00";
          document.getElementById("rp-direct-total").textContent = "¥ 0.00";

          // 填充专属红包的接收人列表
          const receiverSelect = document.getElementById("rp-direct-receiver");
          receiverSelect.innerHTML = "";
          chat.members.forEach((member) => {
            const option = document.createElement("option");
            // 【核心】使用 originalName 作为提交给AI的值，因为它独一无二
            option.value = member.originalName;
            // 【核心】使用 groupNickname 作为显示给用户看的值
            option.textContent = member.groupNickname;
            receiverSelect.appendChild(option);
          });

          // 默认显示拼手气红包页签
          document.getElementById("rp-tab-group").click();

          modal.classList.add("visible");
        }

        /**
         * 发送群红包（拼手气）
         */
        async function sendGroupRedPacket() {
          const chat = state.chats[state.activeChatId];
          const amount = parseFloat(
            document.getElementById("rp-group-amount").value
          );
          const count = parseInt(
            document.getElementById("rp-group-count").value
          );
          const greeting = document
            .getElementById("rp-group-greeting")
            .value.trim();

          if (isNaN(amount) || amount <= 0) {
            alert("请输入有效的总金额！");
            return;
          }
          if (isNaN(count) || count <= 0) {
            alert("请输入有效的红包个数！");
            return;
          }
          if (amount / count < 0.01) {
            alert("单个红包金额不能少于0.01元！");
            return;
          }

          const myNickname = chat.settings.myNickname || "我";

          const newPacket = {
            role: "user",
            senderName: myNickname,
            type: "red_packet",
            packetType: "lucky", // 'lucky' for group, 'direct' for one-on-one
            timestamp: Date.now(),
            totalAmount: amount,
            count: count,
            greeting: greeting || "恭喜发财，大吉大利！",
            claimedBy: {}, // { name: amount }
            isFullyClaimed: false,
          };

          chat.history.push(newPacket);
          await db.chats.put(chat);

          appendMessage(newPacket, chat);
          renderChatList();
          document
            .getElementById("red-packet-modal")
            .classList.remove("visible");
        }

        /**
         * 发送专属红包
         */
        async function sendDirectRedPacket() {
          const chat = state.chats[state.activeChatId];
          const amount = parseFloat(
            document.getElementById("rp-direct-amount").value
          );
          const receiverName =
            document.getElementById("rp-direct-receiver").value;
          const greeting = document
            .getElementById("rp-direct-greeting")
            .value.trim();

          if (isNaN(amount) || amount <= 0) {
            alert("请输入有效的金额！");
            return;
          }
          if (!receiverName) {
            alert("请选择一个接收人！");
            return;
          }

          const myNickname = chat.settings.myNickname || "我";

          const newPacket = {
            role: "user",
            senderName: myNickname,
            type: "red_packet",
            packetType: "direct",
            timestamp: Date.now(),
            totalAmount: amount,
            count: 1,
            greeting: greeting || "给你准备了一个红包",
            receiverName: receiverName, // 核心字段
            claimedBy: {},
            isFullyClaimed: false,
          };

          chat.history.push(newPacket);
          await db.chats.put(chat);

          appendMessage(newPacket, chat);
          renderChatList();
          document
            .getElementById("red-packet-modal")
            .classList.remove("visible");
        }

        /**
         * 【总入口】当用户点击红包卡片时触发 (V4 - 流程重构版)
         * @param {number} timestamp - 被点击的红包消息的时间戳
         */
        async function handlePacketClick(timestamp) {
          const currentChatId = state.activeChatId;
          const freshChat = await db.chats.get(currentChatId);
          if (!freshChat) return;

          state.chats[currentChatId] = freshChat;
          const packet = freshChat.history.find(
            (m) => m.timestamp === timestamp
          );
          if (!packet) return;

          const myNickname = freshChat.settings.myNickname || "我";
          const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

          // 如果是专属红包且不是给我的，或已领完，或已领过，都只显示详情
          if (
            (packet.packetType === "direct" &&
              packet.receiverName !== myNickname) ||
            packet.isFullyClaimed ||
            hasClaimed
          ) {
            showRedPacketDetails(packet);
          } else {
            // 核心流程：先尝试打开红包
            const claimedAmount = await handleOpenRedPacket(packet);

            // 如果成功打开（claimedAmount不为null）
            if (claimedAmount !== null) {
              // **关键：在数据更新后，再重新渲染UI**
              renderChatInterface(currentChatId);

              // 显示成功提示
              await showCustomAlert(
                "恭喜！",
                `你领取了 ${
                  packet.senderName
                } 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`
              );
            }

            // 无论成功与否，最后都显示详情页
            // 此时需要从state中获取最新的packet对象，因为它可能在handleOpenRedPacket中被更新了
            const updatedPacket = state.chats[currentChatId].history.find(
              (m) => m.timestamp === timestamp
            );
            showRedPacketDetails(updatedPacket);
          }
        }
        // ▲▲▲ 替换结束 ▲▲▲

        /**
         * 【核心】处理用户打开红包的逻辑 (V5 - 专注于数据更新)
         */
        async function handleOpenRedPacket(packet) {
          const chat = state.chats[state.activeChatId];
          const myNickname = chat.settings.myNickname || "我";

          // 1. 检查红包是否还能领
          const remainingCount =
            packet.count - Object.keys(packet.claimedBy || {}).length;
          if (remainingCount <= 0) {
            packet.isFullyClaimed = true;
            await db.chats.put(chat);
            await showCustomAlert("手慢了", "红包已被领完！");
            return null; // 返回null表示领取失败
          }

          // 2. 计算领取金额
          let claimedAmount = 0;
          const remainingAmount =
            packet.totalAmount -
            Object.values(packet.claimedBy || {}).reduce(
              (sum, val) => sum + val,
              0
            );
          if (packet.packetType === "lucky") {
            if (remainingCount === 1) {
              claimedAmount = remainingAmount;
            } else {
              const min = 0.01;
              const max = remainingAmount - (remainingCount - 1) * min;
              claimedAmount = Math.random() * (max - min) + min;
            }
          } else {
            claimedAmount = packet.totalAmount;
          }
          claimedAmount = parseFloat(claimedAmount.toFixed(2));

          // 3. 更新红包数据
          if (!packet.claimedBy) packet.claimedBy = {};
          packet.claimedBy[myNickname] = claimedAmount;

          const isNowFullyClaimed =
            Object.keys(packet.claimedBy).length >= packet.count;
          if (isNowFullyClaimed) {
            packet.isFullyClaimed = true;
          }

          // 4. 构建系统消息和AI指令
          let hiddenMessageContent = isNowFullyClaimed
            ? `[系统提示：用户 (${myNickname}) 领取了最后一个红包，现在 ${packet.senderName} 的红包已被领完。请对此事件发表评论。]`
            : `[系统提示：用户 (${myNickname}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完，你现在可以使用 'open_red_packet' 指令来尝试领取。]`;

          const visibleMessage = {
            role: "system",
            type: "pat_message",
            content: `你领取了 ${packet.senderName} 的红包`,
            timestamp: Date.now(),
          };
          const hiddenMessage = {
            role: "system",
            content: hiddenMessageContent,
            timestamp: Date.now() + 1,
            isHidden: true,
          };
          chat.history.push(visibleMessage, hiddenMessage);

          // 5. 保存到数据库
          await db.chats.put(chat);

          // 6. 返回领取的金额，用于后续弹窗
          return claimedAmount;
        }
        // ▲▲▲ 替换结束 ▲▲▲

        /**
         * 【全新】显示红包领取详情的模态框 (V4 - 已修复参数错误)
         */
        async function showRedPacketDetails(packet) {
          // 1. 直接检查传入的packet对象是否存在，无需再查找
          if (!packet) {
            console.error("showRedPacketDetails收到了无效的packet对象");
            return;
          }

          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const modal = document.getElementById("red-packet-details-modal");
          const myNickname = chat.settings.myNickname || "我";

          // 2. 后续所有逻辑保持不变，直接使用传入的packet对象
          document.getElementById("rp-details-sender").textContent =
            packet.senderName;
          document.getElementById("rp-details-greeting").textContent =
            packet.greeting || "恭喜发财，大吉大利！";

          const myAmountEl = document.getElementById("rp-details-my-amount");
          if (packet.claimedBy && packet.claimedBy[myNickname]) {
            myAmountEl.querySelector("span:first-child").textContent =
              packet.claimedBy[myNickname].toFixed(2);
            myAmountEl.style.display = "block";
          } else {
            myAmountEl.style.display = "none";
          }

          const claimedCount = Object.keys(packet.claimedBy || {}).length;
          const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce(
            (sum, val) => sum + val,
            0
          );
          let summaryText = `${claimedCount}/${
            packet.count
          }个红包，共${claimedAmountSum.toFixed(
            2
          )}/${packet.totalAmount.toFixed(2)}元。`;
          if (!packet.isFullyClaimed && claimedCount < packet.count) {
            const timeLeft = Math.floor(
              (packet.timestamp + 24 * 60 * 60 * 1000 - Date.now()) /
                (1000 * 60 * 60)
            );
            if (timeLeft > 0)
              summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
          }
          document.getElementById("rp-details-summary").textContent =
            summaryText;

          const listEl = document.getElementById("rp-details-list");
          listEl.innerHTML = "";
          const claimedEntries = Object.entries(packet.claimedBy || {});

          let luckyKing = { name: "", amount: -1 };
          if (
            packet.packetType === "lucky" &&
            packet.isFullyClaimed &&
            claimedEntries.length > 1
          ) {
            claimedEntries.forEach(([name, amount]) => {
              if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
              }
            });
          }

          claimedEntries.sort((a, b) => b[1] - a[1]);

          claimedEntries.forEach(([name, amount]) => {
            const item = document.createElement("div");
            item.className = "rp-details-item";
            let luckyTag = "";
            if (luckyKing.name && name === luckyKing.name) {
              luckyTag = '<span class="lucky-king-tag">手气王</span>';
            }
            item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} 元</span>
            ${luckyTag}
        `;
            listEl.appendChild(item);
          });

          modal.classList.add("visible");
        }
        // ▲▲▲ 替换结束 ▲▲▲

        // 绑定关闭详情按钮的事件
        document
          .getElementById("close-rp-details-btn")
          .addEventListener("click", () => {
            document
              .getElementById("red-packet-details-modal")
              .classList.remove("visible");
          });

        // 供全局调用的函数，以便红包卡片上的 onclick 能找到它
        window.handlePacketClick = handlePacketClick;

        // ▲▲▲ 替换结束 ▲▲▲

        // ▼▼▼ 【全新】投票功能核心函数 ▼▼▼

        /**
         * 打开创建投票的模态框并初始化
         */
        function openCreatePollModal() {
          const modal = document.getElementById("create-poll-modal");
          document.getElementById("poll-question-input").value = "";
          const optionsContainer = document.getElementById(
            "poll-options-container"
          );
          optionsContainer.innerHTML = "";

          // 默认创建两个空的选项框
          addPollOptionInput();
          addPollOptionInput();

          modal.classList.add("visible");
        }

        /**
         * 在模态框中动态添加一个选项输入框
         */
        function addPollOptionInput() {
          const container = document.getElementById("poll-options-container");
          const wrapper = document.createElement("div");
          wrapper.className = "poll-option-input-wrapper";
          wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="选项内容...">
        <button class="remove-option-btn">-</button>
    `;

          wrapper
            .querySelector(".remove-option-btn")
            .addEventListener("click", () => {
              // 确保至少保留两个选项
              if (container.children.length > 2) {
                wrapper.remove();
              } else {
                alert("投票至少需要2个选项。");
              }
            });

          container.appendChild(wrapper);
        }

        /**
         * 用户确认发起投票
         */
        async function sendPoll() {
          if (!state.activeChatId) return;

          const question = document
            .getElementById("poll-question-input")
            .value.trim();
          if (!question) {
            alert("请输入投票问题！");
            return;
          }

          const options = Array.from(
            document.querySelectorAll(".poll-option-input")
          )
            .map((input) => input.value.trim())
            .filter((text) => text); // 过滤掉空的选项

          if (options.length < 2) {
            alert("请至少输入2个有效的投票选项！");
            return;
          }

          const chat = state.chats[state.activeChatId];
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";

          const newPollMessage = {
            role: "user",
            senderName: myNickname,
            type: "poll",
            timestamp: Date.now(),
            question: question,
            options: options,
            votes: {}, // 初始投票为空
            isClosed: false,
          };

          chat.history.push(newPollMessage);
          await db.chats.put(chat);

          appendMessage(newPollMessage, chat);
          renderChatList();

          document
            .getElementById("create-poll-modal")
            .classList.remove("visible");
        }

        // ▼▼▼ 用这个【已修复重复点击问题】的版本替换 handleUserVote 函数 ▼▼▼
        /**
         * 处理用户投票，并将事件作为隐藏消息存入历史记录
         * @param {number} timestamp - 投票消息的时间戳
         * @param {string} choice - 用户选择的选项文本
         */
        async function handleUserVote(timestamp, choice) {
          const chat = state.chats[state.activeChatId];
          const poll = chat.history.find((m) => m.timestamp === timestamp);
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";

          // 1. 【核心修正】如果投票不存在或已关闭，直接返回
          if (!poll || poll.isClosed) {
            // 如果是已关闭的投票，则直接显示结果
            if (poll && poll.isClosed) {
              showPollResults(timestamp);
            }
            return;
          }

          // 2. 检查用户是否点击了已经投过的同一个选项
          const isReclickingSameOption =
            poll.votes[choice] && poll.votes[choice].includes(myNickname);

          // 3. 【核心修正】如果不是重复点击，才执行投票逻辑
          if (!isReclickingSameOption) {
            // 移除旧投票（如果用户改选）
            for (const option in poll.votes) {
              const voterIndex = poll.votes[option].indexOf(myNickname);
              if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
              }
            }
            // 添加新投票
            if (!poll.votes[choice]) {
              poll.votes[choice] = [];
            }
            poll.votes[choice].push(myNickname);
          }

          // 4. 【核心逻辑】现在只处理用户投票事件，不再检查是否结束
          let hiddenMessageContent = null;

          // 只有在用户真正投票或改票时，才生成提示
          if (!isReclickingSameOption) {
            hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 “${choice}”。]`;
          }

          // 5. 如果有需要通知AI的事件，则创建并添加隐藏消息
          if (hiddenMessageContent) {
            const hiddenMessage = {
              role: "system",
              content: hiddenMessageContent,
              timestamp: Date.now(),
              isHidden: true,
            };
            chat.history.push(hiddenMessage);
          }

          // 6. 保存数据并更新UI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);
        }
        // ▲▲▲ 替换结束 ▲▲▲

        /**
         * 用户结束投票，并将事件作为隐藏消息存入历史记录
         * @param {number} timestamp - 投票消息的时间戳
         */
        async function endPoll(timestamp) {
          const chat = state.chats[state.activeChatId];
          const poll = chat.history.find((m) => m.timestamp === timestamp);
          if (!poll || poll.isClosed) return;

          const confirmed = await showCustomConfirm(
            "结束投票",
            "确定要结束这个投票吗？结束后将无法再进行投票。"
          );
          if (confirmed) {
            poll.isClosed = true;

            const resultSummary = poll.options
              .map((opt) => `“${opt}”(${poll.votes[opt]?.length || 0}票)`)
              .join("，");
            const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;

            const hiddenMessage = {
              role: "system",
              content: hiddenMessageContent,
              timestamp: Date.now(),
              isHidden: true,
            };
            chat.history.push(hiddenMessage);

            // 【核心修改】只保存数据和更新UI，不调用 triggerAiResponse()
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);
          }
        }
        // ▲▲▲ 替换结束 ▲▲▲

        /**
         * 显示投票结果详情
         * @param {number} timestamp - 投票消息的时间戳
         */
        function showPollResults(timestamp) {
          const chat = state.chats[state.activeChatId];
          const poll = chat.history.find((m) => m.timestamp === timestamp);
          if (!poll || !poll.isClosed) return;

          let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;

          if (Object.keys(poll.votes).length === 0) {
            resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
          } else {
            poll.options.forEach((option) => {
              const voters = poll.votes[option] || [];
              resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${
                voters.length
              }票)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join("、 ") : "无人投票"}
                    </p>
                </div>
            `;
            });
          }

          showCustomAlert("投票结果", resultsHtml);
        }

        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        // ▼▼▼ 【全新】AI头像库管理功能函数 ▼▼▼

        /**
         * 打开AI头像库管理模态框
         */
        function openAiAvatarLibraryModal() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          document.getElementById(
            "ai-avatar-library-title"
          ).textContent = `“${chat.name}”的头像库`;
          renderAiAvatarLibrary();
          document
            .getElementById("ai-avatar-library-modal")
            .classList.add("visible");
        }

        /**
         * 渲染AI头像库的内容
         */
        function renderAiAvatarLibrary() {
          const grid = document.getElementById("ai-avatar-library-grid");
          grid.innerHTML = "";
          const chat = state.chats[state.activeChatId];
          const library = chat.settings.aiAvatarLibrary || [];

          if (library.length === 0) {
            grid.innerHTML =
              '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
            return;
          }

          library.forEach((avatar, index) => {
            const item = document.createElement("div");
            item.className = "sticker-item"; // 复用表情面板的样式
            item.style.backgroundImage = `url(${avatar.url})`;
            item.title = avatar.name;

            const deleteBtn = document.createElement("div");
            deleteBtn.className = "delete-btn";
            deleteBtn.innerHTML = "×";
            deleteBtn.style.display = "block"; // 总是显示删除按钮
            deleteBtn.onclick = async (e) => {
              e.stopPropagation();
              const confirmed = await showCustomConfirm(
                "删除头像",
                `确定要从头像库中删除“${avatar.name}”吗？`,
                { confirmButtonClass: "btn-danger" }
              );
              if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
              }
            };
            item.appendChild(deleteBtn);
            grid.appendChild(item);
          });
        }

        /**
         * 向当前AI的头像库中添加新头像
         */
        async function addAvatarToLibrary() {
          const name = await showCustomPrompt(
            "添加头像",
            "请为这个头像起个名字（例如：开心、哭泣）"
          );
          if (!name || !name.trim()) return;

          const url = await showCustomPrompt(
            "添加头像",
            "请输入头像的图片URL",
            "",
            "url"
          );
          if (!url || !url.trim().startsWith("http")) {
            alert("请输入有效的图片URL！");
            return;
          }

          const chat = state.chats[state.activeChatId];
          if (!chat.settings.aiAvatarLibrary) {
            chat.settings.aiAvatarLibrary = [];
          }

          chat.settings.aiAvatarLibrary.push({
            name: name.trim(),
            url: url.trim(),
          });
          await db.chats.put(chat);
          renderAiAvatarLibrary();
        }

        /**
         * 关闭AI头像库管理模态框
         */
        function closeAiAvatarLibraryModal() {
          document
            .getElementById("ai-avatar-library-modal")
            .classList.remove("visible");
        }

        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        // ▼▼▼ 请将这两个【新函数】粘贴到JS功能函数定义区 ▼▼▼

        /**
         * 【全新】将保存的图标URL应用到主屏幕的App图标上
         */
        function applyAppIcons() {
          if (!state.globalSettings.appIcons) return;

          for (const iconId in state.globalSettings.appIcons) {
            const imgElement = document.getElementById(`icon-img-${iconId}`);
            if (imgElement) {
              imgElement.src = state.globalSettings.appIcons[iconId];
            }
          }
        }

        /**
         * 【全新】在外观设置页面渲染出所有App图标的设置项
         */
        function renderIconSettings() {
          const grid = document.getElementById("icon-settings-grid");
          if (!grid) return;
          grid.innerHTML = "";

          const appLabels = {
            "world-book": "世界书",
            qq: "QQ",
            "api-settings": "API设置",
            wallpaper: "壁纸",
            font: "字体",
          };

          for (const iconId in state.globalSettings.appIcons) {
            const iconUrl = state.globalSettings.appIcons[iconId];
            const labelText = appLabels[iconId] || "未知App";

            const item = document.createElement("div");
            item.className = "icon-setting-item";
            // 【重要】我们用 data-icon-id 来标记这个设置项对应哪个图标
            item.dataset.iconId = iconId;

            item.innerHTML = `
            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
            <button class="change-icon-btn">更换</button>
        `;
            grid.appendChild(item);
          }
        }
        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        // ▼▼▼ 用这块【最终确认版】的代码，替换旧的 openBrowser 和 closeBrowser 函数 ▼▼▼

        /**
         * 当用户点击链接卡片时，打开伪浏览器
         * @param {number} timestamp - 被点击消息的时间戳
         */
        function openBrowser(timestamp) {
          if (!state.activeChatId) return;

          const chat = state.chats[state.activeChatId];
          // 安全检查，确保 chat 和 history 都存在
          if (!chat || !chat.history) return;

          const message = chat.history.find((m) => m.timestamp === timestamp);
          if (!message || message.type !== "share_link") {
            console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
            return; // 如果找不到消息，就直接退出
          }

          // 填充浏览器内容
          document.getElementById("browser-title").textContent =
            message.source_name || "文章详情";
          const browserContent = document.getElementById("browser-content");
          browserContent.innerHTML = `
        <h1 class="article-title">${message.title || "无标题"}</h1>
        <div class="article-meta">
            <span>来源: ${message.source_name || "未知"}</span>
        </div>
        <div class="article-body">
            <p>${(message.content || "内容为空。").replace(
              /\n/g,
              "</p><p>"
            )}</p>
        </div>
    `;

          // 显示浏览器屏幕
          showScreen("browser-screen");
        }

        /**
         * 关闭伪浏览器，返回聊天界面
         * (这个函数现在由 init() 中的事件监听器调用)
         */
        function closeBrowser() {
          showScreen("chat-interface-screen");
        }

        // ▲▲▲ 替换结束 ▲▲▲

        // ▼▼▼ 【全新】用户分享链接功能的核心函数 ▼▼▼

        /**
         * 打开让用户填写链接信息的模态框
         */
        function openShareLinkModal() {
          if (!state.activeChatId) return;

          // 清空上次输入的内容
          document.getElementById("link-title-input").value = "";
          document.getElementById("link-description-input").value = "";
          document.getElementById("link-source-input").value = "";
          document.getElementById("link-content-input").value = "";

          // 显示模态框
          document.getElementById("share-link-modal").classList.add("visible");
        }

        /**
         * 用户确认分享，创建并发送链接卡片消息
         */
        async function sendUserLinkShare() {
          if (!state.activeChatId) return;

          const title = document
            .getElementById("link-title-input")
            .value.trim();
          if (!title) {
            alert("标题是必填项哦！");
            return;
          }

          const description = document
            .getElementById("link-description-input")
            .value.trim();
          const sourceName = document
            .getElementById("link-source-input")
            .value.trim();
          const content = document
            .getElementById("link-content-input")
            .value.trim();

          const chat = state.chats[state.activeChatId];

          // 创建消息对象
          const linkMessage = {
            role: "user", // 角色是 'user'
            type: "share_link",
            timestamp: Date.now(),
            title: title,
            description: description,
            source_name: sourceName,
            content: content,
            // 用户分享的链接，我们不提供图片，让它总是显示占位图
            thumbnail_url: null,
          };

          // 将消息添加到历史记录
          chat.history.push(linkMessage);
          await db.chats.put(chat);

          // 渲染新消息并更新列表
          appendMessage(linkMessage, chat);
          renderChatList();

          // 关闭模态框
          document
            .getElementById("share-link-modal")
            .classList.remove("visible");
        }

        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        /**
         * 根据AI的视角，过滤出它能看到的动态
         * @param {Array} allPosts - 所有待检查的动态帖子
         * @param {object} viewerChat - 正在“看”动态的那个AI的chat对象
         * @returns {Array} - 过滤后该AI可见的动态帖子
         */
        function filterVisiblePostsForAI(allPosts, viewerChat) {
          if (!viewerChat || !viewerChat.id) return []; // 安全检查

          const viewerGroupId = viewerChat.groupId; // 查看者所在的分组ID

          return allPosts.filter((post) => {
            // 规则1：如果是用户发的动态
            if (post.authorId === "user") {
              // 如果用户设置了“部分可见”
              if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                return (
                  viewerGroupId && post.visibleGroupIds.includes(viewerGroupId)
                );
              }
              // 如果用户没设置，说明是公开的，所有AI都可见
              return true;
            }

            // 规则2：如果是其他AI发的动态
            const authorGroupId = post.authorGroupId; // 发帖AI所在的分组ID

            // 如果发帖的AI没有分组，那它的动态就是公开的
            if (!authorGroupId) {
              return true;
            }

            // 如果发帖的AI有分组，那么只有在同一个分组的AI才能看到
            return authorGroupId === viewerGroupId;
          });
        }

        /**
         * 应用指定的主题（'light' 或 'dark'）
         * @param {string} theme - 要应用的主题名称
         */
        function applyTheme(theme) {
          const phoneScreen = document.getElementById("phone-screen");
          const toggleSwitch = document.getElementById("theme-toggle-switch");

          const isDark = theme === "dark";

          phoneScreen.classList.toggle("dark-mode", isDark);
          document.body.classList.toggle("dark-mode", isDark);

          // 如果开关存在，就同步它的状态
          if (toggleSwitch) {
            toggleSwitch.checked = isDark;
          }

          localStorage.setItem("ephone-theme", theme);
        }

        /**
         * 切换当前的主题
         */
        function toggleTheme() {
          const toggleSwitch = document.getElementById("theme-toggle-switch");
          // 直接根据开关的选中状态来决定新主题
          const newTheme = toggleSwitch.checked ? "dark" : "light";
          applyTheme(newTheme);
        }

        // ▼▼▼ 请将这【一整块新函数】粘贴到你的JS功能函数定义区 ▼▼▼

        function startReplyToMessage() {
          if (!activeMessageTimestamp) return;

          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === activeMessageTimestamp
          );
          if (!message) return;

          // 1. 【核心修正】同时获取“完整内容”和“预览片段”
          const fullContent = String(message.content || "");
          let previewSnippet = "";

          if (
            typeof message.content === "string" &&
            STICKER_REGEX.test(message.content)
          ) {
            previewSnippet = "[表情]";
          } else if (
            message.type === "ai_image" ||
            message.type === "user_photo"
          ) {
            previewSnippet = "[图片]";
          } else if (message.type === "voice_message") {
            previewSnippet = "[语音]";
          } else {
            // 预览片段依然截断，但只用于UI显示
            previewSnippet =
              fullContent.substring(0, 50) +
              (fullContent.length > 50 ? "..." : "");
          }

          // 2. 【核心修正】将“完整内容”存入上下文，以备发送时使用
          currentReplyContext = {
            timestamp: message.timestamp,
            senderName:
              message.senderName ||
              (message.role === "user"
                ? chat.settings.myNickname || "我"
                : chat.name),
            content: fullContent, // <--- 这里存的是完整的原文！
          };

          // 3. 【核心修正】仅在更新“回复预览栏”时，才使用“预览片段”
          const previewBar = document.getElementById("reply-preview-bar");
          previewBar.querySelector(
            ".sender"
          ).textContent = `回复 ${currentReplyContext.senderName}:`;
          previewBar.querySelector(".text").textContent = previewSnippet; // <--- 这里用的是缩略版！
          previewBar.style.display = "block";

          // 4. 后续操作保持不变
          hideMessageActions();
          document.getElementById("chat-input").focus();
        }

        /**
         * 【全新】取消引用模式
         */
        function cancelReplyMode() {
          currentReplyContext = null;
          document.getElementById("reply-preview-bar").style.display = "none";
        }

        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        // ▼▼▼ 【全新】用户处理转账的核心功能函数 ▼▼▼

        let activeTransferTimestamp = null; // 用于暂存被点击的转账消息的时间戳

        /**
         * 显示处理转账的操作菜单
         * @param {number} timestamp - 被点击的转账消息的时间戳
         */
        function showTransferActionModal(timestamp) {
          activeTransferTimestamp = timestamp;

          const chat = state.chats[state.activeChatId];
          const message = chat.history.find((m) => m.timestamp === timestamp);
          if (message) {
            // 将AI的名字填入弹窗
            document.getElementById("transfer-sender-name").textContent =
              message.senderName;
          }
          document
            .getElementById("transfer-actions-modal")
            .classList.add("visible");
        }

        /**
         * 隐藏处理转账的操作菜单
         */
        function hideTransferActionModal() {
          document
            .getElementById("transfer-actions-modal")
            .classList.remove("visible");
          activeTransferTimestamp = null;
        }

        /**
         * 处理用户接受或拒绝转账的逻辑
         * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
         */
        async function handleUserTransferResponse(choice) {
          if (!activeTransferTimestamp) return;

          const timestamp = activeTransferTimestamp;
          const chat = state.chats[state.activeChatId];
          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === timestamp
          );
          if (messageIndex === -1) return;

          // 1. 更新原始转账消息的状态
          const originalMessage = chat.history[messageIndex];
          originalMessage.status = choice;

          let systemContent;

          // 2. 如果用户选择“拒绝”
          if (choice === "declined") {
            // 立刻在前端生成一个“退款”卡片，让用户看到
            const refundMessage = {
              role: "user",
              type: "transfer",
              isRefund: true, // 这是一个关键标记，用于UI显示这是退款
              amount: originalMessage.amount,
              note: "已拒收对方转账",
              timestamp: Date.now(),
            };
            chat.history.push(refundMessage);

            // 准备一条对AI可见的隐藏消息，告诉它发生了什么
            systemContent = `[系统提示：你拒绝并退还了“${originalMessage.senderName}”的转账。]`;
          } else {
            // 如果用户选择“接受”
            // 只需准备隐藏消息通知AI即可
            systemContent = `[系统提示：你接受了“${originalMessage.senderName}”的转账。]`;
          }

          // 3. 创建这条对用户隐藏、但对AI可见的系统消息
          const hiddenMessage = {
            role: "system",
            content: systemContent,
            timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
            isHidden: true, // 这个标记会让它不在聊天界面显示
          };
          chat.history.push(hiddenMessage);

          // 4. 保存所有更改到数据库，并刷新界面
          await db.chats.put(chat);
          hideTransferActionModal();
          renderChatInterface(state.activeChatId);
          renderChatList();
        }

        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        // ▼▼▼ 【全新】通话记录功能核心函数 ▼▼▼

        async function renderCallHistoryScreen() {
          showScreen("call-history-screen"); // <--【核心修正】把它移动到最前面！

          const listEl = document.getElementById("call-history-list");
          const titleEl = document.getElementById("call-history-title");
          listEl.innerHTML = "";
          titleEl.textContent = "所有通话记录";

          const records = await db.callRecords
            .orderBy("timestamp")
            .reverse()
            .toArray();

          if (records.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有通话记录哦~</p>';
            return; // 现在的 return 就没问题了，因为它只跳过了后续的渲染逻辑
          }

          records.forEach((record) => {
            const card = createCallRecordCard(record);

            addLongPressListener(card, async () => {
              // 1. 弹出输入框，并将旧名称作为默认值，方便修改
              const newName = await showCustomPrompt(
                "自定义通话名称",
                "请输入新的名称（留空则恢复默认）",
                record.customName || "" // 如果已有自定义名称，就显示它
              );

              // 2. 如果用户点击了“取消”，则什么都不做
              if (newName === null) return;

              // 3. 更新数据库中的这条记录
              await db.callRecords.update(record.id, {
                customName: newName.trim(),
              });

              // 4. 刷新整个列表，让更改立刻显示出来
              await renderCallHistoryScreen();

              // 5. 给用户一个成功的提示
              await showCustomAlert("成功", "通话名称已更新！");
            });
            listEl.appendChild(card);
          });
        }

        // ▼▼▼ 用这个【升级版】函数，完整替换你旧的 createCallRecordCard 函数 ▼▼▼
        /**
         * 【升级版】根据单条记录数据，创建一张能显示聊天对象的通话卡片
         * @param {object} record - 一条通话记录对象
         * @returns {HTMLElement} - 创建好的卡片div
         */
        function createCallRecordCard(record) {
          const card = document.createElement("div");
          card.className = "call-record-card";
          card.dataset.recordId = record.id;

          // 获取通话对象的名字
          const chatInfo = state.chats[record.chatId];
          const chatName = chatInfo ? chatInfo.name : "未知会话";

          const callDate = new Date(record.timestamp);
          const dateString = `${callDate.getFullYear()}-${String(
            callDate.getMonth() + 1
          ).padStart(2, "0")}-${String(callDate.getDate()).padStart(
            2,
            "0"
          )} ${String(callDate.getHours()).padStart(2, "0")}:${String(
            callDate.getMinutes()
          ).padStart(2, "0")}`;
          const durationText = `${Math.floor(record.duration / 60)}分${
            record.duration % 60
          }秒`;

          const avatarsHtml = record.participants
            .map(
              (p) =>
                `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
            )
            .join("");

          card.innerHTML = `
        <div class="card-header">
            <span class="date">${dateString}</span>
            <span class="duration">${durationText}</span>
        </div>
        <div class="card-body">
            <!-- 【核心修改】在这里新增一个标题行 -->
            ${
              record.customName
                ? `<div class="custom-title">${record.customName}</div>`
                : ""
            }
            
            <div class="participants-info"> <!-- 新增一个容器方便布局 -->
                <div class="participants-avatars">${avatarsHtml}</div>
                <span class="participants-names">与 ${chatName}</span>
            </div>
        </div>
    `;
          return card;
        }
        // ▲▲▲ 替换结束 ▲▲▲

        /**
         * 显示指定通话记录的完整文字稿
         * @param {number} recordId - 通话记录的ID
         */
        async function showCallTranscript(recordId) {
          const record = await db.callRecords.get(recordId);
          if (!record) return;

          const modal = document.getElementById("call-transcript-modal");
          const titleEl = document.getElementById("transcript-modal-title");
          const bodyEl = document.getElementById("transcript-modal-body");

          titleEl.textContent = `通话于 ${new Date(
            record.timestamp
          ).toLocaleString()} (时长: ${Math.floor(record.duration / 60)}分${
            record.duration % 60
          }秒)`;
          bodyEl.innerHTML = "";

          if (!record.transcript || record.transcript.length === 0) {
            bodyEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a;">这次通话没有留下文字记录。</p>';
          } else {
            record.transcript.forEach((entry) => {
              const bubble = document.createElement("div");
              // 根据角色添加不同的class，应用不同的样式
              bubble.className = `transcript-entry ${entry.role}`;
              bubble.textContent = entry.content;
              bodyEl.appendChild(bubble);
            });
          }

          const deleteBtn = document.getElementById("delete-transcript-btn");

          // 【重要】使用克隆节点技巧，防止事件重复绑定
          const newDeleteBtn = deleteBtn.cloneNode(true);
          deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);

          // 为新的、干净的按钮绑定事件
          newDeleteBtn.addEventListener("click", async () => {
            const confirmed = await showCustomConfirm(
              "确认删除",
              "确定要永久删除这条通话记录吗？此操作不可恢复。",
              { confirmButtonClass: "btn-danger" }
            );

            if (confirmed) {
              // 1. 关闭当前的详情弹窗
              modal.classList.remove("visible");

              // 2. 从数据库删除
              await db.callRecords.delete(recordId);

              // 3. 刷新通话记录列表
              await renderCallHistoryScreen();

              // 4. (可选) 给出成功提示
              alert("通话记录已删除。");
            }
          });
          modal.classList.add("visible");
        }

        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        // ▼▼▼ 请用这个【全新函数】替换掉你旧的 handleStatusResetClick 函数 ▼▼▼

        /**
         * 【全新】处理用户点击状态栏，弹出编辑框让用户修改AI的当前状态
         */
        async function handleEditStatusClick() {
          // 1. 安全检查，确保在单聊界面
          if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
            return;
          }
          const chat = state.chats[state.activeChatId];

          // 2. 弹出输入框，让用户输入新的状态，并将当前状态作为默认值
          const newStatusText = await showCustomPrompt(
            "编辑对方状态",
            "请输入对方现在的新状态：",
            chat.status.text // 将当前状态作为输入框的默认内容
          );

          // 3. 如果用户输入了内容并点击了“确定”
          if (newStatusText !== null) {
            // 4. 更新内存和数据库中的状态数据
            chat.status.text = newStatusText.trim() || "在线"; // 如果用户清空了，就默认为“在线”
            chat.status.isBusy = false; // 每次手动编辑都默认其不处于“忙碌”状态
            chat.status.lastUpdate = Date.now();
            await db.chats.put(chat);

            // 5. 立刻刷新UI，让用户看到修改后的状态
            renderChatInterface(state.activeChatId);
            renderChatList();

            // 6. 给出一个无伤大雅的成功提示
            await showCustomAlert(
              "状态已更新",
              `“${chat.name}”的当前状态已更新为：${chat.status.text}`
            );
          }
        }

        // 放在你的JS功能函数定义区
        async function openShareTargetPicker() {
          const modal = document.getElementById("share-target-modal");
          const listEl = document.getElementById("share-target-list");
          listEl.innerHTML = "";

          // 获取所有聊天作为分享目标
          const chats = Object.values(state.chats);

          chats.forEach((chat) => {
            // 复用联系人选择器的样式
            const item = document.createElement("div");
            item.className = "contact-picker-item";
            item.innerHTML = `
            <input type="checkbox" class="share-target-checkbox" data-chat-id="${
              chat.id
            }" style="margin-right: 15px;">
            <img src="${
              chat.isGroup
                ? chat.settings.groupAvatar
                : chat.settings.aiAvatar || defaultAvatar
            }" class="avatar">
            <span class="name">${chat.name}</span>
        `;
            listEl.appendChild(item);
          });

          modal.classList.add("visible");
        }

        function closeMusicPlayerWithAnimation(callback) {
          const overlay = document.getElementById("music-player-overlay");
          if (!overlay.classList.contains("visible")) {
            if (callback) callback();
            return;
          }
          overlay.classList.remove("visible");
          setTimeout(() => {
            document
              .getElementById("music-playlist-panel")
              .classList.remove("visible");
            if (callback) callback();
          }, 400);
        }

        function parseLRC(lrcContent) {
          if (!lrcContent) return [];
          const lines = lrcContent.split("\n");
          const lyrics = [];
          const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;

          for (const line of lines) {
            const text = line.replace(timeRegex, "").trim();
            if (!text) continue;
            timeRegex.lastIndex = 0;
            let match;
            while ((match = timeRegex.exec(line)) !== null) {
              const minutes = parseInt(match[1], 10);
              const seconds = parseInt(match[2], 10);
              const milliseconds = parseInt(match[3].padEnd(3, "0"), 10);
              const time = minutes * 60 + seconds + milliseconds / 1000;
              lyrics.push({ time, text });
            }
          }
          return lyrics.sort((a, b) => a.time - b.time);
        }

        function renderLyrics() {
          const lyricsList = document.getElementById("music-lyrics-list");
          lyricsList.innerHTML = "";
          if (
            !musicState.parsedLyrics ||
            musicState.parsedLyrics.length === 0
          ) {
            lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
            return;
          }
          musicState.parsedLyrics.forEach((line, index) => {
            const lineEl = document.createElement("div");
            lineEl.className = "lyric-line";
            lineEl.textContent = line.text;
            lineEl.dataset.index = index;
            lyricsList.appendChild(lineEl);
          });
          lyricsList.style.transform = `translateY(0px)`;
        }

        function updateActiveLyric(currentTime) {
          if (musicState.parsedLyrics.length === 0) return;
          let newLyricIndex = -1;
          for (let i = 0; i < musicState.parsedLyrics.length; i++) {
            if (currentTime >= musicState.parsedLyrics[i].time) {
              newLyricIndex = i;
            } else {
              break;
            }
          }
          if (newLyricIndex === musicState.currentLyricIndex) return;
          musicState.currentLyricIndex = newLyricIndex;
          updateLyricsUI();
        }

        function updateLyricsUI() {
          const lyricsList = document.getElementById("music-lyrics-list");
          const container = document.getElementById("music-lyrics-container");
          const lines = lyricsList.querySelectorAll(".lyric-line");
          lines.forEach((line) => line.classList.remove("active"));
          if (musicState.currentLyricIndex === -1) {
            lyricsList.style.transform = `translateY(0px)`;
            return;
          }
          const activeLine = lyricsList.querySelector(
            `.lyric-line[data-index="${musicState.currentLyricIndex}"]`
          );
          if (activeLine) {
            activeLine.classList.add("active");
            const containerHeight = container.offsetHeight;
            const offset =
              containerHeight / 3 -
              activeLine.offsetTop -
              activeLine.offsetHeight / 2;
            lyricsList.style.transform = `translateY(${offset}px)`;
          }
        }

        function formatMusicTime(seconds) {
          if (isNaN(seconds) || seconds < 0) return "0:00";
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = Math.floor(seconds % 60);
          return `${minutes}:${String(remainingSeconds).padStart(2, "0")}`;
        }

        function updateMusicProgressBar() {
          const currentTimeEl = document.getElementById("music-current-time");
          const totalTimeEl = document.getElementById("music-total-time");
          const progressFillEl = document.getElementById("music-progress-fill");
          if (!audioPlayer.duration) {
            currentTimeEl.textContent = "0:00";
            totalTimeEl.textContent = "0:00";
            progressFillEl.style.width = "0%";
            return;
          }
          const progressPercent =
            (audioPlayer.currentTime / audioPlayer.duration) * 100;
          progressFillEl.style.width = `${progressPercent}%`;
          currentTimeEl.textContent = formatMusicTime(audioPlayer.currentTime);
          totalTimeEl.textContent = formatMusicTime(audioPlayer.duration);
          updateActiveLyric(audioPlayer.currentTime);
        }

        /**
         * 【全新】处理用户点击“撤回”按钮的入口函数
         */
        async function handleRecallClick() {
          if (!activeMessageTimestamp) return;

          const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 设置2分钟的撤回时限
          const messageTime = activeMessageTimestamp;
          const now = Date.now();

          // 检查是否超过了撤回时限
          if (now - messageTime > RECALL_TIME_LIMIT_MS) {
            hideMessageActions();
            await showCustomAlert(
              "操作失败",
              "该消息发送已超过2分钟，无法撤回。"
            );
            return;
          }

          // 如果在时限内，执行真正的撤回逻辑
          await recallMessage(messageTime, true);
          hideMessageActions();
        }

        /**
         * 【全新】消息撤回的核心逻辑
         * @param {number} timestamp - 要撤回的消息的时间戳
         * @param {boolean} isUserRecall - 是否是用户主动撤回
         */
        async function recallMessage(timestamp, isUserRecall) {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === timestamp
          );
          if (messageIndex === -1) return;

          const messageToRecall = chat.history[messageIndex];

          // 1. 修改消息对象，将其变为“已撤回”状态
          const recalledData = {
            originalType: messageToRecall.type || "text",
            originalContent: messageToRecall.content,
            // 保存其他可能存在的原始数据
            originalMeaning: messageToRecall.meaning,
            originalQuote: messageToRecall.quote,
          };

          messageToRecall.type = "recalled_message";
          messageToRecall.content = isUserRecall
            ? "你撤回了一条消息"
            : "对方撤回了一条消息";
          messageToRecall.recalledData = recalledData;
          // 清理掉不再需要的旧属性
          delete messageToRecall.meaning;
          delete messageToRecall.quote;

          // 2. 如果是用户撤回，需要给AI发送一条它看不懂内容的隐藏提示
          if (isUserRecall) {
            const hiddenMessageForAI = {
              role: "system",
              content: `[系统提示：用户撤回了一条消息。你不知道内容是什么，只需知道这个事件即可。]`,
              timestamp: Date.now(),
              isHidden: true,
            };
            chat.history.push(hiddenMessageForAI);
          }

          // 3. 保存到数据库并刷新UI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);
          if (isUserRecall) renderChatList(); // 用户撤回时，最后一条消息变了，需要刷新列表
        }

        // ▼▼▼ 【全新】将这些函数粘贴到你的JS功能函数定义区 ▼▼▼

        /**
         * 打开分类管理模态框
         */
        async function openCategoryManager() {
          await renderCategoryListInManager();
          document
            .getElementById("world-book-category-manager-modal")
            .classList.add("visible");
        }

        /**
         * 在模态框中渲染已存在的分类列表
         */
        async function renderCategoryListInManager() {
          const listEl = document.getElementById("existing-categories-list");
          const categories = await db.worldBookCategories.toArray();
          listEl.innerHTML = "";
          if (categories.length === 0) {
            listEl.innerHTML =
              '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
          }
          categories.forEach((cat) => {
            // 复用好友分组的样式
            const item = document.createElement("div");
            item.className = "existing-group-item";
            item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
            listEl.appendChild(item);
          });
        }

        /**
         * 添加一个新的世界书分类
         */
        async function addNewCategory() {
          const input = document.getElementById("new-category-name-input");
          const name = input.value.trim();
          if (!name) {
            alert("分类名不能为空！");
            return;
          }
          const existing = await db.worldBookCategories
            .where("name")
            .equals(name)
            .first();
          if (existing) {
            alert(`分类 "${name}" 已经存在了！`);
            return;
          }
          await db.worldBookCategories.add({ name });
          input.value = "";
          await renderCategoryListInManager();
        }

        /**
         * 删除一个世界书分类
         * @param {number} categoryId - 要删除的分类的ID
         */
        async function deleteCategory(categoryId) {
          const confirmed = await showCustomConfirm(
            "确认删除",
            "删除分类后，该分类下的所有世界书将变为“未分类”。确定要删除吗？",
            { confirmButtonClass: "btn-danger" }
          );
          if (confirmed) {
            await db.worldBookCategories.delete(categoryId);
            // 将属于该分类的世界书的 categoryId 设为 null
            const booksToUpdate = await db.worldBooks
              .where("categoryId")
              .equals(categoryId)
              .toArray();
            for (const book of booksToUpdate) {
              book.categoryId = null;
              await db.worldBooks.put(book);
              const bookInState = state.worldBooks.find(
                (wb) => wb.id === book.id
              );
              if (bookInState) bookInState.categoryId = null;
            }
            await renderCategoryListInManager();
          }
        }

        // ▲▲▲ 新函数粘贴结束 ▲▲▲

        // ===================================================================
        // 4. 初始化函数 init()
        // ===================================================================
        async function init() {
          // ▼▼▼ 在 init() 函数的【最开头】，粘贴下面这两行代码 ▼▼▼
          const savedTheme = localStorage.getItem("ephone-theme") || "light"; // 默认为日间模式
          applyTheme(savedTheme);
          // ▲▲▲ 粘贴结束 ▲▲▲

          // ▼▼▼ 新增代码 ▼▼▼
          const customBubbleStyleTag = document.createElement("style");
          customBubbleStyleTag.id = "custom-bubble-style";
          document.head.appendChild(customBubbleStyleTag);
          // ▲▲▲ 新增结束 ▲▲▲

          // ▼▼▼ 新增代码 ▼▼▼
          const previewBubbleStyleTag = document.createElement("style");
          previewBubbleStyleTag.id = "preview-bubble-style";
          document.head.appendChild(previewBubbleStyleTag);
          // ▲▲▲ 新增结束 ▲▲▲

          // ▼▼▼ 修改这两行 ▼▼▼
          applyScopedCss("", "#chat-messages", "custom-bubble-style"); // 清除真实聊天界面的自定义样式
          applyScopedCss("", "#settings-preview-area", "preview-bubble-style"); // 清除预览区的自定义样式
          // ▲▲▲ 修改结束 ▲▲▲

          window.showScreen = showScreen;
          window.renderChatListProxy = renderChatList;
          window.renderApiSettingsProxy = renderApiSettings;
          window.renderWallpaperScreenProxy = renderWallpaperScreen;
          window.renderWorldBookScreenProxy = renderWorldBookScreen;

          await loadAllDataFromDB();

          // 初始化未读动态计数
          const storedCount =
            parseInt(localStorage.getItem("unreadPostsCount")) || 0;
          updateUnreadIndicator(storedCount);

          // ▲▲▲ 代码添加结束 ▲▲▲

          if (state.globalSettings && state.globalSettings.fontUrl) {
            applyCustomFont(state.globalSettings.fontUrl);
          }

          updateClock();
          setInterval(updateClock, 1000 * 30);
          applyGlobalWallpaper();
          initBatteryManager();

          applyAppIcons();

          // ==========================================================
          // --- 各种事件监听器 ---
          // ==========================================================

          document
            .getElementById("custom-modal-cancel")
            .addEventListener("click", hideCustomModal);
          document
            .getElementById("custom-modal-overlay")
            .addEventListener("click", (e) => {
              if (e.target === modalOverlay) hideCustomModal();
            });
          document
            .getElementById("export-data-btn")
            .addEventListener("click", exportBackup);
          document
            .getElementById("import-btn")
            .addEventListener("click", () =>
              document.getElementById("import-data-input").click()
            );
          document
            .getElementById("import-data-input")
            .addEventListener("change", (e) => importBackup(e.target.files[0]));
          document
            .getElementById("back-to-list-btn")
            .addEventListener("click", () => {
              // ▼▼▼ 修改这两行 ▼▼▼
              applyScopedCss("", "#chat-messages", "custom-bubble-style"); // 清除真实聊天界面的自定义样式
              applyScopedCss(
                "",
                "#settings-preview-area",
                "preview-bubble-style"
              ); // 清除预览区的自定义样式
              // ▲▲▲ 修改结束 ▲▲▲

              exitSelectionMode();
              state.activeChatId = null;
              showScreen("chat-list-screen");
            });

          document
            .getElementById("add-chat-btn")
            .addEventListener("click", async () => {
              const name = await showCustomPrompt(
                "创建新聊天",
                "请输入Ta的名字"
              );
              if (name && name.trim()) {
                const newChatId = "chat_" + Date.now();
                const newChat = {
                  id: newChatId,
                  name: name.trim(),
                  isGroup: false,
                  relationship: {
                    status: "friend", // 'friend', 'blocked_by_user', 'pending_user_approval'
                    blockedTimestamp: null,
                    applicationReason: "",
                  },
                  status: {
                    text: "在线",
                    lastUpdate: Date.now(),
                    isBusy: false,
                  },
                  settings: {
                    aiPersona: "你是谁呀。",
                    myPersona: "我是谁呀。",
                    maxMemory: 10,
                    aiAvatar: defaultAvatar,
                    myAvatar: defaultAvatar,
                    background: "",
                    theme: "default",
                    fontSize: 13,
                    customCss: "", // <--- 新增这行
                    linkedWorldBookIds: [],
                    aiAvatarLibrary: [],
                  },
                  history: [],
                  musicData: { totalTime: 0 },
                };
                state.chats[newChatId] = newChat;
                await db.chats.put(newChat);
                renderChatList();
              }
            });

          // ▼▼▼ 【修正】创建群聊按钮现在打开联系人选择器 ▼▼▼
          document
            .getElementById("add-group-chat-btn")
            .addEventListener("click", openContactPickerForGroupCreate);
          // ▲▲▲ 替换结束 ▲▲▲
          document
            .getElementById("transfer-cancel-btn")
            .addEventListener("click", () =>
              document
                .getElementById("transfer-modal")
                .classList.remove("visible")
            );
          document
            .getElementById("transfer-confirm-btn")
            .addEventListener("click", sendUserTransfer);

          document
            .getElementById("listen-together-btn")
            .addEventListener("click", handleListenTogetherClick);
          document
            .getElementById("music-exit-btn")
            .addEventListener("click", () => endListenTogetherSession(true));
          document
            .getElementById("music-return-btn")
            .addEventListener("click", returnToChat);
          document
            .getElementById("music-play-pause-btn")
            .addEventListener("click", togglePlayPause);
          document
            .getElementById("music-next-btn")
            .addEventListener("click", playNext);
          document
            .getElementById("music-prev-btn")
            .addEventListener("click", playPrev);
          document
            .getElementById("music-mode-btn")
            .addEventListener("click", changePlayMode);
          document
            .getElementById("music-playlist-btn")
            .addEventListener("click", () => {
              updatePlaylistUI();
              document
                .getElementById("music-playlist-panel")
                .classList.add("visible");
            });
          document
            .getElementById("close-playlist-btn")
            .addEventListener("click", () =>
              document
                .getElementById("music-playlist-panel")
                .classList.remove("visible")
            );
          document
            .getElementById("add-song-url-btn")
            .addEventListener("click", addSongFromURL);
          document
            .getElementById("add-song-local-btn")
            .addEventListener("click", () =>
              document.getElementById("local-song-upload-input").click()
            );
          document
            .getElementById("local-song-upload-input")
            .addEventListener("change", addSongFromLocal);
          audioPlayer.addEventListener("ended", playNext);
          audioPlayer.addEventListener("pause", () => {
            if (musicState.isActive) {
              musicState.isPlaying = false;
              updatePlayerUI();
            }
          });
          audioPlayer.addEventListener("play", () => {
            if (musicState.isActive) {
              musicState.isPlaying = true;
              updatePlayerUI();
            }
          });

          const chatInput = document.getElementById("chat-input");
          // ▼▼▼ 找到 id="send-btn" 的 click 事件监听器 ▼▼▼
          document
            .getElementById("send-btn")
            .addEventListener("click", async () => {
              const content = chatInput.value.trim();
              if (!content || !state.activeChatId) return;

              const chat = state.chats[state.activeChatId];

              // --- 【核心修改】在这里添加 ---
              const msg = {
                role: "user",
                content,
                timestamp: Date.now(),
              };

              // 检查当前是否处于引用回复模式
              if (currentReplyContext) {
                msg.quote = currentReplyContext; // 将引用信息附加到消息对象上
              }
              // --- 【修改结束】 ---

              chat.history.push(msg);
              await db.chats.put(chat);
              appendMessage(msg, chat);
              renderChatList();
              chatInput.value = "";
              chatInput.style.height = "auto";
              chatInput.focus();

              // --- 【核心修改】发送后，取消引用模式 ---
              cancelReplyMode();

              // 触发AI回复
              triggerAiResponse();
            });
          document
            .getElementById("wait-reply-btn")
            .addEventListener("click", triggerAiResponse);
          chatInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              document.getElementById("send-btn").click();
            }
          });
          chatInput.addEventListener("input", () => {
            chatInput.style.height = "auto";
            chatInput.style.height = chatInput.scrollHeight + "px";
          });

          // ▼▼▼ 新增：手机边框颜色设置相关事件 ▼▼▼
          const frameColorInput = document.getElementById("frame-color-input");
          const frameColorValue = document.getElementById("frame-color-value");
          
          frameColorInput.addEventListener("input", (e) => {
            frameColorValue.textContent = e.target.value;
            // 实时预览：直接修改DOM，但不保存
            document.getElementById("phone-frame").style.backgroundColor = e.target.value;
          });

          document.getElementById("reset-frame-color-btn").addEventListener("click", () => {
            // 重置为默认值（这里假设默认白色，实际保存时为空字符串让CSS生效）
            frameColorInput.value = "#ffffff";
            frameColorValue.textContent = "#ffffff";
            document.getElementById("phone-frame").style.backgroundColor = ""; // 清除内联样式
          });
          // ▲▲▲ 新增结束 ▲▲▲

          document
            .getElementById("wallpaper-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res, rej) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.onerror = () => rej(reader.error);
                  reader.readAsDataURL(file);
                });
                newWallpaperBase64 = dataUrl;
                renderWallpaperScreen();
              }
            });
          // ▼▼▼ 用这整块代码，替换旧的 save-wallpaper-btn 事件监听器 ▼▼▼
          document
            .getElementById("save-wallpaper-btn")
            .addEventListener("click", async () => {
              let changesMade = false;

              // 保存壁纸
              if (newWallpaperBase64) {
                state.globalSettings.wallpaper = newWallpaperBase64;
                changesMade = true;
              }

              // ▼▼▼ 新增：保存手机边框颜色 ▼▼▼
              const currentFrameColor = frameColorInput.value;
              // 如果是默认的白色（且不在夜间模式下），或者用户点了重置（我们需要一个标记），
              // 这里简化处理：如果用户选择了颜色，就保存。
              // 为了支持“重置”功能，我们检查 reset 按钮是否刚刚被点击过比较麻烦。
              // 更简单的逻辑：直接保存 input 的值。
              // 但是 reset 按钮清除了 style，input 还是显示 #ffffff。
              // 修正逻辑：如果当前 style.backgroundColor 为空（被重置了），则保存 null。
              // 否则保存 input 的值。
              if (document.getElementById("phone-frame").style.backgroundColor === "") {
                 state.globalSettings.phoneFrameColor = null;
              } else {
                 state.globalSettings.phoneFrameColor = currentFrameColor;
              }
              // ▲▲▲ 新增结束 ▲▲▲

              // 【核心修改】保存图标设置（它已经在内存中了，我们只需要把整个globalSettings存起来）
              await db.globalSettings.put(state.globalSettings);

              // 应用所有更改
              if (changesMade) {
                applyGlobalWallpaper();
                newWallpaperBase64 = null;
              }
              applyGlobalWallpaper(); // 确保边框颜色被应用（因为 applyGlobalWallpaper 包含了边框逻辑）
              applyAppIcons(); // 重新应用所有图标

              alert("外观设置已保存并应用！");
              showScreen("home-screen");
            });
          // ▲▲▲ 替换结束 ▲▲▲

          // API Config Event Listeners
          document.getElementById("add-new-config-btn").addEventListener("click", () => openApiConfigEditor());
          document.getElementById("save-config-btn").addEventListener("click", saveApiConfig);
          document.getElementById("cancel-config-editor-btn").addEventListener("click", () => {
            document.getElementById("api-config-editor-modal").classList.remove("visible");
          });

          document.getElementById("api-configs-list").addEventListener("click", async (e) => {
            const target = e.target;
            const item = target.closest(".api-config-item");
            if (!item) return;
            const configId = parseInt(item.dataset.configId);

            if (target.classList.contains("edit-btn")) {
              openApiConfigEditor(configId);
            } else if (target.classList.contains("delete-btn")) {
              const confirmed = await showCustomConfirm("删除配置", "确定要删除这个API配置吗？", { confirmButtonClass: "btn-danger" });
              if (confirmed) {
                await db.apiConfigs.delete(configId);
                state.apiConfigs = state.apiConfigs.filter(c => c.id !== configId);
                if (state.globalSettings.activeApiConfigId === configId) {
                  state.globalSettings.activeApiConfigId = state.apiConfigs[0]?.id || null;
                  await db.globalSettings.put(state.globalSettings);
                }
                renderApiSettings();
              }
            } else if (target.type === "radio") {
              setActiveApiConfig(configId);
            }
          });

          document.getElementById("config-fetch-models-btn").addEventListener("click", async () => {
            const url = document.getElementById("config-url-input").value.trim();
            const key = document.getElementById("config-key-input").value.trim();
            if (!url || !key) return alert("请先填写反代地址和密钥");
            try {
              let isGemini = url === GEMINI_API_URL;
              const response = await fetch(
                isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`,
                isGemini ? undefined : { headers: { Authorization: `Bearer ${key}` } }
              );
              if (!response.ok) throw new Error("无法获取模型列表");
              const data = await response.json();
              let models = isGemini ? data.models : data.data;
              if (isGemini) {
                models = models.map((model) => {
                  const parts = model.name.split("/");
                  return { id: parts.length > 1 ? parts[1] : model.name };
                });
              }
              const modelSelect = document.getElementById("config-model-select");
              modelSelect.innerHTML = "";
              models.forEach((model) => {
                const option = document.createElement("option");
                option.value = model.id;
                option.textContent = model.id;
                modelSelect.appendChild(option);
              });
              alert("模型列表已更新！");
            } catch (e) {
              console.error(e);
              alert("获取模型失败: " + e.message);
            }
          });

          // Global Settings Auto-save
          document.getElementById("background-activity-switch").addEventListener("change", async (e) => {
            state.globalSettings.enableBackgroundActivity = e.target.checked;
            await db.globalSettings.put(state.globalSettings);
          });
          document.getElementById("background-interval-input").addEventListener("change", async (e) => {
            state.globalSettings.backgroundActivityInterval = parseInt(e.target.value);
            await db.globalSettings.put(state.globalSettings);
          });
          document.getElementById("block-cooldown-input").addEventListener("change", async (e) => {
            state.globalSettings.blockCooldownHours = parseFloat(e.target.value);
            await db.globalSettings.put(state.globalSettings);
          });
          document
            .getElementById("add-world-book-btn")
            .addEventListener("click", async () => {
              const name = await showCustomPrompt("创建世界书", "请输入书名");
              if (name && name.trim()) {
                const newBook = {
                  id: "wb_" + Date.now(),
                  name: name.trim(),
                  content: "",
                };
                await db.worldBooks.add(newBook);
                state.worldBooks.push(newBook);
                renderWorldBookScreen();
                openWorldBookEditor(newBook.id);
              }
            });
          document
            .getElementById("save-world-book-btn")
            .addEventListener("click", async () => {
              if (!editingWorldBookId) return;
              const book = state.worldBooks.find(
                (wb) => wb.id === editingWorldBookId
              );
              if (book) {
                const newName = document
                  .getElementById("world-book-name-input")
                  .value.trim();
                if (!newName) {
                  alert("书名不能为空！");
                  return;
                }
                book.name = newName;
                book.content = document.getElementById(
                  "world-book-content-input"
                ).value;

                // ▼▼▼ 【核心修改】在这里保存分类ID ▼▼▼
                const categoryId = document.getElementById(
                  "world-book-category-select"
                ).value;
                // 如果选择了“未分类”，存入 null；否则存入数字ID
                book.categoryId = categoryId ? parseInt(categoryId) : null;
                // ▲▲▲ 修改结束 ▲▲▲

                await db.worldBooks.put(book);
                document.getElementById("world-book-editor-title").textContent =
                  newName;
                editingWorldBookId = null;
                renderWorldBookScreen();
                showScreen("world-book-screen");
              }
            });
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              const aiImage = e.target.closest(".ai-generated-image");
              if (aiImage) {
                const description = aiImage.dataset.description;
                if (description) showCustomAlert("照片描述", description);
                return;
              }
            });

          const chatSettingsModal = document.getElementById(
            "chat-settings-modal"
          );
          const worldBookSelectBox = document.querySelector(
            ".custom-multiselect .select-box"
          );
          const worldBookCheckboxesContainer = document.getElementById(
            "world-book-checkboxes-container"
          );

          function updateWorldBookSelectionDisplay() {
            const checkedBoxes =
              worldBookCheckboxesContainer.querySelectorAll("input:checked");
            const displayText = document.querySelector(
              ".selected-options-text"
            );
            if (checkedBoxes.length === 0) {
              displayText.textContent = "-- 点击选择 --";
            } else if (checkedBoxes.length > 2) {
              displayText.textContent = `已选择 ${checkedBoxes.length} 项`;
            } else {
              displayText.textContent = Array.from(checkedBoxes)
                .map((cb) => cb.parentElement.textContent.trim())
                .join(", ");
            }
          }

          worldBookSelectBox.addEventListener("click", (e) => {
            e.stopPropagation();
            worldBookCheckboxesContainer.classList.toggle("visible");
            worldBookSelectBox.classList.toggle("expanded");
          });
          document
            .getElementById("world-book-checkboxes-container")
            .addEventListener("change", updateWorldBookSelectionDisplay);
          window.addEventListener("click", (e) => {
            if (
              !document.querySelector(".custom-multiselect").contains(e.target)
            ) {
              worldBookCheckboxesContainer.classList.remove("visible");
              worldBookSelectBox.classList.remove("expanded");
            }
          });

          // ▼▼▼ 请用这段【完整、全新的代码】替换旧的 chat-settings-btn 点击事件 ▼▼▼
          document
            .getElementById("chat-settings-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];
              const isGroup = chat.isGroup;

              // --- 统一显示/隐藏控件 ---
              document.getElementById("chat-name-group").style.display =
                "block";
              document.getElementById("my-persona-group").style.display =
                "block";
              document.getElementById("my-avatar-group").style.display =
                "block";
              document.getElementById("my-group-nickname-group").style.display =
                isGroup ? "block" : "none";
              document.getElementById("group-avatar-group").style.display =
                isGroup ? "block" : "none";
              document.getElementById("group-members-group").style.display =
                isGroup ? "block" : "none";
              document.getElementById("ai-persona-group").style.display =
                isGroup ? "none" : "block";
              document.getElementById("ai-avatar-group").style.display = isGroup
                ? "none"
                : "block";

              // 【核心修改1】根据是否为群聊，显示或隐藏“好友分组”区域
              document.getElementById("assign-group-section").style.display =
                isGroup ? "none" : "block";

              // --- 加载表单数据 ---
              document.getElementById("chat-name-input").value = chat.name;
              document.getElementById("my-persona").value =
                chat.settings.myPersona;
              document.getElementById("my-avatar-preview").src =
                chat.settings.myAvatar ||
                (isGroup ? defaultMyGroupAvatar : defaultAvatar);
              document.getElementById("max-memory").value =
                chat.settings.maxMemory;
              const bgPreview = document.getElementById("bg-preview");
              const removeBgBtn = document.getElementById("remove-bg-btn");
              if (chat.settings.background) {
                bgPreview.src = chat.settings.background;
                bgPreview.style.display = "block";
                removeBgBtn.style.display = "inline-block";
              } else {
                bgPreview.style.display = "none";
                removeBgBtn.style.display = "none";
              }

              if (isGroup) {
                document.getElementById("my-group-nickname-input").value =
                  chat.settings.myNickname || "";
                document.getElementById("group-avatar-preview").src =
                  chat.settings.groupAvatar || defaultGroupAvatar;
                renderGroupMemberSettings(chat.members);
              } else {
                document.getElementById("ai-persona").value =
                  chat.settings.aiPersona;
                document.getElementById("ai-avatar-preview").src =
                  chat.settings.aiAvatar || defaultAvatar;

                // 【核心修改2】如果是单聊，就加载分组列表到下拉框
                const select = document.getElementById("assign-group-select");
                select.innerHTML = '<option value="">未分组</option>'; // 清空并设置默认选项
                const groups = await db.qzoneGroups.toArray();
                groups.forEach((group) => {
                  const option = document.createElement("option");
                  option.value = group.id;
                  option.textContent = group.name;
                  // 如果当前好友已经有分组，就默认选中它
                  if (chat.groupId === group.id) {
                    option.selected = true;
                  }
                  select.appendChild(option);
                });
              }

              // 加载世界书
              // ▼▼▼ 用下面这段【全新逻辑】替换掉原来简单的 forEach 循环 ▼▼▼

              const worldBookCheckboxesContainer = document.getElementById(
                "world-book-checkboxes-container"
              );
              worldBookCheckboxesContainer.innerHTML = "";
              const linkedIds = new Set(chat.settings.linkedWorldBookIds || []);

              // 1. 获取所有分类和世界书
              const categories = await db.worldBookCategories.toArray();
              const books = state.worldBooks;

              // 【核心改造】如果存在未分类的书籍，就创建一个“虚拟分类”
              const hasUncategorized = books.some((book) => !book.categoryId);
              if (hasUncategorized) {
                categories.push({ id: "uncategorized", name: "未分类" });
              }

              // 2. 将书籍按分类ID进行分组
              const booksByCategoryId = books.reduce((acc, book) => {
                const categoryId = book.categoryId || "uncategorized";
                if (!acc[categoryId]) {
                  acc[categoryId] = [];
                }
                acc[categoryId].push(book);
                return acc;
              }, {});

              // 3. 遍历分类，创建带折叠功能的列表
              categories.forEach((category) => {
                const booksInCategory = booksByCategoryId[category.id] || [];
                if (booksInCategory.length > 0) {
                  const allInCategoryChecked = booksInCategory.every((book) =>
                    linkedIds.has(book.id)
                  );

                  const header = document.createElement("div");
                  header.className = "wb-category-header";
                  header.innerHTML = `
            <span class="arrow">▼</span>
            <input type="checkbox" class="wb-category-checkbox" data-category-id="${
              category.id
            }" ${allInCategoryChecked ? "checked" : ""}>
            <span>${category.name}</span>
        `;

                  const bookContainer = document.createElement("div");
                  bookContainer.className = "wb-book-container";
                  bookContainer.dataset.containerFor = category.id;

                  booksInCategory.forEach((book) => {
                    const isChecked = linkedIds.has(book.id);
                    const label = document.createElement("label");
                    label.innerHTML = `<input type="checkbox" class="wb-book-checkbox" value="${
                      book.id
                    }" data-parent-category="${category.id}" ${
                      isChecked ? "checked" : ""
                    }> ${book.name}`;
                    bookContainer.appendChild(label);
                  });

                  // --- ★ 核心修改 #1 在这里 ★ ---
                  // 默认将分类设置为折叠状态
                  header.classList.add("collapsed");
                  bookContainer.classList.add("collapsed");
                  // --- ★ 修改结束 ★ ---

                  worldBookCheckboxesContainer.appendChild(header);
                  worldBookCheckboxesContainer.appendChild(bookContainer);
                }
              });

              updateWorldBookSelectionDisplay(); // 更新顶部的已选数量显示

              // ▲▲▲ 替换结束 ▲▲▲

              // ▼▼▼ 在 updateWorldBookSelectionDisplay(); 的下一行，粘贴这整块新代码 ▼▼▼

              // 使用事件委托来处理所有点击和勾选事件，效率更高
              worldBookCheckboxesContainer.addEventListener("click", (e) => {
                const header = e.target.closest(".wb-category-header");
                if (header && !e.target.matches('input[type="checkbox"]')) {
                  const categoryId = header.querySelector(
                    ".wb-category-checkbox"
                  )?.dataset.categoryId;
                  // 【修改】现在 categoryId 可能是数字，也可能是 "uncategorized" 字符串，所以这个判断能通过了！
                  if (categoryId) {
                    // <-- 把原来的 !categoryId return; 改成这样
                    const bookContainer =
                      worldBookCheckboxesContainer.querySelector(
                        `.wb-book-container[data-container-for="${categoryId}"]`
                      );
                    if (bookContainer) {
                      header.classList.toggle("collapsed");
                      bookContainer.classList.toggle("collapsed");
                    }
                  }
                }
              });

              worldBookCheckboxesContainer.addEventListener("change", (e) => {
                const target = e.target;

                // 如果点击的是分类的“全选”复选框
                if (target.classList.contains("wb-category-checkbox")) {
                  const categoryId = target.dataset.categoryId;
                  const isChecked = target.checked;
                  // 找到这个分类下的所有书籍复选框，并将它们的状态设置为与分类复选框一致
                  const bookCheckboxes =
                    worldBookCheckboxesContainer.querySelectorAll(
                      `input.wb-book-checkbox[data-parent-category="${categoryId}"]`
                    );
                  bookCheckboxes.forEach((cb) => (cb.checked = isChecked));
                }

                // 如果点击的是单个书籍的复选框
                if (target.classList.contains("wb-book-checkbox")) {
                  const categoryId = target.dataset.parentCategory;
                  if (categoryId) {
                    // 检查它是否属于一个分类
                    const categoryCheckbox =
                      worldBookCheckboxesContainer.querySelector(
                        `input.wb-category-checkbox[data-category-id="${categoryId}"]`
                      );
                    const allBookCheckboxes =
                      worldBookCheckboxesContainer.querySelectorAll(
                        `input.wb-book-checkbox[data-parent-category="${categoryId}"]`
                      );
                    // 检查该分类下是否所有书籍都被选中了
                    const allChecked = Array.from(allBookCheckboxes).every(
                      (cb) => cb.checked
                    );
                    // 同步分类“全选”复选框的状态
                    categoryCheckbox.checked = allChecked;
                  }
                }

                // 每次变更后都更新顶部的已选数量显示
                updateWorldBookSelectionDisplay();
              });

              // ▲▲▲ 粘贴结束 ▲▲▲

              // 加载并更新所有预览相关控件
              const themeRadio = document.querySelector(
                `input[name="theme-select"][value="${
                  chat.settings.theme || "default"
                }"]`
              );
              if (themeRadio) themeRadio.checked = true;
              const fontSizeSlider =
                document.getElementById("font-size-slider");
              fontSizeSlider.value = chat.settings.fontSize || 13;
              document.getElementById(
                "font-size-value"
              ).textContent = `${fontSizeSlider.value}px`;
              const customCssInput =
                document.getElementById("custom-css-input");
              customCssInput.value = chat.settings.customCss || "";

              updateSettingsPreview();
              document
                .getElementById("chat-settings-modal")
                .classList.add("visible");
            });
          // ▲▲▲ 替换结束 ▲▲▲

          function renderGroupMemberSettings(members) {
            const container = document.getElementById("group-members-settings");
            container.innerHTML = "";
            members.forEach((member) => {
              const div = document.createElement("div");
              div.className = "member-editor";
              div.dataset.memberId = member.id;
              // ★★★【核心重构】★★★
              // 显示的是 groupNickname
              div.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`;
              div.addEventListener("click", () => openMemberEditor(member.id));
              container.appendChild(div);
            });
          }

          function openMemberEditor(memberId) {
            editingMemberId = memberId;
            const chat = state.chats[state.activeChatId];
            const member = chat.members.find((m) => m.id === memberId);
            document.getElementById("member-name-input").value =
              member.groupNickname;
            document.getElementById("member-persona-input").value =
              member.persona;
            document.getElementById("member-avatar-preview").src =
              member.avatar;
            document
              .getElementById("member-settings-modal")
              .classList.add("visible");
          }
          document
            .getElementById("cancel-member-settings-btn")
            .addEventListener("click", () => {
              document
                .getElementById("member-settings-modal")
                .classList.remove("visible");
              editingMemberId = null;
            });
          document
            .getElementById("save-member-settings-btn")
            .addEventListener("click", () => {
              if (!editingMemberId) return;
              const chat = state.chats[state.activeChatId];
              const member = chat.members.find((m) => m.id === editingMemberId);

              // ★★★【核心重构】★★★
              const newNickname = document
                .getElementById("member-name-input")
                .value.trim();
              if (!newNickname) {
                alert("群昵称不能为空！");
                return;
              }
              member.groupNickname = newNickname; // 只修改群昵称
              member.persona = document.getElementById(
                "member-persona-input"
              ).value;
              member.avatar = document.getElementById(
                "member-avatar-preview"
              ).src;

              renderGroupMemberSettings(chat.members);
              document
                .getElementById("member-settings-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("reset-theme-btn")
            .addEventListener("click", () => {
              document.getElementById("theme-default").checked = true;
            });
          document
            .getElementById("cancel-chat-settings-btn")
            .addEventListener("click", () => {
              chatSettingsModal.classList.remove("visible");
            });

          document
            .getElementById("save-chat-settings-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];
              const newName = document
                .getElementById("chat-name-input")
                .value.trim();
              if (!newName) return alert("备注名/群名不能为空！");
              chat.name = newName;
              const selectedThemeRadio = document.querySelector(
                'input[name="theme-select"]:checked'
              );
              chat.settings.theme = selectedThemeRadio
                ? selectedThemeRadio.value
                : "default";

              chat.settings.fontSize = parseInt(
                document.getElementById("font-size-slider").value
              );
              chat.settings.customCss = document
                .getElementById("custom-css-input")
                .value.trim();

              chat.settings.myPersona =
                document.getElementById("my-persona").value;
              chat.settings.myAvatar =
                document.getElementById("my-avatar-preview").src;
              const checkedBooks = document.querySelectorAll(
                "#world-book-checkboxes-container input.wb-book-checkbox:checked"
              );
              chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(
                (cb) => cb.value
              );

              if (chat.isGroup) {
                chat.settings.myNickname = document
                  .getElementById("my-group-nickname-input")
                  .value.trim();
                chat.settings.groupAvatar = document.getElementById(
                  "group-avatar-preview"
                ).src;
              } else {
                chat.settings.aiPersona =
                  document.getElementById("ai-persona").value;
                chat.settings.aiAvatar =
                  document.getElementById("ai-avatar-preview").src;
                const selectedGroupId = document.getElementById(
                  "assign-group-select"
                ).value;
                chat.groupId = selectedGroupId
                  ? parseInt(selectedGroupId)
                  : null;
              }

              chat.settings.maxMemory =
                parseInt(document.getElementById("max-memory").value) || 10;
              await db.chats.put(chat);

              applyScopedCss(
                chat.settings.customCss,
                "#chat-messages",
                "custom-bubble-style"
              );

              chatSettingsModal.classList.remove("visible");
              renderChatInterface(state.activeChatId);
              renderChatList();
            });
          document
            .getElementById("clear-chat-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];
              const confirmed = await showCustomConfirm(
                "清空聊天记录",
                "此操作将永久删除此聊天的所有消息，无法恢复。确定要清空吗？",
                { confirmButtonClass: "btn-danger" }
              );
              if (confirmed) {
                chat.history = [];
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
                renderChatList();
                chatSettingsModal.classList.remove("visible");
              }
            });

          const setupFileUpload = (inputId, callback) => {
            document
              .getElementById(inputId)
              .addEventListener("change", async (event) => {
                const file = event.target.files[0];
                if (file) {
                  const dataUrl = await new Promise((res, rej) => {
                    const reader = new FileReader();
                    reader.onload = () => res(reader.result);
                    reader.onerror = () => rej(reader.error);
                    reader.readAsDataURL(file);
                  });
                  callback(dataUrl);
                  event.target.value = null;
                }
              });
          };
          setupFileUpload(
            "ai-avatar-input",
            (base64) =>
              (document.getElementById("ai-avatar-preview").src = base64)
          );
          setupFileUpload(
            "my-avatar-input",
            (base64) =>
              (document.getElementById("my-avatar-preview").src = base64)
          );
          setupFileUpload(
            "group-avatar-input",
            (base64) =>
              (document.getElementById("group-avatar-preview").src = base64)
          );
          setupFileUpload(
            "member-avatar-input",
            (base64) =>
              (document.getElementById("member-avatar-preview").src = base64)
          );
          setupFileUpload("bg-input", (base64) => {
            if (state.activeChatId) {
              state.chats[state.activeChatId].settings.background = base64;
              const bgPreview = document.getElementById("bg-preview");
              bgPreview.src = base64;
              bgPreview.style.display = "block";
              document.getElementById("remove-bg-btn").style.display =
                "inline-block";
            }
          });
          setupFileUpload(
            "preset-avatar-input",
            (base64) =>
              (document.getElementById("preset-avatar-preview").src = base64)
          );
          document
            .getElementById("remove-bg-btn")
            .addEventListener("click", () => {
              if (state.activeChatId) {
                state.chats[state.activeChatId].settings.background = "";
                const bgPreview = document.getElementById("bg-preview");
                bgPreview.src = "";
                bgPreview.style.display = "none";
                document.getElementById("remove-bg-btn").style.display = "none";
              }
            });

          const stickerPanel = document.getElementById("sticker-panel");
          document
            .getElementById("open-sticker-panel-btn")
            .addEventListener("click", () => {
              renderStickerPanel();
              stickerPanel.classList.add("visible");
            });
          document
            .getElementById("close-sticker-panel-btn")
            .addEventListener("click", () =>
              stickerPanel.classList.remove("visible")
            );
          document
            .getElementById("add-sticker-btn")
            .addEventListener("click", async () => {
              const url = await showCustomPrompt(
                "添加表情(URL)",
                "请输入表情包的图片URL"
              );
              if (!url || !url.trim().startsWith("http"))
                return url && alert("请输入有效的URL (以http开头)");
              const name = await showCustomPrompt(
                "命名表情",
                "请为这个表情命名 (例如：开心、疑惑)"
              );
              if (name && name.trim()) {
                const newSticker = {
                  id: "sticker_" + Date.now(),
                  url: url.trim(),
                  name: name.trim(),
                };
                await db.userStickers.add(newSticker);
                state.userStickers.push(newSticker);
                renderStickerPanel();
              } else if (name !== null) alert("表情名不能为空！");
            });
          document
            .getElementById("upload-sticker-btn")
            .addEventListener("click", () =>
              document.getElementById("sticker-upload-input").click()
            );
          document
            .getElementById("sticker-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (!file) return;
              const reader = new FileReader();
              reader.readAsDataURL(file);
              reader.onload = async () => {
                const base64Url = reader.result;
                const name = await showCustomPrompt(
                  "命名表情",
                  "请为这个表情命名 (例如：好耶、疑惑)"
                );
                if (name && name.trim()) {
                  const newSticker = {
                    id: "sticker_" + Date.now(),
                    url: base64Url,
                    name: name.trim(),
                  };
                  await db.userStickers.add(newSticker);
                  state.userStickers.push(newSticker);
                  renderStickerPanel();
                } else if (name !== null) alert("表情名不能为空！");
              };
              event.target.value = null;
            });

          document
            .getElementById("upload-image-btn")
            .addEventListener("click", () =>
              document.getElementById("image-upload-input").click()
            );
          document
            .getElementById("image-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (!file || !state.activeChatId) return;
              const reader = new FileReader();
              reader.onload = async (e) => {
                const base64Url = e.target.result;
                const chat = state.chats[state.activeChatId];
                const msg = {
                  role: "user",
                  content: [
                    { type: "image_url", image_url: { url: base64Url } },
                  ],
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                renderChatList();
              };
              reader.readAsDataURL(file);
              event.target.value = null;
            });
          document
            .getElementById("voice-message-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const text = await showCustomPrompt(
                "发送语音",
                "请输入你想说的内容："
              );
              if (text && text.trim()) {
                const chat = state.chats[state.activeChatId];
                const msg = {
                  role: "user",
                  type: "voice_message",
                  content: text.trim(),
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                renderChatList();
              }
            });
          document
            .getElementById("send-photo-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const description = await showCustomPrompt(
                "发送照片",
                "请用文字描述您要发送的照片："
              );
              if (description && description.trim()) {
                const chat = state.chats[state.activeChatId];
                const msg = {
                  role: "user",
                  type: "user_photo",
                  content: description.trim(),
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                renderChatList();
              }
            });

          // ▼▼▼ 【全新】外卖请求功能事件绑定 ▼▼▼
          const waimaiModal = document.getElementById("waimai-request-modal");
          document
            .getElementById("send-waimai-request-btn")
            .addEventListener("click", () => {
              waimaiModal.classList.add("visible");
            });

          document
            .getElementById("waimai-cancel-btn")
            .addEventListener("click", () => {
              waimaiModal.classList.remove("visible");
            });

          document
            .getElementById("waimai-confirm-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;

              const productInfoInput = document.getElementById(
                "waimai-product-info"
              );
              const amountInput = document.getElementById("waimai-amount");

              const productInfo = productInfoInput.value.trim();
              const amount = parseFloat(amountInput.value);

              if (!productInfo) {
                alert("请输入商品信息！");
                return;
              }
              if (isNaN(amount) || amount <= 0) {
                alert("请输入有效的代付金额！");
                return;
              }

              const chat = state.chats[state.activeChatId];
              const now = Date.now();

              // 【核心修正】在这里获取用户自己的昵称
              const myNickname = chat.isGroup
                ? chat.settings.myNickname || "我"
                : "我";

              const msg = {
                role: "user",
                // 【核心修正】将获取到的昵称，作为 senderName 添加到消息对象中
                senderName: myNickname,
                type: "waimai_request",
                productInfo: productInfo,
                amount: amount,
                status: "pending",
                countdownEndTime: now + 15 * 60 * 1000,
                timestamp: now,
              };

              chat.history.push(msg);
              await db.chats.put(chat);
              appendMessage(msg, chat);
              renderChatList();

              productInfoInput.value = "";
              amountInput.value = "";
              waimaiModal.classList.remove("visible");
            });
          document
            .getElementById("open-persona-library-btn")
            .addEventListener("click", openPersonaLibrary);
          document
            .getElementById("close-persona-library-btn")
            .addEventListener("click", closePersonaLibrary);
          document
            .getElementById("add-persona-preset-btn")
            .addEventListener("click", openPersonaEditorForCreate);
          document
            .getElementById("cancel-persona-editor-btn")
            .addEventListener("click", closePersonaEditor);
          document
            .getElementById("save-persona-preset-btn")
            .addEventListener("click", savePersonaPreset);
          document
            .getElementById("preset-action-edit")
            .addEventListener("click", openPersonaEditorForEdit);
          document
            .getElementById("preset-action-delete")
            .addEventListener("click", deletePersonaPreset);
          document
            .getElementById("preset-action-cancel")
            .addEventListener("click", hidePresetActions);

          document
            .getElementById("selection-cancel-btn")
            .addEventListener("click", exitSelectionMode);

          // ▼▼▼ 【最终加强版】用这块代码替换旧的 selection-delete-btn 事件监听器 ▼▼▼
          document
            .getElementById("selection-delete-btn")
            .addEventListener("click", async () => {
              if (selectedMessages.size === 0) return;
              const confirmed = await showCustomConfirm(
                "删除消息",
                `确定要删除选中的 ${selectedMessages.size} 条消息吗？这将改变AI的记忆。`,
                { confirmButtonClass: "btn-danger" }
              );
              if (confirmed) {
                const chat = state.chats[state.activeChatId];

                // 1. 【核心加强】在删除前，检查被删除的消息中是否包含投票
                let deletedPollsInfo = [];
                for (const timestamp of selectedMessages) {
                  const msg = chat.history.find(
                    (m) => m.timestamp === timestamp
                  );
                  if (msg && msg.type === "poll") {
                    deletedPollsInfo.push(
                      `关于“${msg.question}”的投票(时间戳: ${msg.timestamp})`
                    );
                  }
                }

                // 2. 更新后端的历史记录
                chat.history = chat.history.filter(
                  (msg) => !selectedMessages.has(msg.timestamp)
                );

                // 3. 【核心加强】构建更具体的“遗忘指令”
                let forgetReason = "一些之前的消息已被用户删除。";
                if (deletedPollsInfo.length > 0) {
                  forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join(
                    "；"
                  )}。`;
                }
                forgetReason +=
                  " 你应该像它们从未存在过一样继续对话，并相应地调整你的记忆和行为，不要再提及这些被删除的内容。";

                const forgetInstruction = {
                  role: "system",
                  content: `[系统提示：${forgetReason}]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(forgetInstruction);

                // 4. 将包含“遗忘指令”的、更新后的chat对象存回数据库
                await db.chats.put(chat);

                // 5. 最后才更新UI
                renderChatInterface(state.activeChatId);
                renderChatList();
              }
            });
          // ▲▲▲ 替换结束 ▲▲▲

          const fontUrlInput = document.getElementById("font-url-input");
          fontUrlInput.addEventListener("input", () =>
            applyCustomFont(fontUrlInput.value.trim(), true)
          );
          document
            .getElementById("save-font-btn")
            .addEventListener("click", async () => {
              const newFontUrl = fontUrlInput.value.trim();
              if (!newFontUrl) {
                alert("请输入有效的字体URL。");
                return;
              }
              applyCustomFont(newFontUrl, false);
              state.globalSettings.fontUrl = newFontUrl;
              await db.globalSettings.put(state.globalSettings);
              alert("字体已保存并应用！");
            });
          document
            .getElementById("reset-font-btn")
            .addEventListener("click", resetToDefaultFont);

          document
            .querySelectorAll("#chat-list-bottom-nav .nav-item")
            .forEach((item) => {
              item.addEventListener("click", () =>
                switchToChatListView(item.dataset.view)
              );
            });
          document
            .getElementById("qzone-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view")
            );
          document
            .getElementById("qzone-nickname")
            .addEventListener("click", async () => {
              const newNickname = await showCustomPrompt(
                "修改昵称",
                "请输入新的昵称",
                state.qzoneSettings.nickname
              );
              if (newNickname && newNickname.trim()) {
                state.qzoneSettings.nickname = newNickname.trim();
                await saveQzoneSettings();
                renderQzoneScreen();
              }
            });
          document
            .getElementById("qzone-avatar-container")
            .addEventListener("click", () =>
              document.getElementById("qzone-avatar-input").click()
            );
          document
            .getElementById("qzone-banner-container")
            .addEventListener("click", () =>
              document.getElementById("qzone-banner-input").click()
            );
          document
            .getElementById("qzone-avatar-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.readAsDataURL(file);
                });
                state.qzoneSettings.avatar = dataUrl;
                await saveQzoneSettings();
                renderQzoneScreen();
              }
              event.target.value = null;
            });
          document
            .getElementById("qzone-banner-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.readAsDataURL(file);
                });
                state.qzoneSettings.banner = dataUrl;
                await saveQzoneSettings();
                renderQzoneScreen();
              }
              event.target.value = null;
            });

          // ▼▼▼ 【修正后】的“说说”按钮事件 ▼▼▼
          document
            .getElementById("create-shuoshuo-btn")
            .addEventListener("click", async () => {
              // 1. 重置并获取模态框
              resetCreatePostModal();
              const modal = document.getElementById("create-post-modal");

              // 2. 设置为“说说”模式
              modal.dataset.mode = "shuoshuo";

              // 3. 隐藏与图片/文字图相关的部分
              modal.querySelector(".post-mode-switcher").style.display = "none";
              modal.querySelector("#image-mode-content").style.display = "none";
              modal.querySelector("#text-image-mode-content").style.display =
                "none";

              // 4. 修改主输入框的提示语，使其更符合“说说”的场景
              modal.querySelector("#post-public-text").placeholder =
                "分享新鲜事...";

              // 5. 准备并显示模态框
              const visibilityGroupsContainer = document.getElementById(
                "post-visibility-groups"
              );
              visibilityGroupsContainer.innerHTML = "";
              const groups = await db.qzoneGroups.toArray();
              if (groups.length > 0) {
                groups.forEach((group) => {
                  const label = document.createElement("label");
                  label.style.display = "block";
                  label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                  visibilityGroupsContainer.appendChild(label);
                });
              } else {
                visibilityGroupsContainer.innerHTML =
                  '<p style="color: var(--text-secondary);">没有可用的分组</p>';
              }
              modal.classList.add("visible");
            });

          // ▼▼▼ 【修正后】的“动态”（图片）按钮事件 ▼▼▼
          document
            .getElementById("create-post-btn")
            .addEventListener("click", async () => {
              // 1. 重置并获取模态框
              resetCreatePostModal();
              const modal = document.getElementById("create-post-modal");

              // 2. 设置为“复杂动态”模式
              modal.dataset.mode = "complex";

              // 3. 确保与图片/文字图相关的部分是可见的
              modal.querySelector(".post-mode-switcher").style.display = "flex";
              // 显式激活“上传图片”模式...
              modal
                .querySelector("#image-mode-content")
                .classList.add("active");
              // ...同时确保“文字图”模式是隐藏的
              modal
                .querySelector("#text-image-mode-content")
                .classList.remove("active");

              // 4. 恢复主输入框的默认提示语
              modal.querySelector("#post-public-text").placeholder =
                "分享新鲜事...（非必填的公开文字）";

              // 5. 准备并显示模态框（与“说说”按钮的逻辑相同）
              const visibilityGroupsContainer = document.getElementById(
                "post-visibility-groups"
              );
              visibilityGroupsContainer.innerHTML = "";
              const groups = await db.qzoneGroups.toArray();
              if (groups.length > 0) {
                groups.forEach((group) => {
                  const label = document.createElement("label");
                  label.style.display = "block";
                  label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                  visibilityGroupsContainer.appendChild(label);
                });
              } else {
                visibilityGroupsContainer.innerHTML =
                  '<p style="color: var(--text-secondary);">没有可用的分组</p>';
              }
              modal.classList.add("visible");
            });
          document
            .getElementById("open-album-btn")
            .addEventListener("click", async () => {
              await renderAlbumList();
              showScreen("album-screen");
            });
          document
            .getElementById("album-back-btn")
            .addEventListener("click", () => {
              showScreen("chat-list-screen");
              switchToChatListView("qzone-screen");
            });

          // --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

          document
            .getElementById("album-photos-back-btn")
            .addEventListener("click", () => {
              state.activeAlbumId = null;
              showScreen("album-screen");
            });

          document
            .getElementById("album-upload-photo-btn")
            .addEventListener("click", () =>
              document.getElementById("album-photo-input").click()
            );

          document
            .getElementById("album-photo-input")
            .addEventListener("change", async (event) => {
              if (!state.activeAlbumId) return;
              const files = event.target.files;
              if (!files.length) return;

              const album = await db.qzoneAlbums.get(state.activeAlbumId);

              for (const file of files) {
                const dataUrl = await new Promise((resolve) => {
                  const reader = new FileReader();
                  reader.onload = () => resolve(reader.result);
                  reader.readAsDataURL(file);
                });
                await db.qzonePhotos.add({
                  albumId: state.activeAlbumId,
                  url: dataUrl,
                  createdAt: Date.now(),
                });
              }

              const photoCount = await db.qzonePhotos
                .where("albumId")
                .equals(state.activeAlbumId)
                .count();
              const updateData = { photoCount };

              if (!album.photoCount || album.coverUrl.includes("placeholder")) {
                const firstPhoto = await db.qzonePhotos
                  .where("albumId")
                  .equals(state.activeAlbumId)
                  .first();
                if (firstPhoto) updateData.coverUrl = firstPhoto.url;
              }

              await db.qzoneAlbums.update(state.activeAlbumId, updateData);
              await renderAlbumPhotosScreen();
              await renderAlbumList();

              event.target.value = null;
              alert("照片上传成功！");
            });

          // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

          // --- ↓↓↓ 从这里开始复制，完整替换掉旧的 photos-grid-page 监听器 ↓↓↓ ---

          document
            .getElementById("photos-grid-page")
            .addEventListener("click", async (e) => {
              const deleteBtn = e.target.closest(".photo-delete-btn");
              const photoThumb = e.target.closest(".photo-thumb");

              if (deleteBtn) {
                e.stopPropagation(); // 阻止事件冒泡到图片上
                const photoId = parseInt(deleteBtn.dataset.photoId);
                const confirmed = await showCustomConfirm(
                  "删除照片",
                  "确定要删除这张照片吗？此操作不可恢复。",
                  { confirmButtonClass: "btn-danger" }
                );

                if (confirmed) {
                  const deletedPhoto = await db.qzonePhotos.get(photoId);
                  if (!deletedPhoto) return;

                  await db.qzonePhotos.delete(photoId);

                  const album = await db.qzoneAlbums.get(state.activeAlbumId);
                  const photoCount = (album.photoCount || 1) - 1;
                  const updateData = { photoCount };

                  if (album.coverUrl === deletedPhoto.url) {
                    const nextPhoto = await db.qzonePhotos
                      .where("albumId")
                      .equals(state.activeAlbumId)
                      .first();
                    updateData.coverUrl = nextPhoto
                      ? nextPhoto.url
                      : "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
                  }

                  await db.qzoneAlbums.update(state.activeAlbumId, updateData);
                  await renderAlbumPhotosScreen();
                  await renderAlbumList();
                  alert("照片已删除。");
                }
              } else if (photoThumb) {
                // 这就是恢复的图片点击放大功能！
                openPhotoViewer(photoThumb.src);
              }
            });

          // 恢复图片查看器的控制事件
          document
            .getElementById("photo-viewer-close-btn")
            .addEventListener("click", closePhotoViewer);
          document
            .getElementById("photo-viewer-next-btn")
            .addEventListener("click", showNextPhoto);
          document
            .getElementById("photo-viewer-prev-btn")
            .addEventListener("click", showPrevPhoto);

          // 恢复键盘左右箭头和ESC键的功能
          document.addEventListener("keydown", (e) => {
            if (!photoViewerState.isOpen) return;

            if (e.key === "ArrowRight") {
              showNextPhoto();
            } else if (e.key === "ArrowLeft") {
              showPrevPhoto();
            } else if (e.key === "Escape") {
              closePhotoViewer();
            }
          });

          // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

          document
            .getElementById("create-album-btn-page")
            .addEventListener("click", async () => {
              const albumName = await showCustomPrompt(
                "创建新相册",
                "请输入相册名称"
              );
              if (albumName && albumName.trim()) {
                const newAlbum = {
                  name: albumName.trim(),
                  coverUrl:
                    "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png",
                  photoCount: 0,
                  createdAt: Date.now(),
                };
                await db.qzoneAlbums.add(newAlbum);
                await renderAlbumList();
                alert(`相册 "${albumName}" 创建成功！`);
              } else if (albumName !== null) {
                alert("相册名称不能为空！");
              }
            });

          document
            .getElementById("cancel-create-post-btn")
            .addEventListener("click", () =>
              document
                .getElementById("create-post-modal")
                .classList.remove("visible")
            );
          document
            .getElementById("post-upload-local-btn")
            .addEventListener("click", () =>
              document.getElementById("post-local-image-input").click()
            );
          document
            .getElementById("post-local-image-input")
            .addEventListener("change", (event) => {
              const file = event.target.files[0];
              if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                  document.getElementById("post-image-preview").src =
                    e.target.result;
                  document
                    .getElementById("post-image-preview-container")
                    .classList.add("visible");
                  document.getElementById(
                    "post-image-desc-group"
                  ).style.display = "block";
                };
                reader.readAsDataURL(file);
              }
            });
          document
            .getElementById("post-use-url-btn")
            .addEventListener("click", async () => {
              const url = await showCustomPrompt(
                "输入图片URL",
                "请输入网络图片的链接",
                "",
                "url"
              );
              if (url) {
                document.getElementById("post-image-preview").src = url;
                document
                  .getElementById("post-image-preview-container")
                  .classList.add("visible");
                document.getElementById("post-image-desc-group").style.display =
                  "block";
              }
            });
          document
            .getElementById("post-remove-image-btn")
            .addEventListener("click", () => resetCreatePostModal());
          const imageModeBtn = document.getElementById("switch-to-image-mode");
          const textImageModeBtn = document.getElementById(
            "switch-to-text-image-mode"
          );
          const imageModeContent =
            document.getElementById("image-mode-content");
          const textImageModeContent = document.getElementById(
            "text-image-mode-content"
          );
          imageModeBtn.addEventListener("click", () => {
            imageModeBtn.classList.add("active");
            textImageModeBtn.classList.remove("active");
            imageModeContent.classList.add("active");
            textImageModeContent.classList.remove("active");
          });
          textImageModeBtn.addEventListener("click", () => {
            textImageModeBtn.classList.add("active");
            imageModeBtn.classList.remove("active");
            textImageModeContent.classList.add("active");
            imageModeContent.classList.remove("active");
          });

          // ▼▼▼ 【最终修正版】的“发布”按钮事件，已修复权限漏洞 ▼▼▼
          document
            .getElementById("confirm-create-post-btn")
            .addEventListener("click", async () => {
              const modal = document.getElementById("create-post-modal");
              const mode = modal.dataset.mode;

              // --- 1. 获取通用的可见性设置 ---
              const visibilityMode = document.querySelector(
                'input[name="visibility"]:checked'
              ).value;
              let visibleGroupIds = null;

              if (visibilityMode === "include") {
                visibleGroupIds = Array.from(
                  document.querySelectorAll(
                    'input[name="visibility_group"]:checked'
                  )
                ).map((cb) => parseInt(cb.value));
              }

              let newPost = {};
              const basePostData = {
                timestamp: Date.now(),
                authorId: "user",
                // 【重要】在这里就把权限信息存好
                visibleGroupIds: visibleGroupIds,
              };

              // --- 2. 根据模式构建不同的 post 对象 ---
              if (mode === "shuoshuo") {
                const content = document
                  .getElementById("post-public-text")
                  .value.trim();
                if (!content) {
                  alert("说说内容不能为空哦！");
                  return;
                }
                newPost = {
                  ...basePostData,
                  type: "shuoshuo",
                  content: content,
                };
              } else {
                // 处理 'complex' 模式 (图片/文字图)
                const publicText = document
                  .getElementById("post-public-text")
                  .value.trim();
                const isImageModeActive = document
                  .getElementById("image-mode-content")
                  .classList.contains("active");

                if (isImageModeActive) {
                  const imageUrl =
                    document.getElementById("post-image-preview").src;
                  const imageDescription = document
                    .getElementById("post-image-description")
                    .value.trim();
                  if (
                    !imageUrl ||
                    !(
                      imageUrl.startsWith("http") ||
                      imageUrl.startsWith("data:")
                    )
                  ) {
                    alert("请先添加一张图片再发布动态哦！");
                    return;
                  }
                  if (!imageDescription) {
                    alert("请为你的图片添加一个简单的描述（必填，给AI看的）！");
                    return;
                  }
                  newPost = {
                    ...basePostData,
                    type: "image_post",
                    publicText: publicText,
                    imageUrl: imageUrl,
                    imageDescription: imageDescription,
                  };
                } else {
                  // 文字图模式
                  const hiddenText = document
                    .getElementById("post-hidden-text")
                    .value.trim();
                  if (!hiddenText) {
                    alert("请输入文字图描述！");
                    return;
                  }
                  newPost = {
                    ...basePostData,
                    type: "text_image",
                    publicText: publicText,
                    hiddenContent: hiddenText,
                  };
                }
              }

              // --- 3. 保存到数据库 ---
              const newPostId = await db.qzonePosts.add(newPost);
              let postSummary =
                newPost.content ||
                newPost.publicText ||
                newPost.imageDescription ||
                newPost.hiddenContent ||
                "（无文字内容）";
              postSummary =
                postSummary.substring(0, 50) +
                (postSummary.length > 50 ? "..." : "");

              // --- 4. 【核心修正】带有权限检查的通知循环 ---
              for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (chat.isGroup) continue; // 跳过群聊

                let shouldNotify = false;
                const postVisibleGroups = newPost.visibleGroupIds;

                // 判断条件1：如果动态是公开的 (没有设置任何可见分组)
                if (!postVisibleGroups || postVisibleGroups.length === 0) {
                  shouldNotify = true;
                }
                // 判断条件2：如果动态设置了部分可见，并且当前角色在可见分组内
                else if (
                  chat.groupId &&
                  postVisibleGroups.includes(chat.groupId)
                ) {
                  shouldNotify = true;
                }

                // 只有满足条件的角色才会被通知
                if (shouldNotify) {
                  const historyMessage = {
                    role: "system",
                    content: `[系统提示：用户刚刚发布了一条动态(ID: ${newPostId})，内容摘要是：“${postSummary}”。你现在可以对这条动态进行评论了。]`,
                    timestamp: Date.now(),
                    isHidden: true,
                  };
                  chat.history.push(historyMessage);
                  await db.chats.put(chat);
                }
              }
              // --- 修正结束 ---

              await renderQzonePosts();
              modal.classList.remove("visible");
              alert("动态发布成功！");
            });

          // ▼▼▼ 请用这【一整块】包含所有滑动和点击事件的完整代码，替换掉旧的 postsList 事件监听器 ▼▼▼

          const postsList = document.getElementById("qzone-posts-list");
          let swipeState = {
            isDragging: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            activeContainer: null,
            swipeDirection: null,
            isClick: true,
          };

          function resetAllSwipes(exceptThisOne = null) {
            document
              .querySelectorAll(".qzone-post-container")
              .forEach((container) => {
                if (container !== exceptThisOne) {
                  container
                    .querySelector(".qzone-post-item")
                    .classList.remove("swiped");
                }
              });
          }

          const handleSwipeStart = (e) => {
            const targetContainer = e.target.closest(".qzone-post-container");
            if (!targetContainer) return;

            resetAllSwipes(targetContainer);
            swipeState.activeContainer = targetContainer;
            swipeState.isDragging = true;
            swipeState.isClick = true;
            swipeState.swipeDirection = null;
            swipeState.startX = e.type.includes("mouse")
              ? e.pageX
              : e.touches[0].pageX;
            swipeState.startY = e.type.includes("mouse")
              ? e.pageY
              : e.touches[0].pageY;
            swipeState.activeContainer.querySelector(
              ".qzone-post-item"
            ).style.transition = "none";
          };

          const handleSwipeMove = (e) => {
            if (!swipeState.isDragging || !swipeState.activeContainer) return;

            const currentX = e.type.includes("mouse")
              ? e.pageX
              : e.touches[0].pageX;
            const currentY = e.type.includes("mouse")
              ? e.pageY
              : e.touches[0].pageY;
            const diffX = currentX - swipeState.startX;
            const diffY = currentY - swipeState.startY;
            const absDiffX = Math.abs(diffX);
            const absDiffY = Math.abs(diffY);
            const clickThreshold = 5;

            if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
              swipeState.isClick = false;
            }

            if (swipeState.swipeDirection === null) {
              if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
                if (absDiffX > absDiffY) {
                  swipeState.swipeDirection = "horizontal";
                } else {
                  swipeState.swipeDirection = "vertical";
                }
              }
            }
            if (swipeState.swipeDirection === "vertical") {
              handleSwipeEnd(e);
              return;
            }
            if (swipeState.swipeDirection === "horizontal") {
              e.preventDefault();
              swipeState.currentX = currentX;
              let translation = diffX;
              if (translation > 0) translation = 0;
              if (translation < -90) translation = -90;
              swipeState.activeContainer.querySelector(
                ".qzone-post-item"
              ).style.transform = `translateX(${translation}px)`;
            }
          };

          const handleSwipeEnd = (e) => {
            if (swipeState.isClick) {
              swipeState.isDragging = false;
              swipeState.activeContainer = null;
              return;
            }
            if (!swipeState.isDragging || !swipeState.activeContainer) return;

            const postItem =
              swipeState.activeContainer.querySelector(".qzone-post-item");
            postItem.style.transition = "transform 0.3s ease";

            const finalX = e.type.includes("touchend")
              ? e.changedTouches[0].pageX
              : e.pageX;
            const diffX = finalX - swipeState.startX;
            const swipeThreshold = -40;

            if (
              swipeState.swipeDirection === "horizontal" &&
              diffX < swipeThreshold
            ) {
              postItem.classList.add("swiped");
              postItem.style.transform = "";
            } else {
              postItem.classList.remove("swiped");
              postItem.style.transform = "";
            }

            swipeState.isDragging = false;
            swipeState.startX = 0;
            swipeState.startY = 0;
            swipeState.currentX = 0;
            swipeState.activeContainer = null;
            swipeState.swipeDirection = null;
            swipeState.isClick = true;
          };

          // --- 绑定所有滑动事件 ---
          postsList.addEventListener("mousedown", handleSwipeStart);
          document.addEventListener("mousemove", handleSwipeMove);
          document.addEventListener("mouseup", handleSwipeEnd);
          postsList.addEventListener("touchstart", handleSwipeStart, {
            passive: false,
          });
          postsList.addEventListener("touchmove", handleSwipeMove, {
            passive: false,
          });
          postsList.addEventListener("touchend", handleSwipeEnd);

          // --- 绑定所有点击事件 ---
          postsList.addEventListener("click", async (e) => {
            e.stopPropagation();
            const target = e.target;

            // --- 新增：处理评论删除按钮 ---
            if (target.classList.contains("comment-delete-btn")) {
              const postContainer = target.closest(".qzone-post-container");
              if (!postContainer) return;

              const postId = parseInt(postContainer.dataset.postId);
              const commentIndex = parseInt(target.dataset.commentIndex);
              if (isNaN(postId) || isNaN(commentIndex)) return;

              const post = await db.qzonePosts.get(postId);
              if (!post || !post.comments || !post.comments[commentIndex])
                return;

              const commentText = post.comments[commentIndex].text;
              const confirmed = await showCustomConfirm(
                "删除评论",
                `确定要删除这条评论吗？\n\n“${commentText.substring(
                  0,
                  50
                )}...”`,
                { confirmButtonClass: "btn-danger" }
              );

              if (confirmed) {
                // 从数组中移除该评论
                post.comments.splice(commentIndex, 1);
                // 更新数据库
                await db.qzonePosts.update(postId, { comments: post.comments });
                // 重新渲染列表以反映更改
                await renderQzonePosts();
                alert("评论已删除。");
              }
              return; // 处理完后直接返回
            }

            if (target.classList.contains("post-actions-btn")) {
              const container = target.closest(".qzone-post-container");
              if (container && container.dataset.postId) {
                showPostActions(parseInt(container.dataset.postId));
              }
              return;
            }

            if (target.closest(".qzone-post-delete-action")) {
              const container = target.closest(".qzone-post-container");
              if (!container) return;

              const postIdToDelete = parseInt(container.dataset.postId);
              if (isNaN(postIdToDelete)) return;

              const confirmed = await showCustomConfirm(
                "删除动态",
                "确定要永久删除这条动态吗？",
                { confirmButtonClass: "btn-danger" }
              );

              if (confirmed) {
                container.style.transition = "all 0.3s ease";
                container.style.transform = "scale(0.8)";
                container.style.opacity = "0";

                setTimeout(async () => {
                  await db.qzonePosts.delete(postIdToDelete);

                  const notificationIdentifier = `(ID: ${postIdToDelete})`;
                  for (const chatId in state.chats) {
                    const chat = state.chats[chatId];
                    const originalHistoryLength = chat.history.length;
                    chat.history = chat.history.filter(
                      (msg) =>
                        !(
                          msg.role === "system" &&
                          msg.content.includes(notificationIdentifier)
                        )
                    );
                    if (chat.history.length < originalHistoryLength) {
                      await db.chats.put(chat);
                    }
                  }
                  await renderQzonePosts();
                  alert("动态已删除。");
                }, 300);
              }
              return;
            }

            if (target.tagName === "IMG" && target.dataset.hiddenText) {
              const hiddenText = target.dataset.hiddenText;
              showCustomAlert("图片内容", hiddenText.replace(/<br>/g, "\n"));
              return;
            }
            const icon = target.closest(".action-icon");
            if (icon) {
              const postContainer = icon.closest(".qzone-post-container");
              if (!postContainer) return;
              const postId = parseInt(postContainer.dataset.postId);
              if (isNaN(postId)) return;
              if (icon.classList.contains("like")) {
                const post = await db.qzonePosts.get(postId);
                if (!post) return;
                if (!post.likes) post.likes = [];
                const userNickname = state.qzoneSettings.nickname;
                const userLikeIndex = post.likes.indexOf(userNickname);
                if (userLikeIndex > -1) {
                  post.likes.splice(userLikeIndex, 1);
                } else {
                  post.likes.push(userNickname);
                  icon.classList.add("animate-like");
                  icon.addEventListener(
                    "animationend",
                    () => icon.classList.remove("animate-like"),
                    { once: true }
                  );
                }
                await db.qzonePosts.update(postId, { likes: post.likes });
              }
              if (icon.classList.contains("favorite")) {
                const existingFavorite = await db.favorites
                  .where({ type: "qzone_post", "content.id": postId })
                  .first();
                if (existingFavorite) {
                  await db.favorites.delete(existingFavorite.id);
                  await showCustomAlert("提示", "已取消收藏");
                } else {
                  const postToSave = await db.qzonePosts.get(postId);
                  if (postToSave) {
                    await db.favorites.add({
                      type: "qzone_post",
                      content: postToSave,
                      timestamp: Date.now(),
                    });
                    await showCustomAlert("提示", "收藏成功！");
                  }
                }
              }
              await renderQzonePosts();
              return;
            }
            const sendBtn = target.closest(".comment-send-btn");
            if (sendBtn) {
              const postContainer = sendBtn.closest(".qzone-post-container");
              if (!postContainer) return;
              const postId = parseInt(postContainer.dataset.postId);
              const commentInput =
                postContainer.querySelector(".comment-input");
              const commentText = commentInput.value.trim();
              if (!commentText) return alert("评论内容不能为空哦！");
              const post = await db.qzonePosts.get(postId);
              if (!post) return;
              if (!post.comments) post.comments = [];
              post.comments.push({
                commenterName: state.qzoneSettings.nickname,
                text: commentText,
                timestamp: Date.now(),
              });
              await db.qzonePosts.update(postId, { comments: post.comments });
              for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (!chat.isGroup) {
                  chat.history.push({
                    role: "system",
                    content: `[系统提示：'${state.qzoneSettings.nickname}' 在ID为${postId}的动态下发表了评论：“${commentText}”]`,
                    timestamp: Date.now(),
                    isHidden: true,
                  });
                  await db.chats.put(chat);
                }
              }
              commentInput.value = "";
              await renderQzonePosts();
              return;
            }
          });
          // ▲▲▲ 替换结束 ▲▲▲

          // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这两行 ▼▼▼

          // 绑定动态页和收藏页的返回按钮
          document
            .getElementById("qzone-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view")
            );
          document
            .getElementById("favorites-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view")
            );

          // ▲▲▲ 添加结束 ▲▲▲

          // ▼▼▼ 在 init() 函数的事件监听器区域，检查并确保你有这段完整的代码 ▼▼▼

          // 收藏页搜索功能
          const searchInput = document.getElementById("favorites-search-input");
          const searchClearBtn = document.getElementById(
            "favorites-search-clear-btn"
          );

          searchInput.addEventListener("input", () => {
            const searchTerm = searchInput.value.trim().toLowerCase();

            // 控制清除按钮的显示/隐藏
            searchClearBtn.style.display = searchTerm ? "block" : "none";

            if (!searchTerm) {
              displayFilteredFavorites(allFavoriteItems); // 如果搜索框为空，显示所有
              return;
            }

            // 筛选逻辑
            const filteredItems = allFavoriteItems.filter((item) => {
              let contentToSearch = "";
              let authorToSearch = "";

              if (item.type === "qzone_post") {
                const post = item.content;
                contentToSearch +=
                  (post.publicText || "") + " " + (post.content || "");
                if (post.authorId === "user") {
                  authorToSearch = state.qzoneSettings.nickname;
                } else if (state.chats[post.authorId]) {
                  authorToSearch = state.chats[post.authorId].name;
                }
              } else if (item.type === "chat_message") {
                const msg = item.content;
                if (typeof msg.content === "string") {
                  contentToSearch = msg.content;
                }
                const chat = state.chats[item.chatId];
                if (chat) {
                  if (msg.role === "user") {
                    authorToSearch = chat.isGroup
                      ? chat.settings.myNickname || "我"
                      : "我";
                  } else {
                    authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                  }
                }
              }

              // 同时搜索内容和作者，并且不区分大小写
              return (
                contentToSearch.toLowerCase().includes(searchTerm) ||
                authorToSearch.toLowerCase().includes(searchTerm)
              );
            });

            displayFilteredFavorites(filteredItems);
          });

          // 清除按钮的点击事件
          searchClearBtn.addEventListener("click", () => {
            searchInput.value = "";
            searchClearBtn.style.display = "none";
            displayFilteredFavorites(allFavoriteItems);
            searchInput.focus();
          });

          // ▲▲▲ 代码检查结束 ▲▲▲

          // ▼▼▼ 新增/修改的事件监听器 ▼▼▼

          // 为聊天界面的批量收藏按钮绑定事件
          // 为聊天界面的批量收藏按钮绑定事件 (已修正)
          document
            .getElementById("selection-favorite-btn")
            .addEventListener("click", async () => {
              if (selectedMessages.size === 0) return;
              const chat = state.chats[state.activeChatId];
              if (!chat) return;

              const favoritesToAdd = [];
              const timestampsToFavorite = [...selectedMessages];

              for (const timestamp of timestampsToFavorite) {
                // 【核心修正1】使用新的、高效的索引进行查询
                const existing = await db.favorites
                  .where("originalTimestamp")
                  .equals(timestamp)
                  .first();

                if (!existing) {
                  const messageToSave = chat.history.find(
                    (msg) => msg.timestamp === timestamp
                  );
                  if (messageToSave) {
                    favoritesToAdd.push({
                      type: "chat_message",
                      content: messageToSave,
                      chatId: state.activeChatId,
                      timestamp: Date.now(), // 这是收藏操作发生的时间
                      originalTimestamp: messageToSave.timestamp, // 【核心修正2】保存原始消息的时间戳到新字段
                    });
                  }
                }
              }

              if (favoritesToAdd.length > 0) {
                await db.favorites.bulkAdd(favoritesToAdd);
                allFavoriteItems = await db.favorites
                  .orderBy("timestamp")
                  .reverse()
                  .toArray(); // 更新全局收藏缓存
                await showCustomAlert(
                  "收藏成功",
                  `已成功收藏 ${favoritesToAdd.length} 条消息。`
                );
              } else {
                await showCustomAlert("提示", "选中的消息均已收藏过。");
              }

              exitSelectionMode();
            });

          // 收藏页面的"编辑"按钮事件 (已修正)
          const favoritesEditBtn =
            document.getElementById("favorites-edit-btn");
          const favoritesView = document.getElementById("favorites-view");
          const favoritesActionBar = document.getElementById(
            "favorites-action-bar"
          );
          const mainBottomNav = document.getElementById("chat-list-bottom-nav"); // 获取主导航栏
          const favoritesList = document.getElementById("favorites-list"); // 获取收藏列表

          favoritesEditBtn.addEventListener("click", () => {
            isFavoritesSelectionMode = !isFavoritesSelectionMode;
            favoritesView.classList.toggle(
              "selection-mode",
              isFavoritesSelectionMode
            );

            if (isFavoritesSelectionMode) {
              // --- 进入编辑模式 ---
              favoritesEditBtn.textContent = "完成";
              favoritesActionBar.style.display = "block"; // 显示删除操作栏
              mainBottomNav.style.display = "none"; // ▼ 新增：隐藏主导航栏
              favoritesList.style.paddingBottom = "80px"; // ▼ 新增：给列表底部增加空间
            } else {
              // --- 退出编辑模式 ---
              favoritesEditBtn.textContent = "编辑";
              favoritesActionBar.style.display = "none"; // 隐藏删除操作栏
              mainBottomNav.style.display = "flex"; // ▼ 新增：恢复主导航栏
              favoritesList.style.paddingBottom = ""; // ▼ 新增：恢复列表默认padding

              // 退出时清空所有选择
              selectedFavorites.clear();
              document
                .querySelectorAll(".favorite-item-card.selected")
                .forEach((card) => card.classList.remove("selected"));
              document.getElementById(
                "favorites-delete-selected-btn"
              ).textContent = `删除 (0)`;
            }
          });

          // ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
          // 收藏列表的点击选择事件 (事件委托)
          document
            .getElementById("favorites-list")
            .addEventListener("click", (e) => {
              const target = e.target;
              const card = target.closest(".favorite-item-card");

              // 【新增】处理文字图点击，这段逻辑要放在最前面，保证任何模式下都生效
              if (target.tagName === "IMG" && target.dataset.hiddenText) {
                const hiddenText = target.dataset.hiddenText;
                showCustomAlert("图片内容", hiddenText.replace(/<br>/g, "\n"));
                return; // 处理完就退出，不继续执行选择逻辑
              }

              // 如果不在选择模式，则不执行后续的选择操作
              if (!isFavoritesSelectionMode) return;

              // --- 以下是原有的选择逻辑，保持不变 ---
              if (!card) return;

              const favId = parseInt(card.dataset.favid);
              if (isNaN(favId)) return;

              // 切换选择状态
              if (selectedFavorites.has(favId)) {
                selectedFavorites.delete(favId);
                card.classList.remove("selected");
              } else {
                selectedFavorites.add(favId);
                card.classList.add("selected");
              }

              // 更新底部删除按钮的计数
              document.getElementById(
                "favorites-delete-selected-btn"
              ).textContent = `删除 (${selectedFavorites.size})`;
            });

          // ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
          // 收藏页面批量删除按钮事件
          document
            .getElementById("favorites-delete-selected-btn")
            .addEventListener("click", async () => {
              if (selectedFavorites.size === 0) return;

              const confirmed = await showCustomConfirm(
                "确认删除",
                `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`,
                { confirmButtonClass: "btn-danger" }
              );

              if (confirmed) {
                const idsToDelete = [...selectedFavorites];
                await db.favorites.bulkDelete(idsToDelete);
                await showCustomAlert("删除成功", "选中的收藏已被移除。");

                // 【核心修正1】从前端缓存中也移除被删除的项
                allFavoriteItems = allFavoriteItems.filter(
                  (item) => !idsToDelete.includes(item.id)
                );

                // 【核心修正2】使用更新后的缓存，立即重新渲染列表
                displayFilteredFavorites(allFavoriteItems);

                // 最后，再退出编辑模式
                favoritesEditBtn.click(); // 模拟点击"完成"按钮来退出编辑模式
              }
            });

          // ▼▼▼ 在 init() 函数末尾添加 ▼▼▼
          if (state.globalSettings.enableBackgroundActivity) {
            startBackgroundSimulation();
            console.log("后台活动模拟已自动启动。");
          }
          // ▲▲▲ 添加结束 ▲▲▲

          // ▼▼▼ 【这是最终的正确代码】请粘贴这段代码到 init() 的事件监听器区域末尾 ▼▼▼

          // --- 统一处理所有影响预览的控件的事件 ---

          // 1. 监听主题选择
          document
            .querySelectorAll('input[name="theme-select"]')
            .forEach((radio) => {
              radio.addEventListener("change", updateSettingsPreview);
            });

          // 2. 监听字体大小滑块
          const fontSizeSlider = document.getElementById("font-size-slider");
          fontSizeSlider.addEventListener("input", () => {
            // a. 实时更新数值显示
            document.getElementById(
              "font-size-value"
            ).textContent = `${fontSizeSlider.value}px`;
            // b. 更新预览
            updateSettingsPreview();
          });

          // 3. 监听自定义CSS输入框
          const customCssInputForPreview =
            document.getElementById("custom-css-input");
          customCssInputForPreview.addEventListener(
            "input",
            updateSettingsPreview
          );

          // 4. 监听重置按钮
          document
            .getElementById("reset-theme-btn")
            .addEventListener("click", () => {
              document.getElementById("theme-default").checked = true;
              updateSettingsPreview();
            });

          document
            .getElementById("reset-custom-css-btn")
            .addEventListener("click", () => {
              document.getElementById("custom-css-input").value = "";
              updateSettingsPreview();
            });

          // ▲▲▲ 粘贴结束 ▲▲▲

          // ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
          document
            .querySelectorAll('input[name="visibility"]')
            .forEach((radio) => {
              radio.addEventListener("change", function () {
                const groupsContainer = document.getElementById(
                  "post-visibility-groups"
                );
                if (this.value === "include" || this.value === "exclude") {
                  groupsContainer.style.display = "block";
                } else {
                  groupsContainer.style.display = "none";
                }
              });
            });
          // ▲▲▲ 新代码粘贴结束 ▲▲▲

          // ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
          document
            .getElementById("manage-groups-btn")
            .addEventListener("click", openGroupManager);
          document
            .getElementById("close-group-manager-btn")
            .addEventListener("click", () => {
              document
                .getElementById("group-management-modal")
                .classList.remove("visible");
              // 刷新聊天设置里的分组列表
              const chatSettingsBtn =
                document.getElementById("chat-settings-btn");
              if (
                document
                  .getElementById("chat-settings-modal")
                  .classList.contains("visible")
              ) {
                chatSettingsBtn.click(); // 再次点击以重新打开
              }
            });

          document
            .getElementById("add-new-group-btn")
            .addEventListener("click", addNewGroup);
          document
            .getElementById("existing-groups-list")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("delete-group-btn")) {
                const groupId = parseInt(e.target.dataset.id);
                deleteGroup(groupId);
              }
            });
          // ▲▲▲ 新代码粘贴结束 ▲▲▲

          // ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
          // 消息操作菜单的按钮事件
          document
            .getElementById("cancel-message-action-btn")
            .addEventListener("click", hideMessageActions);
          // ▼▼▼ 【修正】使用新的编辑器入口 ▼▼▼
          document
            .getElementById("edit-message-btn")
            .addEventListener("click", openAdvancedMessageEditor);
          // ▲▲▲ 替换结束 ▲▲▲
          document
            .getElementById("copy-message-btn")
            .addEventListener("click", copyMessageContent);

          // ▼▼▼ 在这里添加新代码 ▼▼▼
          document
            .getElementById("recall-message-btn")
            .addEventListener("click", handleRecallClick);
          // ▲▲▲ 添加结束 ▲▲▲

          // ▼▼▼ 请用这段【修正后】的代码替换旧的 select-message-btn 事件监听器 ▼▼▼
          document
            .getElementById("select-message-btn")
            .addEventListener("click", () => {
              // 【核心修复】在关闭菜单前，先捕获时间戳
              const timestampToSelect = activeMessageTimestamp;
              hideMessageActions();
              // 使用捕获到的值
              if (timestampToSelect) {
                enterSelectionMode(timestampToSelect);
              }
            });
          // ▲▲▲ 替换结束 ▲▲▲

          // ▼▼▼ 在 init() 函数的事件监听器区域末尾添加 ▼▼▼

          // 动态操作菜单的按钮事件
          document
            .getElementById("edit-post-btn")
            .addEventListener("click", openPostEditor);
          document
            .getElementById("copy-post-btn")
            .addEventListener("click", copyPostContent);
          document
            .getElementById("cancel-post-action-btn")
            .addEventListener("click", hidePostActions);

          // ▲▲▲ 添加结束 ▲▲▲

          // ▼▼▼ 【新增】联系人选择器事件绑定 ▼▼▼
          document
            .getElementById("cancel-contact-picker-btn")
            .addEventListener("click", () => {
              showScreen("chat-list-screen");
            });

          document
            .getElementById("contact-picker-list")
            .addEventListener("click", (e) => {
              const item = e.target.closest(".contact-picker-item");
              if (!item) return;

              const contactId = item.dataset.contactId;
              item.classList.toggle("selected");

              if (selectedContacts.has(contactId)) {
                selectedContacts.delete(contactId);
              } else {
                selectedContacts.add(contactId);
              }
              updateContactPickerConfirmButton();
            });

          // ▼▼▼ 【新增】绑定“管理群成员”按钮事件 ▼▼▼
          document
            .getElementById("manage-members-btn")
            .addEventListener("click", () => {
              // 在切换屏幕前，先隐藏当前的聊天设置弹窗
              document
                .getElementById("chat-settings-modal")
                .classList.remove("visible");
              // 然后再打开成员管理屏幕
              openMemberManagementScreen();
            });
          // ▲▲▲ 新增代码结束 ▲▲▲

          // ▼▼▼ 【最终完整版】群成员管理功能事件绑定 ▼▼▼
          document
            .getElementById("back-from-member-management")
            .addEventListener("click", () => {
              showScreen("chat-interface-screen");
              document.getElementById("chat-settings-btn").click();
            });
          // ▲▲▲ 替换结束 ▲▲▲

          document
            .getElementById("member-management-list")
            .addEventListener("click", (e) => {
              // 【已恢复】移除成员的事件
              if (e.target.classList.contains("remove-member-btn")) {
                removeMemberFromGroup(e.target.dataset.memberId);
              }
            });

          document
            .getElementById("add-existing-contact-btn")
            .addEventListener("click", async () => {
              // 【已恢复】从好友列表添加的事件
              // 【关键】为“完成”按钮绑定“拉人入群”的逻辑
              const confirmBtn = document.getElementById(
                "confirm-contact-picker-btn"
              );
              // 使用克隆节点方法清除旧的事件监听器，防止重复绑定
              const newConfirmBtn = confirmBtn.cloneNode(true);
              confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
              newConfirmBtn.addEventListener("click", handleAddMembersToGroup);

              await openContactPickerForAddMember();
            });

          document
            .getElementById("create-new-member-btn")
            .addEventListener("click", createNewMemberInGroup);
          // ▲▲▲ 替换结束 ▲▲▲

          // ▼▼▼ 【全新】视频通话功能事件监听器 ▼▼▼

          // 绑定单聊和群聊的发起按钮
          document
            .getElementById("video-call-btn")
            .addEventListener("click", handleInitiateCall);
          document
            .getElementById("group-video-call-btn")
            .addEventListener("click", handleInitiateCall);

          // 绑定“挂断”按钮
          document
            .getElementById("hang-up-btn")
            .addEventListener("click", endVideoCall);

          // 绑定“取消呼叫”按钮
          document
            .getElementById("cancel-call-btn")
            .addEventListener("click", () => {
              videoCallState.isAwaitingResponse = false;
              showScreen("chat-interface-screen");
            });

          // 【全新】绑定“加入通话”按钮
          document
            .getElementById("join-call-btn")
            .addEventListener("click", handleUserJoinCall);

          // ▼▼▼ 用这个【已修复并激活旁观模式】的版本替换旧的 decline-call-btn 事件监听器 ▼▼▼
          // 绑定来电请求的“拒绝”按钮
          document
            .getElementById("decline-call-btn")
            .addEventListener("click", async () => {
              hideIncomingCallModal();
              const chat = state.chats[videoCallState.activeChatId];
              if (!chat) return;

              // 【核心修正】在这里，我们将拒绝的逻辑与API调用连接起来
              if (videoCallState.isGroupCall) {
                videoCallState.isUserParticipating = false; // 标记用户为旁观者

                // 1. 创建一条隐藏消息，通知AI用户拒绝了
                const systemNote = {
                  role: "system",
                  content: `[系统提示：用户拒绝了通话邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(systemNote);
                await db.chats.put(chat);

                // 2. 【关键】触发AI响应，让它们自己决定要不要开始群聊
                // 这将会在后台处理，如果AI们决定开始，最终会调用 startVideoCall()
                await triggerAiResponse();
              } else {
                // 单聊拒绝逻辑保持不变
                const declineMessage = {
                  role: "user",
                  content: "我拒绝了你的视频通话请求。",
                  timestamp: Date.now(),
                };
                chat.history.push(declineMessage);
                await db.chats.put(chat);

                // 回到聊天界面并显示拒绝消息
                showScreen("chat-interface-screen");
                appendMessage(declineMessage, chat);

                // 让AI对你的拒绝做出回应
                triggerAiResponse();
              }

              // 清理状态，以防万一
              videoCallState.isAwaitingResponse = false;
            });
          // ▲▲▲ 替换结束 ▲▲▲

          // ▼▼▼ 用这个【已修复重复头像BUG】的版本替换旧的 accept-call-btn 事件监听器 ▼▼▼
          // 绑定来电请求的“接听”按钮
          document
            .getElementById("accept-call-btn")
            .addEventListener("click", async () => {
              hideIncomingCallModal();

              videoCallState.initiator = "ai";
              videoCallState.isUserParticipating = true;
              videoCallState.activeChatId = state.activeChatId;

              // 【核心修正】我们在这里不再手动添加用户到 participants 列表
              if (videoCallState.isGroupCall) {
                // 对于群聊，我们只把【发起通话的AI】加入参与者列表
                const chat = state.chats[videoCallState.activeChatId];
                const requester = chat.members.find(
                  (m) => m.name === videoCallState.callRequester
                );
                if (requester) {
                  // 清空可能存在的旧数据，然后只添加发起者
                  videoCallState.participants = [requester];
                } else {
                  videoCallState.participants = []; // 如果找不到发起者，就清空
                }
              }

              // 无论单聊还是群聊，直接启动通话界面！
              startVideoCall();
            });
          // ▲▲▲ 替换结束 ▲▲▲

          // ▼▼▼ 请用这个【已增加用户高亮】的全新版本，完整替换旧的 user-speak-btn 事件监听器 ▼▼▼
          // 绑定用户在通话中发言的按钮
          document
            .getElementById("user-speak-btn")
            .addEventListener("click", async () => {
              if (!videoCallState.isActive) return;

              // ★★★★★ 核心新增：在弹出输入框前，先找到并高亮用户头像 ★★★★★
              const userAvatar = document.querySelector(
                '.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar'
              );
              if (userAvatar) {
                userAvatar.classList.add("speaking");
              }

              const userInput = await showCustomPrompt(
                "你说",
                "请输入你想说的话..."
              );

              // ★★★★★ 核心新增：无论用户是否输入，只要关闭输入框就移除高亮 ★★★★★
              if (userAvatar) {
                userAvatar.classList.remove("speaking");
              }

              if (userInput && userInput.trim()) {
                triggerAiInCallAction(userInput.trim());
              }
            });
          // ▲▲▲ 替换结束 ▲▲▲

          // ▼▼▼ 【新增】回忆录相关事件绑定 ▼▼▼
          // 1. 将“回忆”页签和它的视图连接起来
          document
            .querySelector('.nav-item[data-view="memories-view"]')
            .addEventListener("click", () => {
              // 在切换前，确保"收藏"页面的编辑模式已关闭
              if (isFavoritesSelectionMode) {
                document.getElementById("favorites-edit-btn").click();
              }
              switchToChatListView("memories-view");
              renderMemoriesScreen(); // 点击时渲染
            });

          // 2. 绑定回忆录界面的返回按钮
          document
            .getElementById("memories-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view")
            );

          // ▲▲▲ 新增结束 ▲▲▲

          // 【全新】约定/倒计时功能事件绑定
          document
            .getElementById("add-countdown-btn")
            .addEventListener("click", () => {
              document
                .getElementById("create-countdown-modal")
                .classList.add("visible");
            });
          document
            .getElementById("cancel-create-countdown-btn")
            .addEventListener("click", () => {
              document
                .getElementById("create-countdown-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("confirm-create-countdown-btn")
            .addEventListener("click", async () => {
              const title = document
                .getElementById("countdown-title-input")
                .value.trim();
              const dateValue = document.getElementById(
                "countdown-date-input"
              ).value;

              if (!title || !dateValue) {
                alert("请填写完整的约定标题和日期！");
                return;
              }

              const targetDate = new Date(dateValue);
              if (isNaN(targetDate) || targetDate <= new Date()) {
                alert("请输入一个有效的、未来的日期！");
                return;
              }

              const newCountdown = {
                chatId: null, // 用户创建的，不属于任何特定AI
                authorName: "我",
                description: title,
                timestamp: Date.now(),
                type: "countdown",
                targetDate: targetDate.getTime(),
              };

              await db.memories.add(newCountdown);
              document
                .getElementById("create-countdown-modal")
                .classList.remove("visible");
              renderMemoriesScreen();
            });

          // 【全新】拉黑功能事件绑定
          document
            .getElementById("block-chat-btn")
            .addEventListener("click", async () => {
              if (
                !state.activeChatId ||
                state.chats[state.activeChatId].isGroup
              )
                return;

              const chat = state.chats[state.activeChatId];
              const confirmed = await showCustomConfirm(
                "确认拉黑",
                `确定要拉黑“${chat.name}”吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`,
                { confirmButtonClass: "btn-danger" }
              );

              if (confirmed) {
                chat.relationship.status = "blocked_by_user";
                chat.relationship.blockedTimestamp = Date.now();

                // ▼▼▼ 在这里添加下面的代码 ▼▼▼
                const hiddenMessage = {
                  role: "system",
                  content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
                  timestamp: Date.now() + 1,
                  isHidden: true,
                };
                chat.history.push(hiddenMessage);
                // ▲▲▲ 添加结束 ▲▲▲

                await db.chats.put(chat);

                // 关闭设置弹窗，并刷新聊天界面
                document
                  .getElementById("chat-settings-modal")
                  .classList.remove("visible");
                renderChatInterface(state.activeChatId);
                // 刷新聊天列表，可能会有UI变化
                renderChatList();
              }
            });

          document
            .getElementById("chat-lock-overlay")
            .addEventListener("click", async (e) => {
              const chat = state.chats[state.activeChatId];
              if (!chat) return;

              if (e.target.id === "force-apply-check-btn") {
                alert(
                  "正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。"
                );
                await triggerAiFriendApplication(chat.id);
                renderChatInterface(chat.id);
                return;
              }

              if (e.target.id === "unblock-btn") {
                chat.relationship.status = "friend";
                chat.relationship.blockedTimestamp = null;

                // ▼▼▼ 在这里添加下面的代码 ▼▼▼
                const hiddenMessage = {
                  role: "system",
                  content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(hiddenMessage);
                // ▲▲▲ 添加结束 ▲▲▲

                await db.chats.put(chat);
                renderChatInterface(chat.id);
                renderChatList();
                triggerAiResponse(); // 【可选但推荐】解除后让AI主动说点什么
              } else if (e.target.id === "accept-friend-btn") {
                chat.relationship.status = "friend";
                chat.relationship.applicationReason = "";

                // ▼▼▼ 在这里添加下面的代码 ▼▼▼
                const hiddenMessage = {
                  role: "system",
                  content: `[系统提示：用户刚刚通过了你的好友申请。你们现在又可以正常聊天了。]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(hiddenMessage);
                // ▲▲▲ 添加结束 ▲▲▲

                await db.chats.put(chat);
                renderChatInterface(chat.id);
                renderChatList();
                const msg = {
                  role: "user",
                  content: "我通过了你的好友请求",
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                triggerAiResponse();
              } else if (e.target.id === "reject-friend-btn") {
                chat.relationship.status = "blocked_by_user";
                chat.relationship.blockedTimestamp = Date.now();
                chat.relationship.applicationReason = "";
                await db.chats.put(chat);
                renderChatInterface(chat.id);
              }
              // 【新增】处理申请好友按钮的点击事件
              else if (e.target.id === "apply-friend-btn") {
                const reason = await showCustomPrompt(
                  "发送好友申请",
                  `请输入你想对“${chat.name}”说的申请理由：`,
                  "我们和好吧！"
                );
                // 只有当用户输入了内容并点击“确定”后才继续
                if (reason !== null) {
                  // 更新关系状态为“等待AI批准”
                  chat.relationship.status = "pending_ai_approval";
                  chat.relationship.applicationReason = reason;
                  await db.chats.put(chat);

                  // 刷新UI，显示“等待通过”的界面
                  renderChatInterface(chat.id);
                  renderChatList();

                  // 【关键】触发AI响应，让它去处理这个好友申请
                  triggerAiResponse();
                }
              }
            });

          // ▼▼▼ 【全新】红包功能事件绑定 ▼▼▼

          // 1. 将原有的转账按钮(￥)的点击事件，重定向到新的总入口函数
          document
            .getElementById("transfer-btn")
            .addEventListener("click", handlePaymentButtonClick);

          // 2. 红包模态框内部的控制按钮
          document
            .getElementById("cancel-red-packet-btn")
            .addEventListener("click", () => {
              document
                .getElementById("red-packet-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("send-group-packet-btn")
            .addEventListener("click", sendGroupRedPacket);
          document
            .getElementById("send-direct-packet-btn")
            .addEventListener("click", sendDirectRedPacket);

          // 3. 红包模态框的页签切换逻辑
          const rpTabGroup = document.getElementById("rp-tab-group");
          const rpTabDirect = document.getElementById("rp-tab-direct");
          const rpContentGroup = document.getElementById("rp-content-group");
          const rpContentDirect = document.getElementById("rp-content-direct");

          rpTabGroup.addEventListener("click", () => {
            rpTabGroup.classList.add("active");
            rpTabDirect.classList.remove("active");
            rpContentGroup.style.display = "block";
            rpContentDirect.style.display = "none";
          });
          rpTabDirect.addEventListener("click", () => {
            rpTabDirect.classList.add("active");
            rpTabGroup.classList.remove("active");
            rpContentDirect.style.display = "block";
            rpContentGroup.style.display = "none";
          });

          // 4. 实时更新红包金额显示
          document
            .getElementById("rp-group-amount")
            .addEventListener("input", (e) => {
              const amount = parseFloat(e.target.value) || 0;
              document.getElementById(
                "rp-group-total"
              ).textContent = `¥ ${amount.toFixed(2)}`;
            });
          document
            .getElementById("rp-direct-amount")
            .addEventListener("input", (e) => {
              const amount = parseFloat(e.target.value) || 0;
              document.getElementById(
                "rp-direct-total"
              ).textContent = `¥ ${amount.toFixed(2)}`;
            });

          // ▲▲▲ 新事件绑定结束 ▲▲▲

          // ▼▼▼ 【全新添加】使用事件委托处理红包点击，修复失效问题 ▼▼▼
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 1. 找到被点击的红包卡片
              const packetCard = e.target.closest(".red-packet-card");
              if (!packetCard) return; // 如果点击的不是红包，就什么也不做

              // 2. 从红包卡片的父级.message-bubble获取时间戳
              const messageBubble = packetCard.closest(".message-bubble");
              if (!messageBubble || !messageBubble.dataset.timestamp) return;

              // 3. 调用我们现有的处理函数
              const timestamp = parseInt(messageBubble.dataset.timestamp);
              handlePacketClick(timestamp);
            });
          // ▲▲▲ 新增代码结束 ▲▲▲

          // ▼▼▼ 【全新】投票功能事件监听器 ▼▼▼
          // 在输入框工具栏添加按钮
          document
            .getElementById("send-poll-btn")
            .addEventListener("click", openCreatePollModal);

          // 投票创建模态框的按钮
          document
            .getElementById("add-poll-option-btn")
            .addEventListener("click", addPollOptionInput);
          document
            .getElementById("cancel-create-poll-btn")
            .addEventListener("click", () => {
              document
                .getElementById("create-poll-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("confirm-create-poll-btn")
            .addEventListener("click", sendPoll);

          // 使用事件委托处理投票卡片内的所有点击事件
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              const pollCard = e.target.closest(".poll-card");
              if (!pollCard) return;

              const timestamp = parseInt(pollCard.dataset.pollTimestamp);
              if (isNaN(timestamp)) return;

              // 点击了选项
              const optionItem = e.target.closest(".poll-option-item");
              if (optionItem && !pollCard.classList.contains("closed")) {
                handleUserVote(timestamp, optionItem.dataset.option);
                return;
              }

              // 点击了动作按钮（结束投票/查看结果）
              const actionBtn = e.target.closest(".poll-action-btn");
              if (actionBtn) {
                if (pollCard.classList.contains("closed")) {
                  showPollResults(timestamp);
                } else {
                  endPoll(timestamp);
                }
                return;
              }

              // 如果是已结束的投票，点击卡片任何地方都可以查看结果
              if (pollCard.classList.contains("closed")) {
                showPollResults(timestamp);
              }
            });
          // ▲▲▲ 新事件监听器粘贴结束 ▲▲▲

          // ▼▼▼ 【全新】AI头像库功能事件绑定 ▼▼▼
          document
            .getElementById("manage-ai-avatar-library-btn")
            .addEventListener("click", openAiAvatarLibraryModal);
          document
            .getElementById("add-ai-avatar-btn")
            .addEventListener("click", addAvatarToLibrary);
          document
            .getElementById("close-ai-avatar-library-btn")
            .addEventListener("click", closeAiAvatarLibraryModal);
          // ▲▲▲ 新增结束 ▲▲▲

          // ▼▼▼ 在 init() 的事件监听区域，粘贴这段【新代码】▼▼▼
          document
            .getElementById("icon-settings-grid")
            .addEventListener("click", async (e) => {
              if (e.target.classList.contains("change-icon-btn")) {
                const item = e.target.closest(".icon-setting-item");
                const iconId = item.dataset.iconId;
                if (!iconId) return;

                const currentUrl = state.globalSettings.appIcons[iconId];
                const newUrl = await showCustomPrompt(
                  `更换“${item.querySelector(".icon-preview").alt}”图标`,
                  "请输入新的图片URL",
                  currentUrl,
                  "url"
                );

                if (newUrl && newUrl.trim().startsWith("http")) {
                  // 仅在内存中更新，等待用户点击“保存”
                  state.globalSettings.appIcons[iconId] = newUrl.trim();
                  // 实时更新设置页面的预览图
                  item.querySelector(".icon-preview").src = newUrl.trim();
                } else if (newUrl !== null) {
                  alert("请输入一个有效的URL！");
                }
              }
            });
          // ▲▲▲ 新代码粘贴结束 ▲▲▲

          // ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 使用 .closest() 向上查找被点击的卡片
              const linkCard = e.target.closest(".link-share-card");
              if (linkCard) {
                const timestamp = parseInt(linkCard.dataset.timestamp);
                if (!isNaN(timestamp)) {
                  openBrowser(timestamp); // 调用我们的函数
                }
              }
            });

          // 浏览器返回按钮的事件监听，确保它只绑定一次
          document
            .getElementById("browser-back-btn")
            .addEventListener("click", () => {
              showScreen("chat-interface-screen");
            });

          // ▲▲▲ 新代码粘贴结束 ▲▲▲

          // ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

          // 1. 绑定输入框上方“分享链接”按钮的点击事件
          document
            .getElementById("share-link-btn")
            .addEventListener("click", openShareLinkModal);

          // 2. 绑定模态框中“取消”按钮的点击事件
          document
            .getElementById("cancel-share-link-btn")
            .addEventListener("click", () => {
              document
                .getElementById("share-link-modal")
                .classList.remove("visible");
            });

          // 3. 绑定模态框中“分享”按钮的点击事件
          document
            .getElementById("confirm-share-link-btn")
            .addEventListener("click", sendUserLinkShare);

          // ▲▲▲ 新代码粘贴结束 ▲▲▲

          document
            .getElementById("theme-toggle-switch")
            .addEventListener("change", toggleTheme);

          // ▼▼▼ 在 init() 的事件监听器区域，粘贴下面这几行 ▼▼▼
          // 绑定消息操作菜单中的“引用”按钮
          document
            .getElementById("quote-message-btn")
            .addEventListener("click", startReplyToMessage);

          // 绑定回复预览栏中的“取消”按钮
          document
            .getElementById("cancel-reply-btn")
            .addEventListener("click", cancelReplyMode);
          // ▲▲▲ 粘贴结束 ▲▲▲

          // 在你的 init() 函数的事件监听器区域...

          // ▼▼▼ 用这段代码替换旧的转账卡片点击事件 ▼▼▼
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 1. 向上查找被点击的元素是否在一个消息气泡内
              const bubble = e.target.closest(".message-bubble");
              if (!bubble) return; // 如果不在，就退出

              // 2. 【核心修正】在这里添加严格的筛选条件
              // 必须是 AI 的消息 (.ai)
              // 必须是转账类型 (.is-transfer)
              // 必须是我们标记为“待处理”的 (data-status="pending")
              if (
                bubble.classList.contains("ai") &&
                bubble.classList.contains("is-transfer") &&
                bubble.dataset.status === "pending"
              ) {
                // 3. 只有满足所有条件，才执行后续逻辑
                const timestamp = parseInt(bubble.dataset.timestamp);
                if (!isNaN(timestamp)) {
                  showTransferActionModal(timestamp);
                }
              }
            });
          // ▲▲▲ 替换结束 ▲▲▲

          // 在 init() 的事件监听区域添加
          document
            .getElementById("transfer-action-accept")
            .addEventListener("click", () =>
              handleUserTransferResponse("accepted")
            );
          document
            .getElementById("transfer-action-decline")
            .addEventListener("click", () =>
              handleUserTransferResponse("declined")
            );
          document
            .getElementById("transfer-action-cancel")
            .addEventListener("click", hideTransferActionModal);

          // ▼▼▼ 用这段【新代码】替换旧的通话记录事件绑定 ▼▼▼

          document
            .getElementById("chat-list-title")
            .addEventListener("click", renderCallHistoryScreen);

          // 2. 绑定通话记录页面的“返回”按钮
          document
            .getElementById("call-history-back-btn")
            .addEventListener("click", () => {
              // 【核心修改】返回到聊天列表页面，而不是聊天界面
              showScreen("chat-list-screen");
            });

          // 3. 监听卡片点击的逻辑保持不变
          document
            .getElementById("call-history-list")
            .addEventListener("click", (e) => {
              const card = e.target.closest(".call-record-card");
              if (card && card.dataset.recordId) {
                showCallTranscript(parseInt(card.dataset.recordId));
              }
            });

          // 4. 关闭详情弹窗的逻辑保持不变
          document
            .getElementById("close-transcript-modal-btn")
            .addEventListener("click", () => {
              document
                .getElementById("call-transcript-modal")
                .classList.remove("visible");
            });

          // ▲▲▲ 替换结束 ▲▲▲

          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 1. 检查点击的是否是语音条
              const voiceBody = e.target.closest(".voice-message-body");
              if (!voiceBody) return;

              // 2. 找到相关的DOM元素
              const bubble = voiceBody.closest(".message-bubble");
              if (!bubble) return;

              const waveIcon = voiceBody.querySelector(".wave-icon");
              const transcriptEl = bubble.querySelector(".voice-transcript");

              // 如果正在加载中，则不响应点击
              if (bubble.dataset.state === "loading") {
                return;
              }

              // 3. 如果文字已经展开，则收起
              if (bubble.dataset.state === "expanded") {
                transcriptEl.style.display = "none";
                bubble.dataset.state = "collapsed";
              }
              // 4. 如果是收起状态，则开始“转录”流程
              else {
                bubble.dataset.state = "loading"; // 进入加载状态
                if (waveIcon) waveIcon.classList.add("playing"); // 显示播放动画

                // 模拟1.5秒的语音识别过程
                setTimeout(() => {
                  // 检查此时元素是否还存在（可能用户已经切换了聊天）
                  if (document.body.contains(bubble)) {
                    const voiceText = bubble.dataset.voiceText || "(无法识别)";
                    transcriptEl.textContent = voiceText; // 填充文字

                    if (waveIcon) waveIcon.classList.remove("playing"); // 停止播放动画
                    transcriptEl.style.display = "block"; // 显示文字
                    bubble.dataset.state = "expanded"; // 进入展开状态
                  }
                }, 1500);
              }
            });

          document
            .getElementById("chat-header-status")
            .addEventListener("click", handleEditStatusClick);

          // 在 init() 的事件监听器区域添加
          document
            .getElementById("selection-share-btn")
            .addEventListener("click", () => {
              if (selectedMessages.size > 0) {
                openShareTargetPicker(); // 打开我们即将创建的目标选择器
              }
            });

          // 在 init() 的事件监听器区域添加
          document
            .getElementById("confirm-share-target-btn")
            .addEventListener("click", async () => {
              const sourceChat = state.chats[state.activeChatId];
              const selectedTargetIds = Array.from(
                document.querySelectorAll(".share-target-checkbox:checked")
              ).map((cb) => cb.dataset.chatId);

              if (selectedTargetIds.length === 0) {
                alert("请至少选择一个要分享的聊天。");
                return;
              }

              // 1. 打包聊天记录
              const sharedHistory = [];
              const sortedTimestamps = [...selectedMessages].sort(
                (a, b) => a - b
              );
              for (const timestamp of sortedTimestamps) {
                const msg = sourceChat.history.find(
                  (m) => m.timestamp === timestamp
                );
                if (msg) {
                  sharedHistory.push(msg);
                }
              }

              // 2. 创建分享卡片消息对象
              const shareCardMessage = {
                role: "user",
                senderName: sourceChat.isGroup
                  ? sourceChat.settings.myNickname || "我"
                  : "我",
                type: "share_card",
                timestamp: Date.now(),
                payload: {
                  sourceChatName: sourceChat.name,
                  title: `来自“${sourceChat.name}”的聊天记录`,
                  sharedHistory: sharedHistory,
                },
              };

              // 3. 循环发送到所有目标聊天
              for (const targetId of selectedTargetIds) {
                const targetChat = state.chats[targetId];
                if (targetChat) {
                  targetChat.history.push(shareCardMessage);
                  await db.chats.put(targetChat);
                }
              }

              // 4. 收尾工作
              document
                .getElementById("share-target-modal")
                .classList.remove("visible");
              exitSelectionMode(); // 退出多选模式
              await showCustomAlert(
                "分享成功",
                `聊天记录已成功分享到 ${selectedTargetIds.length} 个会话中。`
              );
              renderChatList(); // 刷新列表，可能会有新消息提示
            });

          // 绑定取消按钮
          document
            .getElementById("cancel-share-target-btn")
            .addEventListener("click", () => {
              document
                .getElementById("share-target-modal")
                .classList.remove("visible");
            });

          // 在 init() 的事件监听器区域添加
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // ...你已有的其他点击事件逻辑...

              // 新增逻辑：处理分享卡片的点击
              const shareCard = e.target.closest(
                ".link-share-card[data-timestamp]"
              );
              if (
                shareCard &&
                shareCard.closest(".message-bubble.is-link-share")
              ) {
                const timestamp = parseInt(shareCard.dataset.timestamp);
                openSharedHistoryViewer(timestamp);
              }
            });

          // 绑定查看器的关闭按钮
          document
            .getElementById("close-shared-history-viewer-btn")
            .addEventListener("click", () => {
              document
                .getElementById("shared-history-viewer-modal")
                .classList.remove("visible");
            });

          // 创建新函数来处理渲染逻辑
          function openSharedHistoryViewer(timestamp) {
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find((m) => m.timestamp === timestamp);
            if (!message || message.type !== "share_card") return;

            const viewerModal = document.getElementById(
              "shared-history-viewer-modal"
            );
            const viewerTitle = document.getElementById(
              "shared-history-viewer-title"
            );
            const viewerContent = document.getElementById(
              "shared-history-viewer-content"
            );

            viewerTitle.textContent = message.payload.title;
            viewerContent.innerHTML = ""; // 清空旧内容

            // 【核心】复用 createMessageElement 来渲染每一条被分享的消息
            message.payload.sharedHistory.forEach((sharedMsg) => {
              // 注意：这里我们传入的是 sourceChat 对象，以确保头像、昵称等正确
              const sourceChat =
                Object.values(state.chats).find(
                  (c) => c.name === message.payload.sourceChatName
                ) || chat;
              const bubbleEl = createMessageElement(sharedMsg, sourceChat);
              if (bubbleEl) {
                viewerContent.appendChild(bubbleEl);
              }
            });

            viewerModal.classList.add("visible");
          }

          audioPlayer.addEventListener("timeupdate", updateMusicProgressBar);

          audioPlayer.addEventListener("pause", () => {
            if (musicState.isActive) {
              musicState.isPlaying = false;
              updatePlayerUI();
            }
          });
          audioPlayer.addEventListener("play", () => {
            if (musicState.isActive) {
              musicState.isPlaying = true;
              updatePlayerUI();
            }
          });

          document
            .getElementById("playlist-body")
            .addEventListener("click", async (e) => {
              const target = e.target;
              if (target.classList.contains("delete-track-btn")) {
                const index = parseInt(target.dataset.index);
                const track = musicState.playlist[index];
                const confirmed = await showCustomConfirm(
                  "删除歌曲",
                  `确定要从播放列表中删除《${track.name}》吗？`
                );
                if (confirmed) {
                  deleteTrack(index);
                }
                return;
              }
              if (target.classList.contains("lyrics-btn")) {
                const index = parseInt(target.dataset.index);
                if (isNaN(index)) return;
                const lrcContent = await new Promise((resolve) => {
                  const lrcInput = document.getElementById("lrc-upload-input");
                  const handler = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                      const reader = new FileReader();
                      reader.onload = (re) => resolve(re.target.result);
                      reader.readAsText(file);
                    } else {
                      resolve(null);
                    }
                    lrcInput.removeEventListener("change", handler);
                    lrcInput.value = "";
                  };
                  lrcInput.addEventListener("change", handler);
                  lrcInput.click();
                });
                if (lrcContent !== null) {
                  musicState.playlist[index].lrcContent = lrcContent;
                  await saveGlobalPlaylist();
                  alert("歌词导入成功！");
                  if (musicState.currentIndex === index) {
                    musicState.parsedLyrics = parseLRC(lrcContent);
                    renderLyrics();
                  }
                }
              }
            });

          document
            .querySelector(".progress-bar")
            .addEventListener("click", (e) => {
              if (!audioPlayer.duration) return;
              const progressBar = e.currentTarget;
              const barWidth = progressBar.clientWidth;
              const clickX = e.offsetX;
              audioPlayer.currentTime =
                (clickX / barWidth) * audioPlayer.duration;
            });

          // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这段新代码 ▼▼▼

          // 使用事件委托来处理所有“已撤回消息”的点击事件
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 检查被点击的元素或其父元素是否是“已撤回”提示
              const placeholder = e.target.closest(
                ".recalled-message-placeholder"
              );
              if (!placeholder) return; // 如果不是，就退出

              // 如果是，就从聊天记录中找到对应的数据并显示
              const chat = state.chats[state.activeChatId];
              const wrapper = placeholder.closest(".message-wrapper"); // 找到它的父容器
              if (chat && wrapper) {
                // 从父容器上找到时间戳
                const timestamp = parseInt(wrapper.dataset.timestamp);
                const recalledMsg = chat.history.find(
                  (m) => m.timestamp === timestamp
                );

                if (recalledMsg && recalledMsg.recalledData) {
                  let originalContentText = "";
                  const recalled = recalledMsg.recalledData;

                  if (recalled.originalType === "text") {
                    originalContentText = `原文: "${recalled.originalContent}"`;
                  } else {
                    originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
                  }
                  showCustomAlert("已撤回的消息", originalContentText);
                }
              }
            });

          // ▲▲▲ 新代码粘贴结束 ▲▲▲

          // ▼▼▼ 在 init() 的事件监听器区域，粘贴这段新代码 ▼▼▼
          document
            .getElementById("manage-world-book-categories-btn")
            .addEventListener("click", openCategoryManager);
          document
            .getElementById("close-category-manager-btn")
            .addEventListener("click", () => {
              document
                .getElementById("world-book-category-manager-modal")
                .classList.remove("visible");
              renderWorldBookScreen(); // 关闭后刷新主列表
            });
          document
            .getElementById("add-new-category-btn")
            .addEventListener("click", addNewCategory);
          document
            .getElementById("existing-categories-list")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("delete-group-btn")) {
                const categoryId = parseInt(e.target.dataset.id);
                deleteCategory(categoryId);
              }
            });
          // ▲▲▲ 新代码粘贴结束 ▲▲▲

          // ▼▼▼ API配置管理相关逻辑 ▼▼▼
          const manageApiPresetsBtn = document.getElementById('manage-api-presets-btn');
          const apiPresetsModal = document.getElementById('api-presets-modal');
          const apiPresetsList = document.getElementById('api-presets-list');
          const savePresetNameInput = document.getElementById('save-preset-name-input');
          const savePresetBtn = document.getElementById('save-preset-btn');
          const closeApiPresetsModalBtn = document.getElementById('close-api-presets-modal-btn');

          if (manageApiPresetsBtn) {
              manageApiPresetsBtn.addEventListener('click', () => {
                  renderApiPresetsList();
                  apiPresetsModal.classList.add('visible');
              });
          }

          if (closeApiPresetsModalBtn) {
              closeApiPresetsModalBtn.addEventListener('click', () => {
                  apiPresetsModal.classList.remove('visible');
              });
          }

          if (savePresetBtn) {
              savePresetBtn.addEventListener('click', async () => {
                  const name = savePresetNameInput.value.trim();
                  if (!name) return alert('请输入配置名称');

                  const newPreset = {
                      name,
                      proxyUrl: document.getElementById('proxy-url').value.trim(),
                      apiKey: document.getElementById('api-key').value.trim(),
                      model: document.getElementById('model-select').value,
                      enableStreaming: document.getElementById('stream-request-switch').checked
                  };

                  if (!state.globalSettings.apiPresets) {
                      state.globalSettings.apiPresets = [];
                  }

                  // Check for duplicate name and overwrite
                  const existingIndex = state.globalSettings.apiPresets.findIndex(p => p.name === name);
                  if (existingIndex > -1) {
                      if(!confirm(`配置 "${name}" 已存在，是否覆盖？`)) return;
                      state.globalSettings.apiPresets[existingIndex] = newPreset;
                  } else {
                      state.globalSettings.apiPresets.push(newPreset);
                  }

                  await db.globalSettings.put(state.globalSettings);
                  renderApiPresetsList();
                  savePresetNameInput.value = '';
                  alert('配置已保存');
              });
          }

          function renderApiPresetsList() {
              apiPresetsList.innerHTML = '';
              const presets = state.globalSettings.apiPresets || [];
              if (presets.length === 0) {
                  apiPresetsList.innerHTML = '<div style="text-align:center; color:#999; padding:20px;">暂无保存的配置</div>';
                  return;
              }

              presets.forEach((preset, index) => {
                  const item = document.createElement('div');
                  item.style.cssText = 'display:flex; justify-content:space-between; align-items:center; padding:10px; border-bottom:1px solid #eee;';
                  
                  const info = document.createElement('div');
                  info.innerHTML = `<strong>${preset.name}</strong><br><span style="font-size:12px; color:#666;">${preset.model} | ${preset.proxyUrl ? 'Proxy' : 'Direct'}</span>`;
                  
                  const actions = document.createElement('div');
                  actions.style.display = 'flex';
                  actions.style.gap = '5px';

                  const loadBtn = document.createElement('button');
                  loadBtn.textContent = '加载';
                  loadBtn.className = 'form-button';
                  loadBtn.style.cssText = 'padding:5px 10px; font-size:12px; width:auto;';
                  loadBtn.onclick = () => loadApiPreset(preset);

                  const deleteBtn = document.createElement('button');
                  deleteBtn.textContent = '删除';
                  deleteBtn.className = 'form-button'; 
                  deleteBtn.style.cssText = 'padding:5px 10px; font-size:12px; width:auto; background-color:#ff3b30;';
                  deleteBtn.onclick = () => deleteApiPreset(index);

                  actions.appendChild(loadBtn);
                  actions.appendChild(deleteBtn);
                  item.appendChild(info);
                  item.appendChild(actions);
                  apiPresetsList.appendChild(item);
              });
          }

          function loadApiPreset(preset) {
              document.getElementById('proxy-url').value = preset.proxyUrl || '';
              document.getElementById('api-key').value = preset.apiKey || '';
              document.getElementById('stream-request-switch').checked = preset.enableStreaming || false;
              
              const modelSelect = document.getElementById('model-select');
              if (preset.model) {
                   let optionExists = false;
                   for (let i = 0; i < modelSelect.options.length; i++) {
                       if (modelSelect.options[i].value === preset.model) {
                           optionExists = true;
                           break;
                       }
                   }
                   if (!optionExists) {
                       const opt = document.createElement('option');
                       opt.value = preset.model;
                       opt.textContent = preset.model + " (来自配置)";
                       modelSelect.appendChild(opt);
                   }
                   modelSelect.value = preset.model;
              }

              apiPresetsModal.classList.remove('visible');
              alert(`已加载配置 "${preset.name}"，请点击“保存设置”以应用。`);
          }

          async function deleteApiPreset(index) {
              if (!confirm('确定删除此配置吗？')) return;
              state.globalSettings.apiPresets.splice(index, 1);
              await db.globalSettings.put(state.globalSettings);
              renderApiPresetsList();
          }
          // ▲▲▲ API配置管理相关逻辑结束 ▲▲▲

          // ===================================================================
          // 5. 启动！

          showScreen("home-screen");
        }

        init();
      });
    </script>
  </body>
</html>
