<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <script>
      // === 关键样式预加载器（阻止 FOUC）===
      (function() {
        // 1. 同步应用主题到所有必要元素
        const theme = localStorage.getItem('ephone-theme');
        const isDark = theme === 'dark';
        
        if (isDark) {
          // 添加到 html, body (phoneScreen 在 DOMContentLoaded 后才存在，通过 CSS 处理)
          document.documentElement.classList.add('dark-mode');
          // body 可能还不存在，使用 DOMContentLoaded 前的技巧
          const style = document.createElement('style');
          style.textContent = 'body { background-color: #121212; }';
          document.head.appendChild(style);
        }
        
        // 2. 同步应用布局尺寸
        try {
          const cache = localStorage.getItem('ephone-layout-cache');
          if (cache) {
            const layout = JSON.parse(cache);
            const style = document.documentElement.style;
            if (layout.screenWidth) style.setProperty('--screen-width', layout.screenWidth + 'px');
            if (layout.screenHeight) style.setProperty('--screen-height', layout.screenHeight + 'px');
            if (layout.phoneOffset !== undefined) style.setProperty('--phone-offset', layout.phoneOffset + 'px');
          }
        } catch (e) {
          console.warn('Layout cache parse error:', e);
        }

        // 3. 预加载面板可见性（避免闪烁）
        try {
          const settings = localStorage.getItem('ephone-panel-visibility');
          if (settings) {
            const config = JSON.parse(settings);
            if (config.showPhoneSizePanel === false) {
              // 通过 CSS 隐藏面板
              const style = document.createElement('style');
              style.id = 'preload-panel-hidden';
              style.textContent = '#phone-size-control-panel { display: none !important; }';
              document.head.appendChild(style);
            }
          }
        } catch (e) {
          console.warn('Panel visibility cache parse error:', e);
        }
      })();
    </script>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta name="apple-mobile-web-app-title" content="EPhone" />
    <meta name="theme-color" content="#000000" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link
      rel="apple-touch-icon"
      href="https://i.postimg.cc/CMZqNMRh/IMG-6497.jpg"
    />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <link rel="manifest" href="./manifest.json" />
    <script>
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker
          .register("./sw.js")
          .then(() => console.log("SW Registered"))
          .catch((e) => console.error("SW Error:", e));
      }
    </script>

    <title>EPhone</title>
    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
      <style>
        @font-face {
          font-family: "bulangni";
          src: url("") format("truetype");
          font-weight: normal;
          font-style: normal;
          font-display: swap;
        }
        /*
         * 手机尺寸调整指南 (Phone Size Adjustment Guide):
         *
         * 调整屏幕大小:
         *   --screen-width: 控制手机屏幕宽度 (默认: 365px，建议范围: 320px-400px)
         *   --screen-height: 控制手机屏幕高度 (默认: 680px，建议范围: 600px-750px)
         *
       * 调整手机位置:
       *   --phone-offset: 控制手机垂直偏移量 (默认: 15px，正值向下，负值向上)
       *
       * 注意: #phone-frame 的 padding: 12px 控制边框厚度
       */
      :root {
        --screen-width: 365px;
        --screen-height: 680px;
        --secondary-bg: #ffffff;
        --border-color: #e0e0e0;
        --text-primary: #1f1f1f;
        --text-secondary: #8a8a8a;
        --accent-color: #007bff;
        --phone-offset: 15px;
        --phone-offset-x: 0;
        --phone-offset-y: var(--phone-offset, 0);
      }
      html {
        height: 100%;
        overflow: hidden;
        background-color: #dcdcdc;
      }
      body {
        height: 100%;
        overflow: hidden;
        margin: 0;
        padding:
          max(20px, env(safe-area-inset-top))
          max(20px, env(safe-area-inset-right))
          max(20px, env(safe-area-inset-bottom))
          max(20px, env(safe-area-inset-left));
        font-family:
          "bulangni",
          -apple-system,
          BlinkMacSystemFont,
          "Segoe UI",
          Roboto,
          Helvetica,
          Arial,
          sans-serif;
        font-weight: normal;
        background-color: #dcdcdc;
        display: flex;
        justify-content: center;
        align-items: center;
        box-sizing: border-box;
        transition: background-color 0.3s ease;
      }
      :root.dark-mode {
        --secondary-bg: #101010;
        --border-color: rgba(255, 255, 255, 0.18);
        --text-primary: #f5f5f5;
        --text-secondary: #b3b3b3;
        --accent-color: #57a9ff;
      }

      html.dark-mode {
        background-color: #121212;
      }

      body.dark-mode {
        background-color: #121212;
      }
      /* 确保 #phone-screen 继承深色模式 */
      :root.dark-mode #phone-screen,
      html.dark-mode #phone-screen,
      body.dark-mode #phone-screen {
        background-color: #000;
      }
      #phone-size-control-panel {
        background: rgba(255, 255, 255, 0.95);
      }

      html.dark-mode {
        background-color: #121212;
      }

      body.dark-mode #phone-size-control-panel {
        background: rgba(20, 20, 20, 0.95);
        border-radius: 12px;
        border: 1px solid var(--border-color);
        color: var(--text-primary);
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.65);
      }

      body.dark-mode #phone-size-control-panel h3 {
        color: var(--text-primary);
      }

      body.dark-mode #phone-size-control-panel #size-panel-content label {
        color: var(--text-secondary);
      }

      body.dark-mode #phone-size-control-panel #size-panel-content span {
        color: var(--accent-color);
      }

      body.dark-mode #phone-size-control-panel input {
        background-color: var(--secondary-bg);
        border-color: var(--border-color);
        color: var(--text-primary);
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.6);
      }

      body.dark-mode #phone-size-control-panel button#reset-phone-size-btn {
        background: var(--border-color);
        color: var(--text-primary);
        border-color: rgba(255, 255, 255, 0.25);
      }

      body.dark-mode #phone-size-control-panel button#toggle-size-panel-btn {
        color: var(--text-secondary);
      }
      /* 
       * Phone vertical offset adjustment:
       * To move phone UP: decrease --phone-offset (e.g., 0px, -10px)
       * To move phone DOWN: increase --phone-offset (e.g., 30px, 50px)
       * Adjust in :root { --phone-offset: XXpx; }
       */
      #phone-frame {
        margin-top: var(--phone-offset, 0);
        padding: 12px;
        background-color: #fff;
        border-radius: 50px;
        box-shadow:
          0 20px 50px rgba(0, 0, 0, 0.25),
          inset 0 2px 4px rgba(0, 0, 0, 0.1);
        position: relative;
        transition: background-color 0.3s ease;
      }
      body.dark-mode #phone-frame {
        background-color: #2a2a2a;
        box-shadow:
          0 0 25px rgba(220, 235, 255, 0.18),
          0 0 200px rgba(220, 235, 255, 0.06),
          0 0 260px rgba(220, 235, 255, 0.04),
          0 0 0 1px rgba(255, 255, 255, 0.1),
          0 40px 80px rgba(0, 0, 0, 0.95),
          inset 0 1px 2px rgba(255, 255, 255, 0.2);
      }
      .notch {
        position: absolute;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        width: 130px;
        height: 28px;
        background-color: #1f1f1f;
        border-radius: 0 0 15px 15px;
        z-index: 20;
      }
      #phone-screen {
        width: var(--screen-width);
        height: var(--screen-height);
        background-color: #000;
        border-radius: 40px;
        position: relative;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        border: 2px solid #333;
      }
      #status-bar {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        padding: 12px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: white;
        z-index: 10;
        font-size: 14px;
        box-sizing: border-box;
        pointer-events: none;
      }
      #status-bar-time {
        font-weight: 600;
      }
      .battery-container {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .battery-icon {
        width: 25px;
        height: 12px;
        border: 1px solid white;
        border-radius: 3px;
        position: relative;
        padding: 1px;
      }
      .battery-icon::after {
        content: "";
        position: absolute;
        right: -3px;
        top: 2px;
        width: 2px;
        height: 6px;
        background-color: white;
        border-radius: 0 1px 1px 0;
      }
      .battery-level {
        height: 100%;
        background-color: white;
        border-radius: 1px;
        transition: width 0.5s ease;
      }
      .battery-container.charging .battery-level {
        background-color: #4cd964;
        animation: charge-breath 2s infinite;
      }
      .battery-container.charging .battery-text {
        color: #4cd964;
      }
      @keyframes charge-breath {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }
      .screen {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        opacity: 0;
        visibility: hidden;
        transition:
          opacity 0.3s,
          visibility 0.3s;
      }
      .screen.active {
        opacity: 1;
        visibility: visible;
        z-index: 1;
      }
      .header {
        position: relative;
        z-index: 15;
        flex-shrink: 0;
        padding: 15px 20px;
        padding-top: 45px;
        background-color: rgba(247, 247, 247, 0.8);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 18px;
        font-weight: 600;
      }
      .header .header-actions {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      .header .back-btn,
      .header .action-btn {
        font-size: 24px;
        cursor: pointer;
        width: 30px;
        text-align: center;
        color: var(--accent-color);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .header .action-btn {
        width: auto;
        min-width: 30px;
        white-space: nowrap;
        font-size: 16px;
        font-weight: 600;
      }
      .header .action-btn img {
        height: 26px;
      }
      .header .save-btn {
        font-size: 16px;
        color: var(--accent-color);
        font-weight: 600;
        cursor: pointer;
      }
      #home-screen {
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        padding: 20px;
        padding-top: 80px;
        padding-bottom: 50px;
        box-sizing: border-box;
        background-size: cover;
        background-position: center;
      }
      #clock-container {
        text-align: center;
        color: white;
        text-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
        margin-bottom: 20px;
        flex-shrink: 0;
      }
      #main-time {
        font-size: 80px;
        font-weight: 200;
      }
      #main-date {
        font-size: 18px;
        font-weight: 500;
      }
      #app-grid {
        margin-top: auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        width: 100%;
        padding: 20px;
      }
      .app-row {
        display: flex;
        justify-content: center;
        gap: 25px;
        width: 100%;
      }
      .app-icon {
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
        color: white;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        font-size: 14px;
        font-weight: 500;
        text-align: center;
      }
      .app-icon .icon-bg {
        width: 65px;
        height: 65px;
        border-radius: 18px;
        background-color: var(--secondary-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 32px;
        margin-bottom: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        transition: transform 0.2s ease;
        overflow: hidden;
      }
      .app-icon:active .icon-bg {
        transform: scale(0.9);
      }
      .app-icon .icon-bg img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .app-icon .label {
        color: white;
      }
      .form-container,
      .list-container {
        padding: 20px;
        overflow-y: auto;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
      }
      .form-group {
        margin-bottom: 20px;
      }
      .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
        color: var(--text-secondary);
      }
      .form-group input,
      .form-group select,
      .form-group textarea {
        width: 100%;
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-size: 16px;
        box-sizing: border-box;
      }
      .form-group textarea {
        min-height: 80px;
        resize: vertical;
      }
      .settings-group {
        background-color: #fff;
        border-radius: 12px;
        margin-bottom: 20px;
        overflow: hidden;
        border: 1px solid var(--border-color);
      }
      body.dark-mode .settings-group {
        background-color: #1c1c1e;
        border-color: #38383a;
      }
      .settings-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        border-bottom: 1px solid var(--border-color);
        background-color: transparent;
      }
      body.dark-mode .settings-item {
        border-bottom-color: #38383a;
      }
      .settings-item:last-child {
        border-bottom: none;
      }
      .settings-item .label {
        font-size: 16px;
        color: var(--text-primary);
        flex-grow: 1;
      }
      body.dark-mode .settings-item .label {
        color: #fff;
      }
      /* Toggle Switch */
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 51px;
        height: 31px;
        flex-shrink: 0;
        margin-top: 10px;
        margin-right: 10px;
      }
      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #e9e9eb;
        transition: 0.3s;
        border-radius: 31px;
      }
      body.dark-mode .toggle-slider {
        background-color: #39393d;
      }
      .toggle-slider:before {
        position: absolute;
        content: "";
        height: 27px;
        width: 27px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: 0.3s;
        border-radius: 50%;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
      }
      .toggle-switch input:checked + .toggle-slider {
        background-color: #34c759;
      }
      .toggle-switch input:checked + .toggle-slider:before {
        transform: translateX(20px);
      }
      .role-activity-item {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 12px 16px;
        border-bottom: 1px solid var(--border-color);
      }
      .role-activity-item:last-child {
        border-bottom: none;
      }
      .role-activity-item .role-name {
        font-size: 15px;
        font-weight: 600;
        color: var(--text-primary);
      }
      body.dark-mode .role-activity-item .role-name {
        color: #fff;
      }
      .role-activity-options {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
      }
      .role-activity-option {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        color: var(--text-secondary);
      }
      body.dark-mode .role-activity-option {
        color: #b5b5b5;
      }
      .moe-input {
        background-color: #f2f2f7;
        border: none;
        border-radius: 8px;
        padding: 10px 12px;
        font-size: 15px;
        color: var(--text-primary);
        width: 100%;
        box-sizing: border-box;
      }
      body.dark-mode .moe-input {
        background-color: #2c2c2e;
        color: #fff;
      }
      #world-book-content-input {
        height: calc(100% - 120px);
      }
      .form-button {
        width: 100%;
        padding: 15px;
        background-color: var(--accent-color);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        margin-top: 10px;
      }
      .form-button-secondary {
        background-color: #f0f0f0;
        color: var(--text-primary);
        border: 1px solid var(--border-color);
      }
      #wallpaper-upload-input {
        display: none;
      }
      #world-book-list {
        flex-grow: 1;
        overflow-y: auto;
        background-color: var(--secondary-bg);
        padding-top: 80px;
        margin-top: -80px;
      }
      #chat-list {
        flex-grow: 1;
        background-color: var(--secondary-bg);
        padding-top: 80px;
        padding-bottom: 50px;
        box-sizing: border-box;
      }
      .list-item {
        display: flex;
        flex-direction: column;
        padding: 12px 20px;
        cursor: pointer;
        border-bottom: 1px solid var(--border-color);
      }
      .list-item:hover {
        background-color: #f5f5f5;
      }
      .list-item .item-title {
        font-weight: 500;
        font-size: 16px;
        margin-bottom: 5px;
      }
      .list-item .item-content {
        font-size: 14px;
        color: var(--text-secondary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .chat-list-item {
        display: flex;
        align-items: center;
        padding: 10px 15px;
        cursor: pointer;
        border-bottom: 1px solid var(--border-color);
        position: relative;
      }
      .chat-list-item:hover {
        background-color: #f5f5f5;
      }
      .chat-list-item .avatar {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        margin-right: 12px;
        object-fit: cover;
        background-color: #ccc;
      }
      .chat-list-item .info {
        flex-grow: 1;
        overflow: hidden;
      }
      .chat-list-item .name-line {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 2px;
      }
      .chat-list-item .name {
        font-weight: 500;
        color: var(--text-primary);
      }
      .chat-list-item .group-tag {
        font-size: 10px;
        color: var(--accent-color);
        background-color: #e7f3ff;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: bold;
        flex-shrink: 0;
      }
      .chat-list-item .last-msg {
        font-size: 13px;
        color: var(--text-secondary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 180px;
      }
      #chat-interface-screen {
        background-size: cover;
        background-position: center;
        position: relative;
      }
      #selection-cancel-btn,
      #selection-delete-btn {
        font-size: 16px;
        color: var(--accent-color);
        cursor: pointer;
        padding: 5px;
      }
      #selection-delete-btn {
        color: #ff3b30;
      }
      #chat-messages {
        flex-grow: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 10px 15px;
        padding-top: 110px;
        margin-top: -80px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        box-sizing: border-box;
      }
      #load-more-btn {
        text-align: center;
        padding: 10px;
        color: var(--accent-color);
        font-size: 14px;
        cursor: pointer;
        background-color: transparent;
        border: none;
        width: 100%;
      }
      #load-more-btn:hover {
        text-decoration: underline;
      }
      .sender-name {
        font-size: 11px;
        color: #666;
        margin-bottom: 3px;
      }
      .message-wrapper.ai .sender-name {
        margin-left: 50px;
        margin-bottom: 3px;
        position: absolute;
        top: -16px;
        left: 0;
      }
      .message-wrapper {
        scroll-margin-top: 140px;
        display: flex;
        gap: 8px;
        align-items: flex-end;
        position: relative;
        max-width: 90%;
      }
      .message-wrapper.ai {
        align-self: flex-start;
        flex-direction: row;
      }
      .message-wrapper.user {
        align-self: flex-end;
        flex-direction: row-reverse;
      }
      .message-bubble {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        max-width: 100%;
      }
      .timestamp {
        font-size: 11px;
        color: #999;
        text-shadow: 0 0 3px rgba(255, 255, 255, 0.6);
        white-space: nowrap;
        margin-bottom: 5px;
        flex-shrink: 0;
      }
      .message-bubble.selected::after {
        content: "✔";
        position: absolute;
        left: -10px;
        top: 50%;
        transform: translateY(-50%);
        background-color: var(--accent-color);
        color: white;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
      }
      .message-bubble.user.selected::after {
        left: auto;
        right: -10px;
      }
      .message-bubble.user {
        flex-direction: row-reverse;
      }
      #chat-input-area {
        flex-shrink: 0;
        padding: 8px;
        background-color: rgba(247, 247, 247, 0.8);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-top: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      #chat-input-main-row {
        display: flex;
        align-items: flex-end;
        gap: 8px;
        width: 100%;
      }
      #chat-input {
        flex-grow: 1;
        border: none;
        padding: 10px 15px;
        border-radius: 20px;
        background-color: var(--secondary-bg);
        font-size: 16px;
        max-height: 100px;
        resize: none;
      }
      .action-button {
        border: none;
        color: white;
        border-radius: 20px;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
        flex-shrink: 0;
      }
      #send-btn {
        background-color: var(--accent-color);
        height: 40px;
        padding: 0 15px;
      }
      .modal {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 100;
        transform: translate(var(--phone-offset-x, 0), var(--phone-offset-y, 0));
      }
      .modal.visible {
        display: flex;
      }
      .modal-content {
        width: 90%;
        max-height: 90%;
        background-color: white;
        border-radius: 15px;
        display: flex;
        flex-direction: column;
      }
      .modal-header {
        padding: 15px;
        font-weight: 600;
        border-bottom: 1px solid var(--border-color);
        text-align: center;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-radius: 15px 15px 0 0;
      }
      .modal-body {
        padding: 15px;
        overflow-y: auto;
      }
      .modal-footer {
        padding: 15px;
        border-top: 1px solid var(--border-color);
        display: flex;
        justify-content: space-around;
      }
      .modal-footer button {
        width: 45%;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid var(--accent-color);
        cursor: pointer;
        font-size: 16px;
      }
      .modal-footer .save {
        background-color: var(--accent-color);
        color: white;
      }
      .modal-footer .cancel {
        background-color: white;
        color: var(--accent-color);
      }
      .avatar-upload {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      .avatar-upload img {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        object-fit: cover;
        background-color: #eee;
      }
      .avatar-upload button {
        padding: 8px 12px;
        border: 1px solid #ccc;
        background-color: #f0f0f0;
        border-radius: 5px;
        cursor: pointer;
      }
      #open-persona-library-btn {
        font-size: 14px;
        padding: 6px 10px;
        margin-left: 0;
      }
      .avatar-upload input[type="file"] {
        display: none;
      }
      .theme-selector label {
        display: inline-flex;
        align-items: center;
        margin-right: 15px;
        margin-bottom: 5px;
        cursor: pointer;
      }
      #reset-theme-btn {
        background: none;
        border: 1px solid #ccc;
        color: #555;
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 5px;
        cursor: pointer;
        margin-left: 10px;
      }
      #group-members-settings {
        display: flex;
        overflow-x: auto;
        padding-bottom: 10px;
        gap: 15px;
      }
      .member-editor {
        text-align: center;
        cursor: pointer;
      }
      .member-editor img {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        object-fit: cover;
        background-color: #eee;
        margin-bottom: 5px;
      }
      .member-editor .member-name {
        font-size: 12px;
      }
      #notification-bar {
        position: absolute;
        top: 40px;
        left: 50%;
        width: 90%;
        z-index: 500;
        background-color: rgba(250, 250, 250, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-radius: 16px;
        padding: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
        transform: translateX(-50%) translateY(-150%);
        transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        visibility: hidden;
      }
      #notification-bar.visible {
        transform: translateX(-50%) translateY(0);
        visibility: visible;
      }
      #notification-avatar {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        object-fit: cover;
      }
      #notification-content .name {
        font-weight: 600;
        font-size: 15px;
        color: #000;
      }
      #notification-content .message {
        font-size: 14px;
        color: #555;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 200px;
      }
      .sticker-image {
        max-width: 100px;
        max-height: 100px;
        display: block;
        object-fit: contain;
      }
      .message-bubble.is-sticker .content,
      .message-bubble.is-link-share .content,
      .message-bubble.is-voice-message .content {
        padding: 0;
        background-color: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }
      .chat-action-icon-btn {
        font-size: 24px;
        padding: 0;
        width: 38px;
        height: 38px;
        line-height: 38px;
        text-align: center;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.5);
        color: var(--text-primary);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        border: 1px solid rgba(0, 0, 0, 0.05);
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      #sticker-panel {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 50%;
        background-color: rgba(242, 242, 247, 0.85);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-top: 1px solid var(--border-color);
        border-radius: 20px 20px 0 0;
        z-index: 200;
        display: flex;
        flex-direction: column;
        transform: translateY(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        visibility: hidden;
      }
      #sticker-panel.visible {
        transform: translateY(0);
        visibility: visible;
      }
      #sticker-panel-header {
        padding: 10px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        border-bottom: 1px solid var(--border-color);
      }
      #sticker-panel-header .title {
        font-weight: 600;
      }
      #sticker-panel-header .panel-btn {
        font-size: 16px;
        padding: 5px 10px;
        cursor: pointer;
        color: var(--accent-color);
      }
      #sticker-grid {
        flex-grow: 1;
        overflow-y: auto;
        padding: 15px;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 15px;
      }
      .sticker-item {
        position: relative;
        aspect-ratio: 1 / 1;
        background-color: white;
        border-radius: 10px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }
      .sticker-item .delete-btn {
        display: none;
        position: absolute;
        top: -5px;
        right: -5px;
        width: 20px;
        height: 20px;
        background-color: #ff3b30;
        color: white;
        border-radius: 50%;
        text-align: center;
        line-height: 20px;
        font-size: 14px;
        cursor: pointer;
        border: 2px solid white;
      }
      #input-actions-wrapper {
        position: static;
        display: flex;
        align-items: flex-end;
        gap: 8px;
        flex-shrink: 0;
      }
      #wait-reply-btn {
        position: static;
        bottom: auto;
        right: auto;
        width: auto;
        height: 40px;
        padding: 0 10px;
        border-radius: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(255, 255, 255, 0.6);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        border: 1px solid rgba(0, 0, 0, 0.08);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        transition:
          opacity 0.2s,
          transform 0.1s;
        cursor: pointer;
      }
      #wait-reply-btn:hover {
        opacity: 0.8;
      }
      #wait-reply-btn:active {
        transform: scale(0.9);
      }
      #wait-reply-btn img {
        height: 22px;
        display: block;
        margin: auto;
      }
      .chat-image {
        max-width: 100%;
        border-radius: 10px;
        display: block;
      }
      .message-bubble.has-image .content {
        padding: 5px;
      }
      #custom-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
        transform: translate(var(--phone-offset-x, 0), var(--phone-offset-y, 0));
      }
      #custom-modal-overlay.visible {
        display: flex;
        opacity: 1;
      }
      #custom-modal {
        background-color: #fff;
        width: 280px;
        border-radius: 14px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        transform: scale(0.95);
        transition: transform 0.2s ease-in-out;
      }
      #custom-modal-overlay.visible #custom-modal {
        transform: scale(1);
      }
      .custom-modal-header {
        padding: 16px;
        font-size: 17px;
        font-weight: 600;
        text-align: center;
      }
      .custom-modal-body {
        padding: 5px 5px 5px;
        text-align: center;
        font-size: 14px;
        color: #333;
        line-height: 1.5;
      }
      .custom-modal-body p {
        margin: 0;
        margin-bottom: 12px;
      }
      .custom-modal-body input {
        width: 100%;
        padding: 8px;
        border-radius: 6px;
        border: 1px solid #ccc;
        font-size: 14px;
        box-sizing: border-box;
      }
      .custom-modal-footer {
        border-top: 1px solid #dbdbdb;
        display: flex;
      }
      .custom-modal-footer button {
        flex: 1;
        background: none;
        border: none;
        padding: 12px;
        font-size: 17px;
        cursor: pointer;
        color: var(--accent-color);
      }
      .custom-modal-footer button:first-child {
        border-right: 1px solid #dbdbdb;
      }
      .custom-modal-footer .confirm-btn {
        font-weight: 600;
      }
      .custom-modal-footer .confirm-btn.btn-danger {
        color: #ff3b30;
      }
      #preset-actions-modal .custom-modal-footer {
        flex-direction: column;
      }
      #preset-actions-modal .custom-modal-footer button {
        width: 100%;
        border: none;
        border-bottom: 1px solid #dbdbdb;
        padding: 14px;
        font-size: 18px;
      }
      #preset-actions-modal .custom-modal-footer button:last-child {
        border-bottom: none;
      }
      #message-actions-modal .custom-modal-footer {
        flex-direction: column;
      }
      #message-actions-modal .custom-modal-footer button {
        width: 100%;
        border: none;
        border-bottom: 1px solid #dbdbdb;
        padding: 14px;
        font-size: 18px;
      }
      #message-actions-modal .custom-modal-footer button:last-child {
        border-bottom: none;
      }
      .custom-multiselect {
        position: relative;
        user-select: none;
      }
      .select-box {
        display: flex;
        align-items: center;
        width: 100%;
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-size: 16px;
        box-sizing: border-box;
        background-color: #fff;
        cursor: pointer;
      }
      .select-box .selected-options-text {
        flex-grow: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: var(--text-primary);
      }
      .select-box .arrow-down {
        margin-left: auto;
        font-size: 10px;
        color: var(--text-secondary);
        transition: transform 0.2s;
      }
      .select-box.expanded .arrow-down {
        transform: rotate(180deg);
      }
      .checkboxes-container {
        display: none;
        position: absolute;
        top: 100%;
        margin-top: 5px;
        left: 0;
        right: 0;
        max-height: 150px;
        overflow-y: auto;
        overflow-x: hidden;
        background-color: #fff;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        z-index: 101;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }
      .checkboxes-container.visible {
        display: block;
      }
      .checkboxes-container label {
        display: block;
        padding: 12px 15px;
        cursor: pointer;
        font-weight: normal;
        color: var(--text-primary);
        font-size: 15px;
      }
      .checkboxes-container input {
        margin-right: 10px;
        vertical-align: middle;
      }
      .bg-upload-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 8px;
        flex-wrap: wrap;
      }
      .bg-preview-img {
        max-width: 120px;
        max-height: 80px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        object-fit: cover;
        display: none;
      }
      #remove-bg-btn {
        padding: 8px 12px;
        border: 1px solid #ff3b30;
        color: #ff3b30;
        background-color: #fff;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        display: none;
      }
      .message-bubble.is-ai-image .content {
        padding: 5px;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }
      .ai-generated-image {
        max-width: 180px;
        border-radius: 12px;
        display: block;
        cursor: pointer;
        transition:
          transform 0.2s,
          box-shadow 0.2s;
      }
      .ai-generated-image:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }
      .voice-message-body::after {
        content: "";
        position: absolute;
        top: 12px;
        width: 0;
        height: 0;
        border-style: solid;
      }
      .message-bubble.user .voice-message-body::after {
        right: -6px;
        border-width: 6px 0 6px 8px;
        border-color: transparent transparent transparent #2ba245;
      }
      .message-bubble.ai .voice-message-body::after {
        left: -6px;
        border-width: 6px 8px 6px 0;
        border-color: transparent #ffffff transparent transparent;
      }
      #phone-screen.dark-mode .message-bubble.ai .voice-message-body::after {
        border-color: transparent #2c2c2e transparent transparent;
      }
      .voice-message-body {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        cursor: pointer;
        min-width: 60px;
        height: 22px;
        border-radius: 4px;
        position: relative;
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
        gap: 6px;
        box-sizing: content-box;
      }
      .message-bubble.user .voice-message-body {
        background-color: #2ba245;
        color: #1a3d00;
        margin-left: auto;
        flex-direction: row-reverse;
        padding: 10px 14px 10px 10px;
      }
      .message-bubble.ai .voice-message-body {
        background-color: #ffffff;
        color: var(--text-primary);
        flex-direction: row;
        padding: 10px 10px 10px 14px;
      }
      #phone-screen.dark-mode .message-bubble.ai .voice-message-body {
        background-color: #2c2c2e;
        color: #fff;
      }
      .voice-waveform {
        display: flex;
        align-items: center;
        height: 20px;
        gap: 2px;
        flex-grow: 0;
      }
      .voice-waveform div {
        width: 3px;
        background-color: currentColor;
        border-radius: 2px;
        animation: wave-quiet 1.2s ease-in-out infinite;
      }
      @keyframes wave-quiet {
        0%,
        100% {
          height: 3px;
          opacity: 0.6;
        }
        50% {
          height: 14px;
          opacity: 1;
        }
      }
      .voice-waveform div:nth-child(1) {
        animation-delay: 0s;
      }
      .voice-waveform div:nth-child(2) {
        animation-delay: 0.15s;
      }
      .voice-waveform div:nth-child(3) {
        animation-delay: 0.3s;
      }
      .voice-waveform div:nth-child(4) {
        animation-delay: 0.45s;
      }
      .voice-waveform div:nth-child(5) {
        animation-delay: 0.6s;
      }
      .voice-duration {
        font-size: 14px;
        font-weight: 500;
        color: inherit;
        margin: 0;
      }
      .message-bubble.user .voice-duration {
        color: #3e6224;
      }
      .message-bubble .content {
        position: relative;
        font-size: var(--chat-font-size, 16px);
        padding: 8px 12px;
        line-height: 1.5;
        word-break: normal;
        overflow-wrap: break-word;
        text-wrap: pretty;
        text-align: left;
        width: fit-content;
        min-width: 0;
      }
      .message-bubble.user .content {
        background-color: rgba(255, 255, 255, 0.75);
        color: #585858;
        border-radius: 8px 2px 8px 8px;
      }
      .message-bubble.ai .content {
        background-color: rgba(255, 255, 255, 0.7);
        color: #585858;
        border-radius: 2px 8px 8px 8px;
      }
      .message-bubble::after {
        content: "";
        position: absolute;
        width: 20px;
        height: 20px;
        background-size: contain;
        background-repeat: no-repeat;
        opacity: 1;
        z-index: 1;
      }
      #chat-messages[data-theme="pink_blue"] .message-bubble.user .content {
        background-color: #fff0f6;
        color: #432531;
      }
      #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content {
        background-color: #eff7ff;
        color: #263a4e;
      }
      #chat-messages[data-theme="blue_white"] .message-bubble.user .content {
        background-color: #eff7ff;
        color: #263a4e;
      }
      #chat-messages[data-theme="blue_white"] .message-bubble.ai .content {
        background-color: #f8f9fa;
        color: #383d41;
      }
      #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content {
        background-color: #faf7ff;
        color: #827693;
      }
      #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content {
        background-color: #fffde4;
        color: #5c4033;
      }
      #chat-messages[data-theme="black_white"] .message-bubble.user .content {
        background-color: #343a40;
        color: #f8f9fa;
      }
      #chat-messages[data-theme="black_white"] .message-bubble.ai .content {
        background-color: #f8f9fa;
        color: #343a40;
      }
      #chat-messages[data-theme="yellow_white"] .message-bubble.user .content {
        background-color: #ffeb3b;
        color: #5d4037;
      }
      #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content {
        background-color: #f8f9fa;
        color: #383d41;
      }
      #chat-messages[data-theme="red_black"] .message-bubble.user .content {
        background-color: #c62828;
        color: #ffffff;
      }
      #chat-messages[data-theme="red_black"] .message-bubble.ai .content {
        background-color: #212121;
        color: #ffffff;
      }
      #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content {
        background-color: #a0d2eb;
        color: #153243;
      }
      #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content {
        background-color: #fef9e7;
        color: #5d4037;
      }
      #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content {
        background-color: #fff0f6;
        color: #432531;
      }
      #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content {
        background-color: #fef9e7;
        color: #5d4037;
      }
      #chat-messages[data-theme="pink_purple"] .message-bubble.user .content {
        background-color: #fff0f6;
        color: #a78396;
      }
      #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content {
        background-color: #faf7ff;
        color: #827693;
      }
      #chat-messages[data-theme="gray_white"] .message-bubble.user .content {
        background-color: #e9ecef;
        color: #495057;
      }
      #chat-messages[data-theme="gray_white"] .message-bubble.ai .content {
        background-color: #f8f9fa;
        color: #383d41;
      }
      #chat-messages[data-theme="blue_green"] .message-bubble.user .content {
        background-color: #d1ecf1;
        color: #0c5460;
      }
      #chat-messages[data-theme="blue_green"] .message-bubble.ai .content {
        background-color: #d4edda;
        color: #155724;
      }
      #chat-messages[data-theme="pink_white"] .message-bubble.user .content {
        background-color: #fff0f6;
        color: #a78396;
      }
      #chat-messages[data-theme="pink_white"] .message-bubble.ai .content {
        background-color: #f8f9fa;
        color: #383d41;
      }
      #chat-messages[data-theme="pink_black"] .message-bubble.user .content {
        background-color: #f8bbd0;
        color: #5b2c6f;
      }
      #chat-messages[data-theme="pink_black"] .message-bubble.ai .content {
        background-color: #343a40;
        color: #f8f9fa;
      }
      #chat-messages[data-theme="pink_green"] .message-bubble.user .content {
        background-color: #f8bbd0;
        color: #5b2c6f;
      }
      #chat-messages[data-theme="pink_green"] .message-bubble.ai .content {
        background-color: #c8e6c9;
        color: #1b5e20;
      }
      #chat-messages[data-theme="green_black"] .message-bubble.user .content {
        background-color: #d4edda;
        color: #155724;
      }
      #chat-messages[data-theme="green_black"] .message-bubble.ai .content {
        background-color: #343a40;
        color: #f8f9fa;
      }
      #transfer-btn {
        font-weight: bold;
      }
      #transfer-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1001;
        transform: translate(var(--phone-offset-x, 0), var(--phone-offset-y, 0));
      }
      #transfer-modal.visible {
        display: flex;
      }
      .transfer-content {
        background-color: #fff0f5;
        border-radius: 20px 20px 20px 20px;
        width: 290px;
        padding: 20px;
        box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3);
        text-align: center;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>');
        background-repeat: no-repeat;
        background-position: top right;
        background-size: 80px;
      }
      .transfer-header {
        font-size: 20px;
        font-weight: bold;
        color: #a35c7b;
        margin-bottom: 20px;
      }
      .transfer-input-group {
        margin-bottom: 15px;
        text-align: left;
      }
      .transfer-input-group label {
        display: block;
        font-size: 14px;
        color: #ff85b3;
        margin-bottom: 5px;
        font-weight: 500;
      }
      .transfer-input-group input {
        width: 100%;
        padding: 12px;
        border-radius: 10px;
        border: 2px solid #ffcce0;
        background-color: #fff;
        font-size: 16px;
        box-sizing: border-box;
      }
      .transfer-input-group input:focus {
        border-color: #ff85b3;
        outline: none;
      }
      .transfer-actions {
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }
      .transfer-actions button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 10px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
      }
      .transfer-actions button:active {
        transform: scale(0.95);
      }
      #transfer-cancel-btn {
        background-color: #ffdde9;
        color: #a35c7b;
      }
      #transfer-confirm-btn {
        background-color: #ff85b3;
        color: white;
      }
      .message-bubble.is-transfer .content {
        padding: 0;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        cursor: pointer;
      }
      .transfer-card {
        width: 200px;
        border-radius: 12px;
        padding: 12px;
        color: white;
        position: relative;
        overflow: hidden;
      }
      .transfer-card::before {
        content: "🐾";
        position: absolute;
        right: 10px;
        top: 5px;
        font-size: 30px;
        opacity: 0.2;
        transform: rotate(15deg);
      }
      .message-bubble.user .transfer-card {
        background: radial-gradient(circle at top left, #ffc5d5, #ff85b3);
      }
      .message-bubble.ai .transfer-card {
        background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb);
      }
      .transfer-title {
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 8px;
      }
      .transfer-amount {
        font-size: 28px;
        font-weight: bold;
        margin-bottom: 4px;
      }
      .transfer-note {
        font-size: 13px;
        opacity: 0.9;
        border-top: 1px solid rgba(255, 255, 255, 0.3);
        padding-top: 8px;
        margin-top: 8px;
        word-break: break-all;
      }
      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      #listen-together-btn img.rotating {
        animation: spin 2s linear infinite;
      }
      #listen-together-btn img.paused {
        animation-play-state: paused;
      }
      #music-time-counter {
        font-size: 12px;
        color: #555;
        margin-bottom: 20px;
      }
      #music-player-song-title {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 5px;
        text-align: center;
      }
      #music-player-artist {
        font-size: 14px;
        color: #666;
        margin-bottom: 25px;
      }
      .music-controls button {
        background: none;
        border: none;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        color: #333;
        width: 44px;
        height: 44px;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: transform 0.2s;
      }
      .music-controls button:active {
        transform: scale(0.9);
      }
      .music-controls .play-pause-btn {
        font-size: 24px;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.05);
      }
      .music-bottom-actions {
        display: flex;
        justify-content: space-between;
        width: 100%;
      }
      .music-bottom-actions button {
        flex: 1;
        padding: 12px 0;
        border: none;
        border-radius: 10px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
      }
      #music-playlist-panel {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 70%;
        background-color: rgba(242, 242, 247, 0.9);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-top: 1px solid var(--border-color);
        border-radius: 20px 20px 0 0;
        z-index: 210;
        display: flex;
        flex-direction: column;
        transform: translateY(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        visibility: hidden;
      }
      #music-playlist-panel.visible {
        transform: translateY(0);
        visibility: visible;
      }
      .playlist-header {
        padding: 15px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        border-bottom: 1px solid var(--border-color);
        font-weight: 600;
      }
      .playlist-header .panel-btn {
        font-size: 16px;
        cursor: pointer;
        color: var(--accent-color);
      }
      .playlist-body {
        flex-grow: 1;
        overflow-y: auto;
        padding: 10px 0;
      }
      .playlist-item {
        padding: 10px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        border-bottom: 1px solid #eee;
      }
      .playlist-item.playing {
        background-color: rgba(0, 123, 255, 0.1);
      }
      .playlist-item-info .title {
        font-weight: 500;
        font-size: 15px;
      }
      .playlist-item-info .artist {
        font-size: 12px;
        color: #666;
      }
      .playlist-item .delete-track-btn {
        color: #ff3b30;
        font-size: 20px;
        padding: 5px;
      }
      #persona-library-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
        padding: 10px;
      }
      .persona-preset-item {
        aspect-ratio: 1 / 1;
        border-radius: 12px;
        background-size: cover;
        background-position: center;
        cursor: pointer;
        transition:
          transform 0.2s,
          box-shadow 0.2s;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }
      .persona-preset-item:hover {
        transform: scale(1.08);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      .modal-header .action-button {
        font-size: 16px;
        color: var(--accent-color);
        font-weight: 600;
        cursor: pointer;
        background: none;
        border: none;
        padding: 5px;
      }
      #battery-alert-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        opacity: 0;
        transition: opacity 0.3s ease;
        transform: translate(var(--phone-offset-x, 0), var(--phone-offset-y, 0));
      }
      #battery-alert-modal.visible {
        display: flex;
        opacity: 1;
      }
      .battery-alert-content {
        background-color: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        width: 280px;
        border-radius: 15px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        text-align: center;
        padding: 20px;
        cursor: pointer;
        transform: scale(0.9);
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      #battery-alert-modal.visible .battery-alert-content {
        transform: scale(1);
      }
      #battery-alert-image {
        max-width: 100px;
        max-height: 100px;
        margin-bottom: 15px;
      }
      #battery-alert-text {
        font-size: 16px;
        font-weight: 500;
        color: #333;
        margin: 0;
        line-height: 1.4;
      }
      #chat-list-screen {
      }
      .chat-list-view {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        opacity: 0;
        visibility: hidden;
        transition:
          opacity 0.2s,
          visibility 0.2s;
        z-index: 1;
      }
      .chat-list-view.active {
        opacity: 1;
        visibility: visible;
        z-index: 2;
      }
      #messages-view {
        overflow-y: auto;
      }
      #chat-list-bottom-nav {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        z-index: 15;
        display: flex;
        border-top: 1px solid var(--border-color);
        background-color: rgba(247, 247, 247, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }
      .nav-item {
        flex: 1;
        text-align: center;
        padding: 12px 0;
        font-size: 14px;
        color: var(--text-secondary);
        cursor: pointer;
        transition: color 0.2s;
      }
      .nav-item.active {
        color: var(--accent-color);
        font-weight: 600;
      }
      #qzone-screen {
        background-color: #f0f2f5;
      }
      .qzone-header {
        position: relative;
        z-index: 10;
        flex-shrink: 0;
        padding: 15px 20px;
        padding-top: 45px;
        background-color: rgba(247, 247, 247, 0.7);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 18px;
        font-weight: 600;
        text-align: center;
      }
      .qzone-header .back-btn {
        font-size: 24px;
        cursor: pointer;
        color: var(--accent-color);
      }
      .qzone-header span:nth-child(2) {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
      }
      .qzone-content {
        flex-grow: 1;
        overflow-y: auto;
      }
      .qzone-profile-header {
        position: relative;
        margin-bottom: 20px;
      }
      .qzone-banner-container {
        width: 100%;
        height: 180px;
        position: relative;
      }
      #qzone-banner-img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .qzone-user-info {
        position: absolute;
        bottom: -30px;
        left: 20px;
        display: flex;
        align-items: flex-end;
        gap: 10px;
      }
      .qzone-avatar-container {
        position: relative;
      }
      #qzone-avatar-img {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        border: 3px solid white;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        object-fit: cover;
      }
      #qzone-nickname {
        font-size: 18px;
        font-weight: 600;
        color: #fff;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        padding-bottom: 5px;
      }
      #change-qzone-banner-btn {
        bottom: 10px;
        right: 10px;
      }
      #change-qzone-avatar-btn {
        bottom: 5px;
        right: 5px;
      }
      #change-qzone-nickname-btn {
        font-size: 14px;
        padding: 2px 6px;
        margin-left: 5px;
        color: var(--text-primary);
        background-color: rgba(255, 255, 255, 0.7);
        border-radius: 5px;
        position: relative;
        bottom: 5px;
      }
      #qzone-banner-container,
      #qzone-avatar-container,
      #qzone-nickname {
        cursor: pointer;
        transition: opacity 0.2s;
      }
      #qzone-banner-container:hover,
      #qzone-avatar-container:hover,
      #qzone-nickname:hover {
        opacity: 0.85;
      }
      .qzone-edit-btn {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.4);
        color: white;
        border: none;
        border-radius: 10px;
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        display: none;
      }
      #qzone-screen .qzone-header {
        display: none;
      }
      #qzone-screen.active .qzone-header {
        display: flex;
      }
      #chat-list-screen.in-qzone-view > .header,
      #chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
        display: none;
      }
      .chat-list-item:first-child,
      .chat-group-container:first-child {
        margin-top: 10px;
      }
      .qzone-actions-bar {
        display: flex;
        justify-content: space-around;
        padding: 10px 0;
        margin: 40px 15px 15px 15px;
        background-color: var(--secondary-bg);
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }
      .action-item {
        flex: 1;
        text-align: center;
        font-size: 15px;
        font-weight: 500;
        color: var(--text-primary);
        cursor: pointer;
        padding: 8px 0;
        position: relative;
      }
      .action-item:not(:last-child)::after {
        content: "";
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 1px;
        height: 20px;
        background-color: var(--border-color);
      }
      #qzone-posts-list {
        padding: 0 15px 20px 15px;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      .post-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }
      .post-header .post-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        object-fit: cover;
      }
      .post-info {
        display: flex;
        flex-direction: column;
      }
      .post-info .post-nickname {
        font-weight: 600;
        font-size: 15px;
        color: var(--text-primary);
      }
      .post-info .post-timestamp {
        font-size: 12px;
        color: var(--text-secondary);
      }
      .post-content {
        font-size: 14px;
        line-height: 1.6;
        color: #333;
        white-space: pre-wrap;
        word-break: break-word;
      }
      #post-public-text {
        min-height: 80px;
        resize: vertical;
      }
      .post-image-preview-container {
        position: relative;
        width: 100%;
        aspect-ratio: 16 / 9;
        background-color: #f0f2f5;
        border: 2px dashed var(--border-color);
        border-radius: 8px;
        margin-bottom: 15px;
        display: none;
        justify-content: center;
        align-items: center;
      }
      .post-image-preview-container.visible {
        display: flex;
      }
      #post-image-preview {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        border-radius: 6px;
      }
      #post-remove-image-btn {
        position: absolute;
        top: -10px;
        right: -10px;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background-color: #ff3b30;
        color: white;
        border: 2px solid white;
        font-size: 16px;
        line-height: 20px;
        text-align: center;
        cursor: pointer;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
      }
      .post-image-upload-options {
        display: flex;
        gap: 10px;
      }
      .post-image-upload-options button {
        flex: 1;
        margin-top: 0;
      }
      .post-mode-switcher {
        display: flex;
        margin-bottom: 20px;
        background-color: #e9ecef;
        border-radius: 8px;
        padding: 4px;
      }
      .mode-btn {
        flex: 1;
        padding: 8px;
        border: none;
        background-color: transparent;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.2s ease-in-out;
      }
      .mode-btn.active {
        background-color: var(--secondary-bg);
        color: var(--text-primary);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .post-mode-content {
        display: none;
      }
      .post-mode-content.active {
        display: block;
      }
      #album-screen {
        background-color: #f0f2f5;
      }
      #album-grid-page {
        padding: 15px;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
      }
      .album-item {
        display: flex;
        flex-direction: column;
        cursor: pointer;
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
        border-radius: 8px;
      }
      .album-item:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
      }
      .album-cover {
        aspect-ratio: 1 / 1;
        background-size: cover;
        background-position: center;
        border-radius: 8px;
        margin-bottom: 8px;
        background-color: #f0f2f5;
      }
      .album-info {
        text-align: center;
      }
      .album-name {
        font-weight: 500;
        margin: 0 0 4px 0;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .album-count {
        font-size: 12px;
        color: var(--text-secondary);
        margin: 0;
      }
      #album-photos-screen {
        background-color: #f0f2f5;
      }
      #photos-grid-page {
        padding: 15px;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }
      .photo-item {
        position: relative;
        aspect-ratio: 1 / 1;
        border-radius: 6px;
        overflow: hidden;
        background-color: #e9ecef;
      }
      .photo-item .photo-thumb {
        width: 100%;
        height: 100%;
        object-fit: cover;
        cursor: pointer;
      }
      .photo-item .photo-delete-btn {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 22px;
        height: 22px;
        background-color: rgba(0, 0, 0, 0.6);
        color: white;
        border: none;
        border-radius: 50%;
        font-size: 16px;
        line-height: 22px;
        text-align: center;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .photo-item:hover .photo-delete-btn {
        opacity: 1;
      }
      #photo-viewer-modal {
        background-color: rgba(0, 0, 0, 0.85);
        z-index: 1002;
        -webkit-backdrop-filter: blur(5px);
        backdrop-filter: blur(5px);
      }
      .photo-viewer-content {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
      }
      #photo-viewer-image {
        max-width: 90vw;
        max-height: 85vh;
        object-fit: contain;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        transition: opacity 0.2s ease-in-out;
      }
      #photo-viewer-close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        border: none;
        color: white;
        font-size: 40px;
        font-weight: 200;
        cursor: pointer;
        line-height: 1;
        text-shadow: 0 0 5px black;
      }
      #photo-viewer-modal .nav-arrow {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.7);
        font-size: 50px;
        font-weight: 100;
        cursor: pointer;
        padding: 10px;
        user-select: none;
        transition: color 0.2s;
        z-index: 1003;
      }
      #photo-viewer-prev-btn {
        left: 5px;
      }
      #photo-viewer-next-btn {
        right: 5px;
      }
      #photo-viewer-modal .nav-arrow:hover {
        color: white;
      }
      #photo-viewer-modal .nav-arrow:disabled {
        color: rgba(255, 255, 255, 0.2);
        cursor: default;
      }
      .post-main-content {
      }
      .post-feedback-icons {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        gap: 12px;
        padding: 8px 0;
      }
      .action-icon {
        cursor: pointer;
        color: var(--text-secondary);
        transition: all 0.2s ease-in-out;
      }
      .action-icon svg {
        width: 22px;
        height: 22px;
        fill: none;
        stroke: currentColor;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
      }
      .action-icon.active {
        color: #ff5252;
        transform: scale(1.1);
      }
      .action-icon.active.favorite {
        color: #ffc107;
      }
      .action-icon.active svg {
        fill: currentColor;
      }
      .animate-like {
        animation: like-bounce 0.4s ease-in-out;
      }
      @keyframes like-bounce {
        0% {
          transform: scale(1);
        }
        25% {
          transform: scale(0.8);
        }
        50% {
          transform: scale(1.2);
        }
        75% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1.1);
        }
      }
      .post-footer {
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #f0f0f0;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .comment-section {
        flex-grow: 1;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .comment-section .comment-avatar {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        object-fit: cover;
        flex-shrink: 0;
      }
      .comment-section .comment-input {
        width: 100%;
        padding: 8px 12px;
        border: none;
        background-color: #f0f2f5;
        border-radius: 14px;
        font-size: 13px;
        outline: none;
      }
      .comment-send-btn {
        flex-shrink: 0;
        padding: 8px 15px;
        border: none;
        background-color: var(--accent-color);
        color: white;
        border-radius: 14px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
      }
      .unread-indicator {
        position: absolute;
        top: -8px;
        right: -15px;
        min-width: 18px;
        height: 18px;
        padding: 0 5px;
        background-color: #ff3b30;
        color: white;
        font-size: 11px;
        font-weight: bold;
        line-height: 18px;
        text-align: center;
        border-radius: 9px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        display: none;
        z-index: 1;
      }
      .back-btn-indicator {
        top: 0;
        right: -8px;
        width: 10px;
        height: 10px;
        min-width: 10px;
        padding: 0;
        border-radius: 50%;
      }
      .post-comments-container {
        padding: 10px 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 13px;
      }
      .comment-item .commenter-name {
        font-weight: 600;
        color: var(--accent-color);
        cursor: pointer;
        margin-right: 5px;
      }
      .comment-item .comment-text {
        color: var(--text-primary);
        word-break: break-word;
      }
      .post-likes-section {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 8px 10px;
        font-size: 13px;
        color: var(--accent-color);
        background-color: #f0f5fa;
        border-top: 1px solid #e9eef3;
        border-bottom: 1px solid #e9eef3;
        margin-top: 5px;
      }
      .post-likes-section .like-icon {
        width: 16px;
        height: 16px;
        fill: currentColor;
        flex-shrink: 0;
      }
      .at-mention-popup {
        position: absolute;
        bottom: 100%;
        left: 40px;
        width: calc(100% - 40px);
        max-height: 120px;
        overflow-y: auto;
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
        z-index: 10;
        display: none;
      }
      .at-mention-item {
        padding: 8px 12px;
        font-size: 14px;
        cursor: pointer;
        color: var(--text-primary);
        border-bottom: 1px solid #f0f0f0;
      }
      .at-mention-item:last-child {
        border-bottom: none;
      }
      .at-mention-item:hover {
        background-color: #f5f5f5;
      }
      #favorites-view {
        display: flex;
        flex-direction: column;
      }
      #favorites-view > .header {
        flex-shrink: 0;
      }
      #favorites-list {
        flex-grow: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 15px;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      .favorite-item-card {
        background-color: var(--secondary-bg);
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
        position: relative;
      }
      .fav-card-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
      }
      .fav-card-header .avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        object-fit: cover;
      }
      .fav-card-header .info {
        flex-grow: 1;
      }
      .fav-card-header .name {
        font-weight: 600;
        font-size: 15px;
      }
      .fav-card-header .source {
        font-size: 12px;
        color: var(--text-secondary);
      }
      .fav-card-content {
        font-size: 14px;
        line-height: 1.6;
        color: #333;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .fav-card-content .chat-image {
        margin-top: 8px;
      }
      .fav-delete-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 28px;
        height: 28px;
        background: #f0f2f5;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        font-size: 18px;
        color: var(--text-secondary);
        line-height: 28px;
        text-align: center;
      }
      .fav-delete-btn:hover {
        background-color: #e9ecef;
        color: #ff3b30;
      }
      .search-bar-container {
        padding: 10px 15px;
        background-color: #f9f9f9;
        position: relative;
        flex-shrink: 0;
      }
      #favorites-search-input {
        width: 100%;
        padding: 10px 30px 10px 15px;
        font-size: 14px;
        border: 1px solid var(--border-color);
        border-radius: 18px;
        background-color: var(--secondary-bg);
        box-sizing: border-box;
        outline: none;
      }
      #favorites-search-input:focus {
        border-color: var(--accent-color);
      }
      .search-clear-btn {
        position: absolute;
        right: 25px;
        top: 50%;
        transform: translateY(-50%);
        background: #ccc;
        color: white;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        font-size: 16px;
        cursor: pointer;
      }
      #chat-interface-screen .selection-controls .action-btn {
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        padding: 5px;
      }
      .favorite-item-card::before {
        content: "";
        position: absolute;
        left: -25px;
        top: 50%;
        transform: translateY(-50%);
        width: 20px;
        height: 20px;
        border: 2px solid #ccc;
        border-radius: 50%;
        background-color: white;
        transition: all 0.2s ease;
        opacity: 0;
      }
      #favorites-view.selection-mode .favorite-item-card {
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
        transform: translateX(35px);
      }
      #favorites-view.selection-mode .favorite-item-card::before {
        opacity: 1;
      }
      #favorites-view.selection-mode .favorite-item-card.selected::before {
        background-color: var(--accent-color);
        border-color: var(--accent-color);
        content: "✔";
        color: white;
        font-size: 14px;
        text-align: center;
        line-height: 20px;
      }
      #favorites-action-bar {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        width: auto;
        padding: 10px 15px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom));
        background-color: rgba(247, 247, 247, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-top: 1px solid var(--border-color);
        box-sizing: border-box;
        z-index: 5;
        display: none;
      }
      #favorites-action-bar .action-bar-btn {
        width: 100%;
        padding: 12px;
        border-radius: 8px;
        border: none;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        background-color: #ff3b30;
        color: white;
      }
      #chat-interface-screen .header .selection-controls {
        display: none;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }
      #chat-interface-screen .header .default-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }
      #chat-interface-screen.selection-mode .header .default-controls {
        display: none;
      }
      #chat-interface-screen.selection-mode .header .selection-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
      }
      #add-chat-btn,
      #add-world-book-btn,
      #create-album-btn-page {
        font-size: 28px;
        font-weight: 300;
        position: relative;
        top: -1px;
      }
      #settings-preview-area {
        width: 100%;
        height: 180px;
        background-color: #f0f2f5;
        border-radius: 8px;
        padding: 15px;
        box-sizing: border-box;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        gap: 10px;
        border: 1px solid var(--border-color);
        position: relative;
      }
      #settings-preview-area::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
        z-index: 1;
        opacity: 0.8;
      }
      #settings-preview-area .message-wrapper {
        position: relative;
        z-index: 2;
      }
      #settings-preview-area .message-bubble .avatar {
        width: 30px;
        height: 30px;
      }
      #settings-preview-area .message-bubble .timestamp {
        display: none;
      }
      .existing-group-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
        background-color: #f9f9f9;
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }
      .existing-group-item .group-name {
        font-weight: 500;
      }
      .existing-group-item .delete-group-btn {
        color: #ff3b30;
        font-size: 20px;
        cursor: pointer;
        padding: 5px;
      }
      .chat-group-container {
        border-bottom: 1px solid var(--border-color);
      }
      .chat-group-container:first-child {
        border-top: 1px solid var(--border-color);
      }
      .chat-group-header {
        display: flex;
        align-items: center;
        padding: 12px 15px;
        cursor: pointer;
        background-color: #f7f7f7;
      }
      .chat-group-header .arrow {
        font-size: 14px;
        margin-right: 8px;
        transition: transform 0.2s ease;
      }
      .chat-group-header.collapsed .arrow {
        transform: rotate(-90deg);
      }
      .chat-group-header .group-name {
        font-weight: 600;
        font-size: 15px;
      }
      .chat-group-content {
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out;
      }
      .chat-group-content.collapsed {
        max-height: 0;
      }
      .format-helpers {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }
      .format-btn {
        background-color: #e9ecef;
        color: var(--text-primary);
        border: none;
        padding: 6px 12px;
        border-radius: 16px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .format-btn:hover {
        background-color: #dcdfe3;
      }
      .post-actions-btn {
        margin-left: auto;
        padding: 5px 10px;
        font-size: 20px;
        font-weight: bold;
        color: var(--text-secondary);
        cursor: pointer;
        border-radius: 50%;
        line-height: 1;
      }
      .post-actions-btn:hover {
        background-color: #f0f0f0;
      }
      #post-actions-modal .custom-modal-footer button {
        width: 100%;
        border: none;
        border-bottom: 1px solid #dbdbdb;
        padding: 14px;
        font-size: 18px;
      }
      #post-actions-modal .custom-modal-footer button:last-child {
        border-bottom: none;
      }
      #post-actions-modal #cancel-post-action-btn {
        margin-top: 8px;
        border-radius: 8px;
        background-color: #f0f0f0;
      }
      #chat-messages .transfer-card .transfer-title,
      #chat-messages .transfer-card .transfer-amount,
      #chat-messages .transfer-card .transfer-note {
        text-shadow: none !important;
        color: white !important;
      }
      #chat-messages .transfer-card .transfer-title {
        font-size: 16px !important;
        font-weight: 600 !important;
      }
      #chat-messages .transfer-card .transfer-amount {
        font-size: 28px !important;
        font-weight: bold !important;
      }
      #chat-messages .transfer-card .transfer-note {
        font-size: 13px !important;
        opacity: 0.9 !important;
      }
      .header > span:nth-child(2),
      #chat-header-title {
        position: absolute;
        left: 50%;
        transform: translateX(calc(-50% - 2px));
        max-width: 60%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      #message-editor-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      .message-editor-block {
        background-color: #f9f9f9;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 12px;
      }
      .message-editor-block textarea {
        width: 100%;
        min-height: 60px;
        resize: vertical;
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 8px;
        font-size: 14px;
        box-sizing: border-box;
      }
      .message-editor-block .format-helpers {
        margin-top: 8px;
        margin-bottom: 0;
      }
      .message-editor-block .delete-block-btn {
        float: right;
        margin-top: -5px;
        background: none;
        border: none;
        color: #ff3b30;
        font-size: 20px;
        cursor: pointer;
      }
      .contact-picker-item {
        display: flex;
        align-items: center;
        padding: 10px 15px;
        cursor: pointer;
        border-bottom: 1px solid var(--border-color);
      }
      .contact-picker-item .checkbox {
        width: 20px;
        height: 20px;
        border: 2px solid #ccc;
        border-radius: 50%;
        margin-right: 15px;
        transition: all 0.2s ease;
      }
      .contact-picker-item.selected .checkbox {
        background-color: var(--accent-color);
        border-color: var(--accent-color);
        content: "✔";
        color: white;
        font-size: 14px;
        text-align: center;
        line-height: 20px;
      }
      .contact-picker-item .avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        margin-right: 12px;
      }
      .contact-picker-item .name {
        font-weight: 500;
      }
      #member-management-list {
        padding: 0;
      }
      .member-management-item {
        display: flex;
        align-items: center;
        padding: 12px 15px;
        border-bottom: 1px solid var(--border-color);
      }
      .member-management-item .avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        margin-right: 12px;
      }
      .member-management-item .name {
        flex-grow: 1;
        font-weight: 500;
      }
      .member-management-item .remove-member-btn {
        background-color: #ff3b30;
        color: white;
        border: none;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        font-size: 20px;
        line-height: 28px;
        text-align: center;
        cursor: pointer;
        flex-shrink: 0;
      }
      #member-management-actions {
        flex-shrink: 0;
        padding: 15px;
        border-top: 1px solid var(--border-color);
        background-color: #f7f7f7;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      #member-management-actions button {
        width: 100%;
        padding: 15px;
        background-color: var(--accent-color);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
      }
      #member-management-actions #create-new-member-btn {
        background-color: #4cd964;
      }
      .message-bubble.is-waimai-request .content {
        padding: 0;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }
      .waimai-card {
        width: 240px;
        border-radius: 12px;
        overflow: hidden;
        background-color: #fff;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
      }
      .waimai-header {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
        border-bottom: 1px solid #f0f0f0;
      }
      .waimai-header .icon {
        width: 20px;
        height: 20px;
      }
      .waimai-header .title-group {
        display: flex;
        align-items: baseline;
        font-size: 14px;
        color: #8a8a8a;
      }
      .waimai-header .title-group .brand {
        font-weight: 600;
        color: #555;
        margin-right: 5px;
      }
      .waimai-header .title-group .separator {
        margin: 0 5px;
      }
      .waimai-catchphrase {
        font-size: 13px;
        color: #1f1f1f;
        padding: 12px;
      }
      .waimai-main {
        background-color: #ffd66b;
        padding: 12px;
        text-align: center;
      }
      .waimai-main .request-title {
        font-size: 12px;
        color: #856404;
        margin-bottom: 8px;
      }
      .waimai-main .payment-box {
        background-color: #fff;
        border-radius: 8px;
        padding: 15px 10px;
      }
      .waimai-main .payment-label {
        font-size: 13px;
        color: #8a8a8a;
      }
      .waimai-main .amount {
        font-size: 32px;
        font-weight: 700;
        color: #1f1f1f;
        margin: 4px 0 12px 0;
      }
      .waimai-main .countdown-label {
        font-size: 13px;
        color: #8a8a8a;
      }
      .waimai-main .countdown-timer {
        display: inline-flex;
        align-items: center;
        gap: 2px;
        margin-left: 5px;
      }
      .waimai-main .countdown-timer span {
        background-color: #333;
        color: white;
        padding: 2px 4px;
        border-radius: 2px;
        font-weight: bold;
        font-size: 12px;
      }
      .waimai-details-btn {
        width: 100%;
        padding: 10px 0;
        margin-top: 15px;
        border: none;
        border-radius: 6px;
        background-color: #ffc33a;
        color: #49380a;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
      }
      .message-bubble.status-paid .waimai-card {
        border: 2px solid #28a745;
      }
      .message-bubble.status-paid .waimai-main .request-title::before {
        content: "✅  ";
      }
      .message-bubble.status-paid .waimai-main .request-title {
        color: #155724;
        font-weight: 600;
        content: "我已为您买单，请尽情享用吧～" !important;
        display: block;
        margin-bottom: 15px;
      }
      .message-bubble.status-paid .payment-box {
        display: none;
      }
      .message-bubble.status-paid .waimai-details-btn {
        background-color: #28a745;
        color: white;
      }
      .message-bubble.status-rejected .waimai-card {
        border: 2px solid #dc3545;
        opacity: 0.8;
      }
      .message-bubble.status-rejected .waimai-main {
        background-color: #e9ecef;
      }
      .message-bubble.status-rejected .waimai-main .request-title::before {
        content: "❌ ";
      }
      .message-bubble.status-rejected .waimai-main .request-title {
        color: #721c24;
        font-weight: 600;
        content: "我拒绝了您的代付请求" !important;
        display: block;
        margin-bottom: 15px;
      }
      .message-bubble.status-rejected .payment-box {
        display: none;
      }
      .message-bubble.status-rejected .waimai-details-btn {
        background-color: #6c757d;
        color: white;
      }
      .message-bubble[class*="status-"] .request-title {
        font-size: 0;
      }
      .message-bubble[class*="status-"] .request-title::after {
        font-size: 14px;
      }
      .message-bubble.status-paid .request-title::after {
        content: "我已为您买单，请尽情享用吧～";
      }
      .message-bubble.status-rejected .request-title::after {
        content: "我拒绝了您的代付请求";
      }
      .waimai-user-actions {
        display: flex;
        gap: 10px;
        padding: 0 12px 12px 12px;
        background-color: #fff;
      }
      .waimai-user-actions button {
        flex: 1;
        padding: 10px;
        border-radius: 8px;
        border: 1.5px solid;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .waimai-pay-btn {
        background-color: #28a745;
        border-color: #1f7a33;
        color: white;
      }
      .waimai-pay-btn:hover {
        background-color: #218838;
      }
      .waimai-decline-btn {
        background-color: #f8f9fa;
        border-color: #ced4da;
        color: #495057;
      }
      .waimai-decline-btn:hover {
        background-color: #e2e6ea;
      }
      #api-settings-screen,
      #font-settings-screen,
      #wallpaper-screen,
      #memories-view,
      #contact-picker-screen,
      #member-management-screen,
      #world-book-editor-screen {
        background-color: var(--secondary-bg);
      }
      #api-settings-screen .form-container,
      #font-settings-screen .form-container,
      #wallpaper-screen .form-container {
        padding-top: 100px;
        margin-top: -80px;
        background-color: var(--secondary-bg);
      }
      #incoming-call-modal .incoming-call-content {
        background-color: rgba(40, 40, 40, 0.85);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-radius: 20px;
        width: 280px;
        padding: 30px 20px;
        text-align: center;
        color: white;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }
      .caller-avatar {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        object-fit: cover;
        margin-bottom: 12px;
        border: 3px solid rgba(255, 255, 255, 0.5);
      }
      .caller-name {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 5px;
      }
      .caller-text {
        font-size: 14px;
        color: #ccc;
        margin-bottom: 30px;
      }
      .incoming-call-actions {
        display: flex;
        justify-content: space-around;
        align-items: center;
      }
      .action-button-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: #e0e0e0;
      }
      .call-action-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        background-size: 50%;
        background-repeat: no-repeat;
        background-position: center;
        transition:
          transform 0.2s,
          box-shadow 0.2s;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      .call-action-btn:active {
        transform: scale(0.9);
      }
      .call-action-btn.decline {
        background-color: #ff3b30;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
      }
      .call-action-btn.accept {
        background-color: #4cd964;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
        animation: pulse 1.5s infinite;
      }
      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7);
        }
        70% {
          box-shadow: 0 0 0 15px rgba(76, 217, 100, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(76, 217, 100, 0);
        }
      }
      #video-call-screen {
        background-color: #1c1c1e;
        color: white;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .video-call-top-bar {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        padding: 15px 20px;
        padding-top: 50px;
        background: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), transparent);
        z-index: 10;
        text-align: center;
        box-sizing: border-box;
        pointer-events: none;
      }
      #call-timer {
        font-size: 16px;
        font-weight: 500;
        letter-spacing: 1px;
      }
      .video-call-controls {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: space-around;
        align-items: center;
        padding: 20px;
        padding-bottom: 40px;
        background: linear-gradient(to top, rgba(0, 0, 0, 0.5), transparent);
        z-index: 10;
        box-sizing: border-box;
      }
      .video-call-avatar-area {
        height: 35%;
        flex-shrink: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
        padding-top: 80px;
        box-sizing: border-box;
        overflow-y: auto;
      }
      #participant-avatars-grid {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 15px;
        max-width: 100%;
      }
      .participant-avatar-wrapper {
        position: relative;
        text-align: center;
        flex-shrink: 0;
      }
      .participant-avatar {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        object-fit: cover;
        border: 3px solid rgba(255, 255, 255, 0.2);
        transition: all 0.3s ease;
      }
      .participant-name {
        margin-top: 8px;
        font-size: 12px;
        color: #ccc;
      }
      .participant-avatar.speaking {
        border-color: #4cd964;
        box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
        transform: scale(1.05);
      }
      #video-call-main {
        flex-grow: 1;
        margin: 15px 15px 130px 15px;
        overflow-y: auto;
        padding: 15px;
        background-color: rgba(255, 255, 255, 0.05);
        border-radius: 20px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        box-sizing: border-box;
      }
      .control-btn {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        border: none;
        cursor: pointer;
        background-repeat: no-repeat;
        background-position: center;
        transition:
          transform 0.2s,
          background-color 0.2s;
      }
      .control-btn:active {
        transform: scale(0.9);
      }
      .control-btn.speak-btn {
        background-color: rgba(255, 255, 255, 0.2);
        background-size: 55%;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>');
      }
      .control-btn.hangup-btn {
        background-color: #ff3b30;
        background-size: 50%;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
      }
      .control-btn.join-btn {
        background-color: #007bff;
        background-size: 50%;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>');
      }
      .call-message-bubble {
        padding: 10px 15px;
        border-radius: 12px;
        max-width: 85%;
        line-height: 1.6;
        word-break: break-word;
        white-space: pre-wrap;
      }
      .call-message-bubble.ai-speech {
        background-color: rgba(255, 255, 255, 0.15);
        align-self: flex-start;
      }
      .call-message-bubble.user-speech {
        background-color: #4cd964;
        align-self: flex-end;
        text-align: left;
      }
      #outgoing-call-screen {
        background-color: #1c1c1e;
        color: white;
        justify-content: center;
        align-items: center;
      }
      .outgoing-call-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
      }
      .outgoing-call-actions {
        margin-top: 50px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: #e0e0e0;
      }
      .qzone-post-container {
        position: relative;
        overflow: hidden;
        border-radius: 12px;
      }
      .qzone-post-item {
        background-color: var(--secondary-bg);
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
        transition: transform 0.3s ease;
        position: relative;
        z-index: 2;
      }
      .qzone-post-delete-action {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 90px;
        background-color: #ff3b30;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 500;
        cursor: pointer;
        z-index: 1;
      }
      .qzone-post-item.swiped {
        transform: translateX(-90px);
      }
      @keyframes pat-shake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-3px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(3px);
        }
      }
      .pat-animation {
        animation: pat-shake 0.4s ease-in-out;
      }
      .system-message {
        align-self: center;
        padding: 4px 12px;
        margin: 5px 0;
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--text-secondary);
        font-size: 12px;
        border-radius: 10px;
        text-align: center;
        max-width: 80%;
      }
      .message-wrapper.system-pat {
        justify-content: center;
        align-self: center;
        margin: 5px 0;
        max-width: 80%;
      }
      .message-bubble.system-bubble {
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--text-secondary);
        font-size: 12px;
        padding: 4px 12px;
        border-radius: 10px;
      }
      .message-bubble.is-sticker .content,
      .message-bubble.is-transfer .content,
      .message-bubble.is-waimai-request .content,
      .message-bubble.has-image .content,
      .message-bubble.is-ai-image .content,
      .message-bubble.is-voice-message .content {
        background-color: transparent !important;
        background: transparent !important;
        box-shadow: none !important;
        border: none !important;
        padding: 0 !important;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
      }
      .message-bubble.is-sticker:not(.selected)::after,
      .message-bubble.has-image:not(.selected)::after,
      .message-bubble.is-ai-image:not(.selected)::after,
      .message-bubble.is-transfer:not(.selected)::after,
      .message-bubble.is-waimai-request:not(.selected)::after,
      .message-bubble.is-voice-message:not(.selected)::after {
        display: none !important;
      }
      #typing-indicator {
        align-self: center;
        display: none;
        margin: 5px 0;
        color: var(--text-secondary);
      }
      #typing-indicator .system-bubble {
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--text-secondary);
        font-size: 12px;
        padding: 4px 12px;
        border-radius: 10px;
        display: inline-block;
      }
      #chat-input-actions-top {
        display: flex;
        gap: 8px;
        padding: 0 5px;
        overflow-x: auto;
        flex-wrap: nowrap;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        -ms-overflow-style: none;
      }
      #chat-input-actions-top::-webkit-scrollbar {
        display: none;
      }
      #chat-header-title-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        max-width: 60%;
      }
      #chat-header-status {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 11px;
        color: var(--text-secondary);
        transition: all 0.3s ease;
      }
      .status-dot {
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background-color: #4cd964;
        transition: background-color 0.3s ease;
      }
      #chat-header-status.busy .status-dot {
        background-color: #cccccc;
      }
      .status-text {
        font-weight: 500;
      }
      .memory-card {
        background-color: #fffaf0;
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.07);
        border-left: 5px solid #ffb74d;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .memory-card .header {
        border-bottom: 1px solid rgba(217, 129, 0, 0.15);
        padding-bottom: 8px;
      }
      .memory-card .header .date {
        font-size: 11px;
        color: #a1887f;
        margin-bottom: 4px;
      }
      .memory-card .header .author {
        font-weight: 600;
        color: #d98100;
        font-size: 15px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .memory-card .content {
        font-size: 14px;
        line-height: 1.7;
        color: #5d4037;
        white-space: pre-wrap;
      }
      .countdown-card {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
        text-align: center;
        position: relative;
        overflow: hidden;
        flex-shrink: 0;
      }
      .countdown-card::before {
        content: "✨";
        position: absolute;
        top: -10px;
        left: -10px;
        font-size: 50px;
        opacity: 0.1;
        transform: rotate(-15deg);
      }
      .countdown-card .title {
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 15px;
      }
      .countdown-card .timer {
        font-size: 28px;
        font-weight: 300;
        letter-spacing: 2px;
        margin-bottom: 15px;
      }
      .countdown-card .target-date {
        font-size: 12px;
        opacity: 0.8;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        padding-top: 10px;
      }
      #chat-lock-overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        background-color: rgba(247, 247, 247, 0.9);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        z-index: 150;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 20px;
        box-sizing: border-box;
        border-top: 1px solid var(--border-color);
        text-align: center;
      }
      #chat-lock-content {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      #chat-lock-content .lock-text {
        color: var(--text-secondary);
        font-size: 14px;
      }
      #chat-lock-content .lock-action-btn {
        padding: 10px 20px;
        border-radius: 20px;
        border: 1px solid var(--accent-color);
        background-color: var(--accent-color);
        color: white;
        cursor: pointer;
      }
      #chat-lock-content .lock-action-btn.secondary {
        background-color: transparent;
        color: var(--accent-color);
      }
      .message-bubble.is-red-packet .content {
        padding: 0;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }
      .red-packet-card {
        width: 220px;
        border-radius: 8px;
        background: linear-gradient(160deg, #f96259, #e44d44);
        color: #ffd700;
        padding: 12px;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        position: relative;
        overflow: hidden;
      }
      .red-packet-card.opened {
        background: linear-gradient(160deg, #d3c4a0, #c4b693);
        cursor: default;
      }
      .red-packet-card::before {
        content: "🧧";
        position: absolute;
        top: -5px;
        left: -5px;
        font-size: 30px;
        opacity: 0.2;
        transform: rotate(-10deg);
      }
      .rp-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
      }
      .rp-icon {
        width: 20px;
        height: 20px;
      }
      .rp-greeting {
        font-size: 15px;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .rp-type {
        font-size: 11px;
        color: white;
        opacity: 0.8;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        padding-top: 8px;
        margin-top: 8px;
      }
      .rp-claimed-info {
        font-size: 13px;
        color: white;
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid rgba(255, 255, 255, 0.3);
      }
      .rp-details-item {
        display: flex;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid #eee;
      }
      .rp-details-item:last-child {
        border-bottom: none;
      }
      .rp-details-item .name {
        flex-grow: 1;
        font-weight: 500;
        color: #333;
      }
      .rp-details-item .amount {
        font-weight: 500;
        color: #555;
      }
      .rp-details-item .lucky-king-tag {
        font-size: 10px;
        background-color: #ffd700;
        color: #a67c00;
        padding: 2px 5px;
        border-radius: 4px;
        margin-left: 8px;
        font-weight: bold;
      }
      .message-bubble.is-poll .content {
        padding: 0;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }
      .poll-card {
        width: 250px;
        background-color: #f9f9f9;
        border-radius: 10px;
        border: 1px solid #e0e0e0;
        padding: 12px;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }
      .poll-card.closed {
        background-color: #e9ecef;
      }
      .poll-question {
        font-weight: 600;
        font-size: 15px;
        margin-bottom: 12px;
        line-height: 1.4;
        word-break: break-word;
      }
      .poll-options-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .poll-option-item {
        background-color: white;
        border: 1px solid #dcdcdc;
        border-radius: 8px;
        padding: 10px;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        transition: background-color 0.2s;
      }
      .poll-card:not(.closed) .poll-option-item:hover {
        background-color: #f0f8ff;
      }
      .poll-option-item.voted {
        border-color: var(--accent-color);
        background-color: #e7f3ff;
        font-weight: 500;
      }
      .poll-option-bar {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        background-color: rgba(0, 123, 255, 0.1);
        z-index: 1;
        transition: width 0.3s ease-in-out;
      }
      .poll-option-content {
        position: relative;
        z-index: 2;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .poll-option-text {
        font-size: 14px;
      }
      .poll-option-votes {
        font-size: 13px;
        color: #8a8a8a;
        font-weight: 500;
      }
      .poll-footer {
        margin-top: 12px;
        padding-top: 8px;
        border-top: 1px solid #e9e9e9;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 12px;
        color: var(--text-secondary);
      }
      .poll-total-votes {
        font-weight: 500;
      }
      .poll-action-btn {
        background: none;
        border: 1px solid var(--accent-color);
        color: var(--accent-color);
        padding: 4px 10px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 12px;
      }
      .poll-card.closed .poll-action-btn {
        background-color: #6c757d;
        color: white;
        border-color: #6c757d;
      }
      .poll-option-input-wrapper {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .poll-option-input-wrapper input {
        flex-grow: 1;
      }
      .poll-option-input-wrapper .remove-option-btn {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background-color: #f0f0f0;
        color: #ff3b30;
        border: none;
        cursor: pointer;
        font-size: 18px;
        line-height: 28px;
        text-align: center;
        flex-shrink: 0;
      }
      #chat-header-title.typing-status {
        color: var(--text-secondary);
        animation: typing-pulse 1.5s infinite;
        font-style: italic;
      }
      @keyframes typing-pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }
      #chat-header-title {
        font-size: 16px;
        font-weight: 600;
        position: static;
        transform: none;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        transition: opacity 0.2s ease-in-out;
      }
      @keyframes message-pop-in {
        from {
          opacity: 0;
          transform: translateY(15px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .message-wrapper.animate-in {
        animation: message-pop-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
      }
      #icon-settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
        gap: 20px;
        width: 100%;
        padding: 0 10px;
        box-sizing: border-box;
      }
      .icon-setting-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }
      .icon-preview {
        width: 60px;
        height: 60px;
        border-radius: 15px;
        background-size: cover;
        background-position: center;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }
      .change-icon-btn {
        padding: 4px 10px;
        font-size: 12px;
        border: 1px solid #ccc;
        background-color: #f0f0f0;
        border-radius: 5px;
        cursor: pointer;
      }
      #wallpaper-screen .form-container {
        align-items: center;
        min-height: 0;
      }
      #wallpaper-preview {
        width: 180px;
        height: 320px;
        border: 2px dashed var(--border-color);
        background-color: #f0f2f5;
        margin-bottom: 20px;
        background-size: cover;
        background-position: center;
        border-radius: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        color: var(--text-secondary);
        flex-shrink: 0;
      }
      #browser-screen {
        background-color: #f8f9fa;
      }
      #browser-content {
        padding: 20px;
        font-size: 16px;
        line-height: 1.8;
        color: #333;
        overflow-y: auto;
        background-color: #f8f9fa;
      }
      #browser-content .article-title {
        font-size: 24px;
        font-weight: 700;
        margin-bottom: 10px;
      }
      #browser-content .article-meta {
        font-size: 13px;
        color: #8a8a8a;
        margin-bottom: 25px;
        padding-bottom: 15px;
        border-bottom: 1px solid #e0e0e0;
      }
      #browser-content .article-body {
        white-space: pre-wrap;
        word-break: break-word;
      }
      #browser-content .article-body p {
        margin-bottom: 1em;
      }
      .message-bubble.is-link-share .content {
        padding: 0;
        background: transparent;
        box-shadow: none;
        border: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }
      .link-share-card {
        width: 210px;
        background-color: #fff;
        border-radius: 10px;
        border: 1px solid #e0e0e0;
        padding: 12px;
        cursor: pointer;
        transition: background-color 0.2s;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .link-share-card:hover {
        background-color: #f9f9f9;
      }
      .link-share-card .title {
        font-weight: 600;
        font-size: 15px;
        line-height: 1.4;
        color: #1f1f1f;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .link-share-card .description {
        font-size: 13px;
        color: #8a8a8a;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .link-share-card .footer {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        color: var(--text-secondary);
        margin-top: 4px;
      }
      .link-share-card .footer-icon {
        width: 14px;
        height: 14px;
        flex-shrink: 0;
      }
      .comment-item {
        line-height: 1.5;
        position: relative;
        padding-right: 25px;
      }
      .comment-delete-btn {
        position: absolute;
        top: 50%;
        right: 0;
        transform: translateY(-50%);
        width: 22px;
        height: 22px;
        line-height: 22px;
        text-align: center;
        border-radius: 50%;
        color: var(--text-secondary);
        font-size: 18px;
        cursor: pointer;
        transition: all 0.2s ease;
        opacity: 0;
      }
      .comment-item:hover .comment-delete-btn {
        opacity: 1;
      }
      .comment-delete-btn:hover {
        background-color: #f0f0f0;
        color: #ff3b30;
      }
      #phone-screen.dark-mode {
        --secondary-bg: #1c1c1e;
        --border-color: #38383a;
        --text-primary: #ffffff;
        --text-secondary: #8d8d92;
      }
      #phone-screen.dark-mode #chat-list-screen,
      #phone-screen.dark-mode #qzone-screen .qzone-content,
      #phone-screen.dark-mode #memories-view {
        background-color: #000000;
      }
      #phone-screen.dark-mode #chat-list {
        background-color: #000000;
      }
      #phone-screen.dark-mode .chat-list-item {
        border-bottom-color: rgba(255, 255, 255, 0.15);
      }
      #phone-screen.dark-mode .chat-group-header {
        background-color: #1c1c1e;
        border-bottom: 1px solid #38383a;
      }
      #phone-screen.dark-mode .chat-list-item .name,
      #phone-screen.dark-mode .chat-group-header .group-name {
        color: #ffffff;
      }
      #phone-screen.dark-mode .chat-list-item:hover {
        background-color: #1c1c1e;
      }
      #phone-screen.dark-mode .header,
      #phone-screen.dark-mode .qzone-header {
        background-color: rgba(25, 25, 25, 0.9);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-bottom-color: rgba(255, 255, 255, 0.15);
        color: #ffffff;
      }
      #phone-screen.dark-mode .header .back-btn,
      #phone-screen.dark-mode .header .action-btn,
      #phone-screen.dark-mode .header .save-btn {
        color: #ffffff;
      }
      #phone-screen.dark-mode #chat-list-bottom-nav {
        background-color: rgba(25, 25, 25, 0.9);
        border-top-color: rgba(255, 255, 255, 0.15);
      }
      #phone-screen.dark-mode .nav-item.active {
        color: #ffffff;
      }
      #phone-screen.dark-mode #chat-input-area {
        background-color: rgba(5, 5, 5, 0.8);
        border-top: none;
      }
      #phone-screen.dark-mode #chat-input {
        background-color: #3e3e42;
        color: #ffffff;
      }
      #phone-screen.dark-mode #chat-input::placeholder {
        color: #8d8d92;
      }
      #phone-screen.dark-mode .chat-action-icon-btn {
        color: #ffffff;
        background-color: rgba(255, 255, 255, 0.1);
        border: none;
      }
      #phone-screen.dark-mode #send-btn {
        background-color: var(--accent-color);
      }
      #phone-screen.dark-mode .qzone-actions-bar,
      #phone-screen.dark-mode .qzone-post-item {
        background-color: #1c1c1e;
        border: 1px solid #333;
        box-shadow: 0 2px 8px rgba(255, 255, 255, 0.05);
      }
      #phone-screen.dark-mode .action-item:not(:last-child)::after {
        background-color: #333;
      }
      #phone-screen.dark-mode .post-footer,
      #phone-screen.dark-mode .post-likes-section {
        border-top-color: #333;
      }
      #phone-screen.dark-mode .post-likes-section {
        background-color: rgba(0, 123, 255, 0.1);
      }
      #phone-screen.dark-mode .comment-input {
        background-color: #333;
        color: #ffffff;
      }
      #phone-screen.dark-mode .comment-input::placeholder {
        color: #8d8d92;
      }
      #phone-screen.dark-mode .post-actions-btn:hover {
        background-color: #333;
      }
      #phone-screen.dark-mode .at-mention-popup {
        background-color: #1c1c1e;
        border-color: #333;
      }
      #phone-screen.dark-mode .at-mention-item {
        border-bottom-color: #333;
      }
      #phone-screen.dark-mode .at-mention-item:hover {
        background-color: #333;
      }
      #phone-screen.dark-mode .memory-card {
        background-color: #1c1c1e;
        border-left-color: #e6a753;
        box-shadow: 0 4px 12px rgba(255, 255, 255, 0.08);
      }
      #phone-screen.dark-mode .memory-card .header {
        background-color: #2c2c2e;
        border-bottom-color: #38383a;
        margin: -15px -15px 8px -15px;
        padding: 12px 15px;
        border-radius: 12px 12px 0 0;
      }
      #phone-screen.dark-mode .memory-card .header .date,
      #phone-screen.dark-mode .memory-card .header .author,
      #phone-screen.dark-mode .memory-card .content {
        color: #e0e0e0;
      }
      #phone-screen.dark-mode #api-settings-screen,
      #phone-screen.dark-mode #font-settings-screen,
      #phone-screen.dark-mode #wallpaper-screen,
      #phone-screen.dark-mode #contact-picker-screen,
      #phone-screen.dark-mode #member-management-screen,
      #phone-screen.dark-mode #world-book-editor-screen,
      #phone-screen.dark-mode #world-book-list,
      #phone-screen.dark-mode .list-item:hover,
      #phone-screen.dark-mode .list-container,
      #phone-screen.dark-mode .form-container {
        background-color: #000000;
      }
      #phone-screen.dark-mode .form-group input,
      #phone-screen.dark-mode .form-group select,
      #phone-screen.dark-mode .form-group textarea {
        background-color: #1c1c1e;
        color: #ffffff;
        border-color: #38383a;
      }
      #phone-screen.dark-mode .form-button-secondary {
        background-color: #333;
        border-color: #555;
        color: #fff;
      }
      #phone-screen.dark-mode .qzone-post-item .post-nickname,
      #phone-screen.dark-mode .qzone-post-item .post-content {
        color: #f0f0f0;
      }
      #phone-screen.dark-mode .favorite-item-card .fav-card-header .name,
      #phone-screen.dark-mode .favorite-item-card .fav-card-content {
        color: #f0f0f0;
      }
      #phone-screen.dark-mode .favorite-item-card .fav-card-header .source {
        color: #8d8d92;
      }
      #phone-screen.dark-mode .search-bar-container {
        background-color: #000000;
      }
      #phone-screen.dark-mode #favorites-search-input {
        background-color: #1c1c1e;
        border-color: #38383a;
        color: #ffffff;
      }
      #phone-screen.dark-mode #favorites-search-input::placeholder {
        color: #8d8d92;
      }
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 51px;
        height: 31px;
      }
      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #e9e9eb;
        transition: 0.4s;
        border-radius: 34px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 27px;
        width: 27px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }
      input:checked + .slider {
        background-color: #34c759;
      }
      input:checked + .slider:before {
        transform: translateX(20px);
      }
      #reply-preview-bar {
        display: none;
        padding: 8px 12px;
        margin: 0 8px 8px 8px;
        background-color: rgba(0, 0, 0, 0.05);
        border-left: 3px solid var(--accent-color);
        border-radius: 6px;
        position: relative;
        font-size: 13px;
        color: var(--text-secondary);
      }
      #phone-screen.dark-mode #reply-preview-bar {
        background-color: rgba(255, 255, 255, 0.1);
      }
      .reply-preview-content .sender {
        font-weight: 600;
        color: var(--text-primary);
      }
      .reply-preview-content .text {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: block;
        max-width: 95%;
      }
      #cancel-reply-btn {
        position: absolute;
        top: 50%;
        right: 8px;
        transform: translateY(-50%);
        width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.1);
        cursor: pointer;
        font-size: 14px;
      }
      .quoted-message {
        padding: 6px 10px;
        margin-bottom: 6px;
        background-color: rgba(0, 0, 0, 0.04);
        border-left: 2px solid var(--accent-color);
        border-radius: 4px;
        font-size: 0.9em;
        opacity: 0.8;
      }
      #phone-screen.dark-mode .quoted-message {
        background-color: rgba(255, 255, 255, 0.08);
        border-left-color: #a0cff1;
      }
      .quoted-message .quoted-sender {
        font-weight: 600;
        color: var(--accent-color);
      }
      #phone-screen.dark-mode .quoted-message .quoted-sender {
        color: #a0cff1;
      }
      .quoted-message .quoted-content {
        color: var(--text-secondary);
        white-space: normal;
        word-break: break-word;
        display: block;
      }
      #font-preview {
        transition:
          background-color 0.3s,
          border-color 0.3s;
        padding: 20px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: #f9f9f9;
      }
      #font-preview p {
        color: var(--text-primary);
      }
      #phone-screen.dark-mode #font-preview {
        background-color: #1c1c1e;
        border-color: #38383a;
      }
      #phone-screen.dark-mode #font-preview p {
        color: #ffffff;
      }
      .transfer-actions-content {
        background-color: #fff0f5;
        border-radius: 20px;
        width: 290px;
        padding: 20px;
        box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3);
        text-align: center;
        position: relative;
        border: 1px solid #ffcce0;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }
      .transfer-actions-header {
        font-size: 20px;
        font-weight: bold;
        color: #a35c7b;
        margin-bottom: 15px;
      }
      .transfer-actions-body p {
        font-size: 15px;
        color: #555;
        margin: 0 0 25px 0;
        line-height: 1.5;
      }
      .transfer-actions-footer {
        display: flex;
        justify-content: space-between;
        gap: 15px;
      }
      .transfer-actions-footer .action-btn {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 12px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition:
          transform 0.2s,
          box-shadow 0.2s;
        color: white;
      }
      .transfer-actions-footer .action-btn:active {
        transform: scale(0.95);
      }
      .transfer-actions-footer .action-btn.accept {
        background: linear-gradient(135deg, #ff85b3, #ff69b4);
        box-shadow: 0 4px 10px rgba(255, 105, 180, 0.4);
      }
      .transfer-actions-footer .action-btn.decline {
        background: linear-gradient(135deg, #c2c2c2, #a0a0a0);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      .transfer-actions-content .cancel-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: none;
        background-color: rgba(0, 0, 0, 0.1);
        color: #a35c7b;
        font-size: 20px;
        line-height: 28px;
        cursor: pointer;
      }
      .unread-count-wrapper {
        flex-shrink: 0;
        width: 40px;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding-top: 20px;
      }
      .unread-count {
        min-width: 20px;
        height: 20px;
        padding: 0 6px;
        background-color: #ff3b30;
        color: white;
        font-size: 13px;
        font-weight: 500;
        line-height: 20px;
        text-align: center;
        border-radius: 10px;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
        display: none;
        justify-content: center;
        align-items: center;
      }
      #call-history-screen {
        background-color: #f0f2f5;
      }
      .call-record-card {
        background-color: var(--secondary-bg);
        border-radius: 12px;
        padding: 15px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        cursor: pointer;
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
        border-left: 5px solid var(--accent-color);
      }
      .call-record-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
      }
      .call-record-card .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 13px;
        color: var(--text-secondary);
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid var(--border-color);
      }
      .call-record-card .card-header .duration {
        font-weight: 500;
        color: var(--text-primary);
      }
      .call-record-card .participants-avatars {
        display: flex;
        align-items: center;
      }
      .call-record-card .participant-avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid white;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .call-record-card .participant-avatar:not(:first-child) {
        margin-left: -12px;
      }
      #transcript-modal-body {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 15px;
      }
      .transcript-entry {
        padding: 8px 12px;
        border-radius: 10px;
        max-width: 85%;
        line-height: 1.5;
        word-break: break-word;
      }
      .transcript-entry.user {
        background-color: #dcf8c6;
        align-self: flex-end;
      }
      .transcript-entry.assistant {
        background-color: #ffffff;
        align-self: flex-start;
      }
      #chat-list-title {
        cursor: pointer;
      }
      .call-record-card .card-body {
        display: flex;
        align-items: center;
        flex-direction: column;
        gap: 8px;
      }
      .call-record-card .custom-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-primary);
        padding-bottom: 8px;
        border-bottom: 1px solid var(--border-color);
        margin-bottom: 4px;
      }
      .call-record-card .participants-info {
        display: flex;
        align-items: center;
      }
      .call-record-card .participants-names {
        margin-left: 12px;
        font-weight: 500;
        color: var(--text-secondary);
        font-size: 14px;
      }
      .voice-transcript {
        background-color: rgba(0, 0, 0, 0.04);
        color: var(--text-secondary);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 14px;
        line-height: 1.6;
        position: relative;
        text-align: justify;
        margin-top: 6px;
        display: none;
        word-break: break-word;
      }
      #phone-screen.dark-mode .voice-transcript {
        background-color: rgba(255, 255, 255, 0.1);
      }
      .loading-spinner {
        display: none;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(0, 0, 0, 0.2);
        border-top-color: var(--accent-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 8px;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      #shared-history-viewer-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
        padding: 15px;
      }
      #music-player-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 50;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        background-color: rgba(0, 0, 0, 0.3);
        padding-top: 60px;
        opacity: 0;
        visibility: hidden;
        transform: translateY(-50px);
        transition:
          opacity 0.4s ease-out,
          transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      #music-player-overlay.visible {
        display: flex;
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
      }
      .music-player-window {
        width: 70%;
        background-color: rgba(255, 255, 255, 0.6);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-radius: 25px;
        box-shadow: 0 8px 32px 0 rgba(25, 25, 25, 0.37);
        border: 1px solid rgba(255, 255, 255, 0.18);
        padding: 25px;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: #1f1f1f;
        position: relative;
        min-height: 420px;
        justify-content: space-between;
        padding-bottom: 15px;
      }
      .music-player-top-actions {
        position: absolute;
        top: 15px;
        left: 15px;
        right: 15px;
        width: calc(100% - 30px);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .top-left-cluster {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      #music-return-btn,
      #music-exit-btn {
        background: none;
        border: none;
        font-size: 28px;
        font-weight: 300;
        cursor: pointer;
        color: #555;
        padding: 5px;
        line-height: 1;
      }
      #music-exit-btn {
        background-color: transparent;
        color: #555;
        margin-right: 5px;
        font-size: 24px;
        font-weight: 400;
      }
      .music-progress-bar-container {
        width: 100%;
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 25px;
        margin-bottom: 10px;
      }
      .time-display {
        font-size: 11px;
        color: #888;
        width: 35px;
        text-align: center;
        flex-shrink: 0;
        font-family: "SF Mono", "Menlo", monospace;
      }
      .progress-bar {
        flex-grow: 1;
        height: 5px;
        background-color: #e5e5e5;
        border-radius: 2.5px;
        cursor: pointer;
      }
      .progress-bar-fill {
        width: 0%;
        height: 100%;
        background-color: #333;
        border-radius: 2.5px;
      }
      #music-lyrics-container {
        width: 100%;
        height: 192px;
        overflow: hidden;
        position: relative;
        -webkit-mask-image: linear-gradient(
          transparent,
          black 20%,
          black 80%,
          transparent
        );
        mask-image: linear-gradient(
          transparent,
          black 20%,
          black 80%,
          transparent
        );
      }
      #music-lyrics-list {
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
      }
      .lyric-line {
        padding: 4px 0;
        font-size: 14px;
        color: #666;
        text-align: center;
        line-height: 1.5;
        transition: all 0.5s ease;
        opacity: 0.7;
        transform: scale(0.95);
      }
      .lyric-line.active {
        font-size: 16px;
        color: #000;
        opacity: 1;
        transform: scale(1);
      }
      .music-player-controls-wrapper {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .music-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 20px;
        width: 100%;
        margin-bottom: 30px;
        margin-top: 0;
      }
      #music-return-btn,
      #music-exit-btn,
      #music-playlist-btn {
        position: relative;
      }
      #music-return-btn {
        background-color: transparent;
        color: #555;
        margin-left: 5px;
        top: -2px;
      }
      #music-playlist-btn {
        position: absolute;
        top: -3px;
        right: 15px;
        font-size: 24px;
        cursor: pointer;
        color: #333;
      }
      .playlist-item-actions {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      .playlist-action-btn {
        font-size: 18px;
        color: #888;
        cursor: pointer;
        transition: color 0.2s;
      }
      .playlist-action-btn:hover {
        color: #000;
      }
      .delete-track-btn {
        font-size: 24px;
        color: #ff3b30;
      }
      .delete-track-btn:hover {
        color: #c00;
      }
      .lyrics-btn {
        font-weight: 500;
      }
      .message-bubble .avatar {
        width: 34px;
        height: 34px;
        border-radius: 20%;
        object-fit: cover;
        flex-shrink: 0;
      }
      #phone-screen.dark-mode .recalled-message-placeholder {
        background-color: rgba(255, 255, 255, 0.15);
      }
      @keyframes recall-animation {
        from {
          opacity: 1;
          transform: scale(1);
        }
        to {
          opacity: 0;
          transform: scale(0.8);
        }
      }
      .message-wrapper.recalled-animation {
        animation: recall-animation 0.3s ease-out forwards;
      }
      .recalled-message-placeholder {
        align-self: center;
        padding: 4px 12px;
        margin: 5px 0;
        background-color: rgba(0, 0, 0, 0.1);
        color: var(--text-secondary);
        font-size: 12px;
        border-radius: 10px;
        text-align: center;
        max-width: 80%;
        cursor: pointer;
        white-space: nowrap;
        display: inline-block;
      }
      .world-book-group-container {
        border-bottom: 1px solid var(--border-color);
      }
      .world-book-group-container:first-child {
        border-top: 1px solid var(--border-color);
      }
      .world-book-group-header {
        display: flex;
        align-items: center;
        padding: 12px 15px;
        cursor: pointer;
        background-color: #f7f7f7;
      }
      .world-book-group-header .arrow {
        font-size: 14px;
        margin-right: 8px;
        transition: transform 0.2s ease;
      }
      .world-book-group-header.collapsed .arrow {
        transform: rotate(-90deg);
      }
      .world-book-group-header .group-name {
        font-weight: 600;
        font-size: 15px;
      }
      .world-book-group-content {
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out;
      }
      .world-book-group-content.collapsed {
        max-height: 0;
      }
      .frame-tabs {
        display: flex;
        background-color: #f0f0f0;
        padding: 4px;
        margin: 15px;
        border-radius: 8px;
      }
      .frame-tab {
        flex: 1;
        text-align: center;
        padding: 8px;
        font-size: 14px;
        font-weight: 500;
        color: #555;
        cursor: pointer;
        border-radius: 6px;
        transition: all 0.2s ease-in-out;
      }
      .frame-tab.active {
        background-color: #ffffff;
        color: #000000;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      .wb-category-header {
        display: flex;
        align-items: center;
        padding: 10px 12px;
        cursor: pointer;
        background-color: #f0f2f5;
        font-weight: 600;
      }
      #phone-screen.dark-mode .wb-category-header {
        background-color: #2c2c2e;
      }
      .wb-category-header .arrow {
        font-size: 12px;
        margin-right: 8px;
        transition: transform 0.2s ease;
      }
      .wb-category-header.collapsed .arrow {
        transform: rotate(-90deg);
      }
      .wb-book-container {
        padding-left: 20px;
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out;
      }
      .wb-book-container.collapsed {
        max-height: 0;
      }
      .wb-book-container label {
        padding: 8px 12px;
      }
      .wb-category-header > span:last-of-type {
        font-size: 14px;
        font-weight: 700;
        color: var(--text-primary);
      }
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 1)
        .arrow {
        color: #007bff;
      }
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 2)
        .arrow {
        color: #28a745;
      }
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 3)
        .arrow {
        color: #fd7e14;
      }
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 4)
        .arrow {
        color: #6f42c1;
      }
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 5)
        .arrow {
        color: #dc3545;
      }
      #world-book-checkboxes-container
        .wb-category-header:nth-of-type(6n + 6)
        .arrow {
        color: #ffc107;
      }
      #video-call-floating-bubble {
        position: absolute;
        right: 20px;
        top: 150px;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        overflow: hidden;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        z-index: 999;
        cursor: pointer;
        border: 3px solid white;
        transition: transform 0.2s;
      }
      #video-call-floating-bubble:active {
        transform: scale(0.95);
      }
      #video-floating-avatar {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      #api-configs-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .api-config-item {
        background-color: var(--secondary-bg);
        border: 1px solid var(--border-color);
        border-radius: 10px;
        padding: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      #phone-screen.dark-mode .api-config-item {
        background-color: #2c2c2e;
      }
      .api-config-item .config-main {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-grow: 1;
        overflow: hidden;
      }
      .api-config-item input[type="radio"] {
        width: 20px;
        height: 20px;
        flex-shrink: 0;
        accent-color: var(--accent-color);
      }
      .api-config-item .config-details {
        display: flex;
        flex-direction: column;
        gap: 2px;
        overflow: hidden;
      }
      .api-config-item .config-name {
        font-weight: 600;
        color: var(--text-primary);
        font-size: 15px;
      }
      .api-config-item .config-url {
        font-size: 12px;
        color: var(--text-secondary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .api-config-item .config-actions {
        display: flex;
        gap: 8px;
        flex-shrink: 0;
      }
      .api-config-item .config-actions button {
        padding: 5px 10px;
        font-size: 12px;
        border-radius: 5px;
        cursor: pointer;
        border: 1px solid transparent;
      }
      .api-config-item .config-actions .edit-btn {
        background-color: #e7f3ff;
        color: var(--accent-color);
      }
      .api-config-item .config-actions .delete-btn {
        background-color: #ffebee;
        color: #c62828;
      }
      .form-group-flex {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      #phone-screen.dark-mode #world-book-list .list-item,
      #phone-screen.dark-mode #world-book-list .list-item .item-title,
      #phone-screen.dark-mode #world-book-list .list-item .item-content,
      #phone-screen.dark-mode .wb-book-container label,
      #phone-screen.dark-mode .wb-category-header {
        text-shadow: none !important;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        transform: translateZ(0);
      }
      body.dark-mode .modal-content,
      body.dark-mode .transfer-actions-content,
      body.dark-mode .battery-alert-content {
        background-color: #1c1c1e !important;
        color: #ffffff !important;
        border: 1px solid #38383a !important;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8) !important;
      }
      body.dark-mode .modal-header {
        border-bottom-color: #38383a !important;
        color: #fff !important;
      }
      body.dark-mode .modal-footer {
        border-top-color: #38383a !important;
      }
      body.dark-mode .modal-footer button {
        background-color: #2c2c2e !important;
        color: #fff !important;
        border: 1px solid #38383a !important;
      }
      body.dark-mode .modal-footer button.save,
      body.dark-mode .modal-footer .confirm-btn {
        background-color: var(--accent-color) !important;
        color: #fff !important;
        border: none !important;
      }
      body.dark-mode .modal-footer .cancel,
      body.dark-mode #custom-modal-cancel {
        color: #ff453a !important;
      }
      body.dark-mode input[type="text"],
      body.dark-mode input[type="number"],
      body.dark-mode input[type="password"],
      body.dark-mode input[type="datetime-local"],
      body.dark-mode textarea,
      body.dark-mode select,
      body.dark-mode .select-box {
        background-color: #2c2c2e !important;
        color: #ffffff !important;
        border: 1px solid #38383a !important;
      }
      body.dark-mode ::placeholder {
        color: #666;
      }
      body.dark-mode .form-group label {
        color: #aaaaaa !important;
      }
      body.dark-mode .select-box .arrow-down {
        color: #aaa;
      }
      body.dark-mode .checkboxes-container {
        background-color: #2c2c2e;
        border-color: #38383a;
      }
      body.dark-mode .checkboxes-container label:hover {
        background-color: #3a3a3c;
      }
      body.dark-mode #reset-theme-btn,
      body.dark-mode #reset-custom-css-btn,
      body.dark-mode #reset-frame-color-btn,
      body.dark-mode .avatar-upload button,
      body.dark-mode #manage-groups-btn,
      body.dark-mode #manage-members-btn,
      body.dark-mode #manage-ai-avatar-library-btn,
      body.dark-mode #open-persona-library-btn,
      body.dark-mode #remove-bg-btn {
        background-color: #3a3a3c !important;
        color: #fff !important;
        border: 1px solid #48484a !important;
      }
      body.dark-mode .theme-selector label {
        color: #ddd;
      }
      body.dark-mode hr {
        border-top-color: #38383a !important;
        opacity: 0.5;
      }
      body.dark-mode .link-share-card {
        background-color: #2c2c2e;
        border-color: #38383a;
      }
      body.dark-mode .link-share-card .title {
        color: #fff;
      }
      body.dark-mode .link-share-card .description {
        color: #aaa;
      }
      body.dark-mode .poll-card {
        background-color: #2c2c2e;
        border-color: #38383a;
        color: #fff;
      }
      body.dark-mode .poll-option-item {
        background-color: #3a3a3c;
        border-color: #48484a;
        color: #fff;
      }
      body.dark-mode .poll-footer {
        border-top-color: #38383a;
        color: #888;
      }
      body.dark-mode .message-editor-block {
        background-color: #2c2c2e;
        border-color: #38383a;
      }
      body.dark-mode .format-btn {
        background-color: #3a3a3c;
        color: #fff;
      }
      body.dark-mode #reply-preview-bar {
        background-color: rgba(255, 255, 255, 0.1);
      }
      body.dark-mode .reply-preview-content .sender {
        color: #fff;
      }
      body.dark-mode .music-player-window {
        background-color: rgba(30, 30, 30, 0.85);
        border-color: rgba(255, 255, 255, 0.1);
        color: #fff;
      }
      body.dark-mode #music-player-artist,
      body.dark-mode #music-time-counter {
        color: #aaa;
      }
      body.dark-mode .music-controls button,
      body.dark-mode #music-playlist-btn {
        color: #fff;
      }
      body.dark-mode .music-controls .play-pause-btn {
        background-color: rgba(255, 255, 255, 0.1);
      }
      body.dark-mode .lyric-line {
        color: #888;
      }
      body.dark-mode .lyric-line.active {
        color: #fff;
      }
      body.dark-mode #music-playlist-panel,
      body.dark-mode #sticker-panel {
        background-color: rgba(28, 28, 30, 0.95);
        border-top-color: #38383a;
      }
      body.dark-mode .playlist-header,
      body.dark-mode #sticker-panel-header {
        border-bottom-color: #38383a;
        color: #fff;
      }
      body.dark-mode .playlist-item {
        border-bottom-color: #38383a;
        color: #fff;
      }
      body.dark-mode .playlist-item.playing {
        background-color: rgba(255, 255, 255, 0.1);
      }
      body.dark-mode .playlist-item-info .artist {
        color: #aaa;
      }
      body.dark-mode .sticker-item {
        background-color: #3a3a3c;
        border-color: #38383a;
      }
      body.dark-mode #chat-lock-overlay {
        background-color: rgba(0, 0, 0, 0.85);
        border-top-color: #38383a;
      }
      body.dark-mode .lock-text {
        color: #ccc;
      }
      body.dark-mode .contact-picker-item,
      body.dark-mode .member-management-item {
        border-bottom-color: #38383a;
        color: #fff;
      }
      body.dark-mode #member-management-actions {
        background-color: #1c1c1e;
        border-top-color: #38383a;
      }
      body.dark-mode .api-config-item {
        background-color: #2c2c2e;
        border-color: #38383a;
      }
      body.dark-mode .api-config-item .config-name {
        color: #fff;
      }
      body.dark-mode .api-config-item .config-actions button {
        background-color: #3a3a3c;
        color: #fff;
      }
      body.dark-mode .api-config-item .config-actions .delete-btn {
        background-color: #5c1e1e;
        color: #ff9999;
      }
      body.dark-mode #red-packet-details-modal .modal-content {
        background-color: #1c1c1e !important;
      }
      body.dark-mode #rp-details-greeting {
        color: #fff !important;
      }
      body.dark-mode #rp-details-summary {
        color: #aaa !important;
        border-top-color: #38383a !important;
      }
      body.dark-mode .rp-details-item {
        border-bottom-color: #38383a;
      }
      body.dark-mode .rp-details-item .name {
        color: #fff;
      }
      body.dark-mode .rp-details-item .amount {
        color: #ddd;
      }
      body.dark-mode .frame-tabs {
        background-color: #2c2c2e;
      }
      body.dark-mode .frame-tab {
        color: #aaa;
      }
      body.dark-mode .frame-tab.active {
        background-color: #3a3a3c;
        color: #fff;
      }
      body.dark-mode .call-record-card {
        background-color: #1c1c1e;
        border: 1px solid #333;
      }
      body.dark-mode .call-record-card .custom-title {
        color: #fff;
        border-bottom-color: #333;
      }
      body.dark-mode .call-record-card .participants-names {
        color: #aaa;
      }
      body.dark-mode .transcript-entry.assistant {
        background-color: #2c2c2e;
        color: #fff;
      }
      body.dark-mode .transcript-entry.user {
        background-color: #1e4620;
        color: #fff;
      }
      body.dark-mode #custom-modal-body p {
        color: #ddd;
      }
      body.dark-mode #custom-modal-confirm {
        color: var(--accent-color);
      }
      body.dark-mode #preset-actions-modal button,
      body.dark-mode #message-actions-modal button,
      body.dark-mode #post-actions-modal button {
        background-color: #2c2c2e;
        color: #fff;
        border-bottom-color: #38383a;
      }
      body.dark-mode #preset-actions-modal button:last-child,
      body.dark-mode #message-actions-modal button:last-child,
      body.dark-mode #post-actions-modal button:last-child {
        background-color: #1c1c1e;
        margin-top: 8px;
      }
      body.dark-mode .wb-category-header > span:last-of-type,
      body.dark-mode .wb-book-container label {
        color: #fff;
      }
      body.dark-mode .custom-modal-body,
      body.dark-mode .custom-modal-body p {
        color: #e0e0e0 !important;
      }
      body.dark-mode #custom-modal .format-btn {
        background-color: #3a3a3c !important;
        color: #ffffff !important;
        border: 1px solid #48484a !important;
      }
      body.dark-mode #custom-modal .format-btn:hover {
        background-color: #48484a !important;
      }
      body.dark-mode .custom-modal-header {
        color: #ffffff !important;
        border-bottom: 1px solid #38383a !important;
      }
      body.dark-mode .custom-modal-footer {
        border-top-color: #38383a !important;
        border-top: 1px solid #38383a !important;
      }
      body.dark-mode .custom-modal-footer button:first-child {
        border-right-color: #38383a !important;
        border-right: 1px solid #38383a !important;
      }
      body.dark-mode #custom-modal input,
      body.dark-mode #custom-modal textarea {
        background-color: #2c2c2e !important;
        border: 1px solid #38383a !important;
        color: #ffffff !important;
      }
      body.dark-mode .existing-group-item .delete-group-btn {
        color: #ff453a !important;
      }
      body.dark-mode #new-category-name-input {
        background-color: #2c2c2e !important;
        border: 1px solid #38383a !important;
        color: #ffffff !important;
      }
      body.dark-mode #add-new-category-btn {
        background-color: #3a3a3c !important;
        border: 1px solid #48484a !important;
        color: #ffffff !important;
      }
      body.dark-mode #post-public-text,
      body.dark-mode #post-hidden-text,
      body.dark-mode #post-image-description {
        background-color: #2c2c2e !important;
        color: #ffffff !important;
        border: 1px solid #38383a !important;
      }
      body.dark-mode .post-mode-switcher {
        background-color: #2c2c2e !important;
        border: 1px solid #38383a;
      }
      body.dark-mode .mode-btn {
        color: #888888;
      }
      body.dark-mode .mode-btn.active {
        background-color: #3a3a3c !important;
        color: #ffffff !important;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      }
      body.dark-mode .post-image-preview-container {
        background-color: #1c1c1e !important;
        border-color: #38383a !important;
      }
      body.dark-mode #post-visibility-groups {
        background-color: #2c2c2e !important;
        color: #ffffff !important;
        border: 1px solid #38383a;
      }
      body.dark-mode .transfer-content {
        background-color: #2a1c21 !important;
        border: 1px solid #4a2c36 !important;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.9) !important;
        background-image: none !important;
      }
      body.dark-mode .transfer-header {
        color: #ff85b3 !important;
      }
      body.dark-mode .transfer-input-group input {
        background-color: #1a0f12 !important;
        color: #ffffff !important;
        border: 1px solid #4a2c36 !important;
      }
      body.dark-mode .transfer-input-group input:focus {
        border-color: #ff85b3 !important;
      }
      body.dark-mode .transfer-input-group label {
        color: #d18ca6 !important;
      }
      body.dark-mode #transfer-cancel-btn {
        background-color: #3d2b32 !important;
        color: #ff85b3 !important;
      }
      body.dark-mode #new-group-name-input {
        background-color: #2c2c2e !important;
        color: #ffffff !important;
        border: 1px solid #38383a !important;
      }
      body.dark-mode #add-new-group-btn {
        background-color: #3a3a3c !important;
        border: 1px solid #48484a !important;
        color: #ffffff !important;
      }
      body.dark-mode .existing-group-item {
        background-color: #2c2c2e !important;
        border-color: #38383a !important;
        color: #ffffff !important;
      }
      body.dark-mode #settings-preview-area {
        background-color: #000000 !important;
        border-color: #38383a !important;
      }
      body.dark-mode #settings-preview-area .message-bubble {
        color: #e0e0e0;
      }
      body.dark-mode #custom-prompt-input {
        background-color: #2c2c2e !important;
        color: #ffffff !important;
        border: 1px solid #38383a !important;
        caret-color: #0a84ff;
      }
      body.dark-mode #custom-prompt-input::placeholder {
        color: #666666 !important;
      }
      body.dark-mode #custom-modal-body {
        color: #e0e0e0 !important;
      }
      body.dark-mode #favorites-action-bar {
        background-color: rgba(25, 25, 25, 0.9) !important;
        border-top: 1px solid #38383a !important;
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
      }
      body.dark-mode #favorites-delete-selected-btn {
        background-color: #ff453a !important;
        color: #ffffff !important;
      }
      body.dark-mode #custom-modal-body,
      body.dark-mode #custom-modal-body p {
        color: #e0e0e0 !important;
      }
      body.dark-mode #custom-modal {
        background-color: #1c1c1e !important;
        box-shadow:
          0 0 0 1px #38383a,
          0 10px 40px rgba(0, 0, 0, 0.8) !important;
        color: #ffffff !important;
        border: 1px solid #38383a !important;
      }
      body.dark-mode .custom-modal-footer button {
        background-color: transparent !important;
        color: #0a84ff !important;
      }
      body.dark-mode .custom-modal-footer .confirm-btn.btn-danger {
        color: #ff453a !important;
        font-weight: 600;
      }
      #phone-screen.dark-mode #world-book-list {
        background-color: #000000 !important;
      }
      #phone-screen.dark-mode .world-book-group-content .list-item,
      #phone-screen.dark-mode #world-book-list .list-item {
        background-color: #000000 !important;
        border-bottom: 1px solid #2c2c2e !important;
      }
      #phone-screen.dark-mode .world-book-group-content .list-item:hover,
      #phone-screen.dark-mode #world-book-list .list-item:hover {
        background-color: #1c1c1e !important;
      }
      #phone-screen.dark-mode .list-item .item-title {
        color: #ffffff !important;
        font-weight: 600;
        text-shadow: none !important;
      }
      #phone-screen.dark-mode .list-item .item-content {
        color: #8d8d92 !important;
        text-shadow: none !important;
      }
      #phone-screen.dark-mode .world-book-group-header {
        background-color: #1c1c1e !important;
        border-bottom: 1px solid #2c2c2e !important;
      }
      #phone-screen.dark-mode .world-book-group-header .group-name {
        color: #e0e0e0 !important;
        font-weight: 600;
      }
      #phone-screen.dark-mode .world-book-group-header .arrow {
        color: #8d8d92 !important;
      }
      #phone-screen.dark-mode .world-book-group-container {
        border-top-color: #2c2c2e !important;
        border-bottom-color: #2c2c2e !important;
        background-color: transparent !important;
      }
      #phone-screen.dark-mode #world-book-list * {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      #phone-screen.dark-mode .message-bubble.system-bubble,
      #phone-screen.dark-mode #typing-indicator .system-bubble {
        background-color: rgba(255, 255, 255, 0.15) !important;
        box-shadow: none !important;
      }
      /* Paging Logic */
      #home-screen {
        padding: 0 !important;
        display: block !important;
      }
      .home-screen-slider {
        display: flex;
        width: 100%;
        height: 100%;
        overflow-x: auto;
        overflow-y: hidden;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        cursor: grab; /* Enable grab cursor for desktop */
      }
      .home-screen-slider:active {
        cursor: grabbing;
      }
      .home-screen-slider::-webkit-scrollbar {
        display: none;
      }
      .home-page {
        flex: 0 0 100%;
        width: 100%;
        height: 100%;
        scroll-snap-align: start;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        padding: 20px;
        padding-top: 80px;
        padding-bottom: 50px;
        box-sizing: border-box;
      }
      /* 搜索面板样式 - 移动端优先设计 */
      #chat-search-panel {
        position: absolute;
        top: 80px;
        left: 0;
        right: 0;
        padding: 8px 12px;
        background-color: rgba(247, 247, 247, 0.95);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 15;
        transform: translateY(-100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        visibility: hidden;
      }

      #chat-search-panel.visible {
        transform: translateY(0);
        visibility: visible;
      }

      body.dark-mode #chat-search-panel {
        background-color: rgba(28, 28, 30, 0.95);
      }

      #phone-screen.dark-mode #chat-search-panel {
        background-color: rgba(28, 28, 30, 0.95);
      }

      #chat-search-input {
        flex: 1;
        min-width: 0; /* 防止flex子元素溢出 */
        padding: 10px 12px;
        border: none;
        border-radius: 8px;
        background-color: var(--secondary-bg);
        font-size: 15px;
        -webkit-appearance: none; /* 移除iOS默认样式 */
      }

      body.dark-mode #chat-search-input,
      #phone-screen.dark-mode #chat-search-input {
        background-color: #2c2c2e;
        color: #fff;
      }

      #chat-search-input::placeholder {
        color: var(--text-secondary);
      }

      #chat-search-input:focus {
        outline: none;
      }

      .search-nav-btn {
        width: 36px;
        height: 36px;
        min-width: 36px; /* 确保触摸区域足够 */
        border: none;
        background: none;
        font-size: 16px;
        cursor: pointer;
        color: var(--text-primary);
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background-color 0.2s;
      }

      .search-nav-btn:active {
        background-color: rgba(0, 0, 0, 0.1);
      }

      body.dark-mode .search-nav-btn:active,
      #phone-screen.dark-mode .search-nav-btn:active {
        background-color: rgba(255, 255, 255, 0.1);
      }

      .search-nav-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      body.dark-mode .search-nav-btn,
      #phone-screen.dark-mode .search-nav-btn {
        color: #fff;
      }

      #search-result-count {
        font-size: 12px;
        color: var(--text-secondary);
        min-width: 40px;
        text-align: center;
        white-space: nowrap;
      }

      #close-search-btn {
        width: 36px;
        height: 36px;
        min-width: 36px;
        font-size: 18px;
        color: var(--text-secondary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: background-color 0.2s;
      }

      #close-search-btn:active {
        background-color: rgba(0, 0, 0, 0.1);
      }

      /* 消息高亮闪烁 */
      @keyframes message-highlight {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(255, 204, 0, 0.4); }
      }

      .message-wrapper.search-highlight {
        animation: message-highlight 0.5s ease-in-out 3;
        border-radius: 8px;
      }

      body.dark-mode .message-wrapper.search-highlight,
      #phone-screen.dark-mode .message-wrapper.search-highlight {
        animation-name: message-highlight-dark;
      }

      @keyframes message-highlight-dark {
        0%, 100% { background-color: transparent; }
        50% { background-color: rgba(255, 204, 0, 0.25); }
      }

      /* 搜索匹配文本高亮 */
      .search-match {
        background-color: rgba(255, 204, 0, 0.5);
        border-radius: 2px;
        padding: 0 2px;
      }

      .search-match.current {
        background-color: rgba(255, 165, 0, 0.7);
      }

      body.dark-mode .search-match,
      #phone-screen.dark-mode .search-match {
        background-color: rgba(255, 204, 0, 0.4);
      }

      body.dark-mode .search-match.current,
      #phone-screen.dark-mode .search-match.current {
        background-color: rgba(255, 165, 0, 0.6);
      }
    </style>
  </head>
  <body>
    <div id="phone-frame">
      <div class="notch"></div>
      <div id="phone-screen">
        <div id="status-bar">
          <span id="status-bar-time">12:00</span>
          <div id="status-bar-battery" class="battery-container">
            <span class="battery-text">--%</span>
            <div class="battery-icon">
              <div class="battery-level"></div>
            </div>
          </div>
        </div>
        <div id="video-call-floating-bubble" style="display: none">
          <img id="video-floating-avatar" src="" />
        </div>
        <div id="video-call-floating-bubble" style="display: none">
          <img id="video-floating-avatar" src="" />
        </div>
        <div id="video-call-floating-bubble" style="display: none">
          <img id="video-floating-avatar" src="" />
        </div>
        <div id="notification-bar">
          <img id="notification-avatar" src="" />
          <div id="notification-content">
            <div class="name"></div>
            <div class="message"></div>
          </div>
        </div>

        <div id="home-screen" class="screen active">
          <div class="home-screen-slider">
            <div class="home-page">
              <div id="clock-container">
                <div id="main-time">12:00</div>
                <div id="main-date">星期一, 1月1日</div>
              </div>
              <div id="app-grid">
                <!-- 第一行：放2个图标 -->
                <div class="app-row">
                  <div
                    class="app-icon"
                    onclick="showScreen('world-book-screen')"
                  >
                    <div class="icon-bg">
                      <!-- 【核心修改1】添加ID -->
                      <img
                        id="icon-img-world-book"
                        src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg"
                        alt="世界书"
                      />
                    </div>
                    <span class="label">世界书</span>
                  </div>
                  <div
                    class="app-icon"
                    onclick="showScreen('chat-list-screen')"
                  >
                    <div class="icon-bg">
                      <!-- 【核心修改2】添加ID -->
                      <img
                        id="icon-img-qq"
                        src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg"
                        alt="QQ"
                      />
                    </div>
                    <span class="label">QQ</span>
                  </div>
                </div>
                <!-- 第二行：放3个图标 -->
                <div class="app-row">
                  <div
                    class="app-icon"
                    onclick="showScreen('api-settings-screen')"
                  >
                    <div class="icon-bg">
                      <!-- 【核心修改3】添加ID -->
                      <img
                        id="icon-img-api-settings"
                        src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg"
                        alt="API设置"
                      />
                    </div>
                    <span class="label">API设置</span>
                  </div>
                  <div
                    class="app-icon"
                    onclick="showScreen('wallpaper-screen')"
                  >
                    <div class="icon-bg">
                      <!-- 【核心修改4】添加ID -->
                      <img
                        id="icon-img-wallpaper"
                        src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg"
                        alt="外观设置"
                      />
                    </div>
                    <span class="label">外观设置</span>
                  </div>
                  <div
                    class="app-icon"
                    onclick="showScreen('font-settings-screen')"
                  >
                    <div class="icon-bg">
                      <!-- 【核心修改5】添加ID -->
                      <img
                        id="icon-img-font"
                        src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg"
                        alt="字体"
                      />
                    </div>
                    <span class="label">字体</span>
                  </div>
                </div>
              </div>
            </div>
            <!-- Close .home-page -->

            <div class="home-page">
              <div
                style="
                  width: 100%;
                  height: 100%;
                  display: flex;
                  justify-content: center;
                  align-items: center;
                  flex-direction: column;
                  color: rgba(0, 0, 0, 0.3);
                  font-weight: 500;
                "
              >
                <div>更多应用敬请期待</div>
              </div>
            </div>
          </div>
          <!-- Close .home-screen-slider -->

          <div
            class="home-screen-dots"
            style="
              position: absolute;
              bottom: 20px;
              left: 0;
              width: 100%;
              display: flex;
              justify-content: center;
              gap: 8px;
              z-index: 20;
              pointer-events: none;
            "
          >
            <div
              class="dot active"
              style="
                width: 8px;
                height: 8px;
                background: rgba(255, 255, 255, 0.9);
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
                border-radius: 50%;
                opacity: 1;
                transition: opacity 0.3s;
              "
            ></div>
            <div
              class="dot"
              style="
                width: 8px;
                height: 8px;
                background: rgba(255, 255, 255, 0.9);
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
                border-radius: 50%;
                opacity: 0.4;
                transition: opacity 0.3s;
              "
            ></div>
          </div>
        </div>

        <div id="world-book-screen" class="screen">
          <div class="header">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <span>世界书</span>
            <div class="header-actions">
              <!-- 【推荐】用一个容器把按钮包起来 -->
              <span class="action-btn" id="manage-world-book-categories-btn"
                >管理分类</span
              >
              <span class="action-btn" id="add-world-book-btn">+</span>
            </div>
          </div>
          <div id="world-book-list"></div>
        </div>
        <div id="world-book-editor-screen" class="screen">
          <div class="header">
            <span class="back-btn" onclick="showScreen('world-book-screen')"
              >‹</span
            >
            <span id="world-book-editor-title">编辑世界书</span>
            <span class="save-btn" id="save-world-book-btn">保存</span>
          </div>
          <div class="form-container">
            <div class="form-group">
              <label for="world-book-name-input">书名</label>
              <input
                type="text"
                id="world-book-name-input"
                placeholder="请输入世界书的名称..."
              />
            </div>

            <div class="form-group">
              <label for="world-book-category-select">分类</label>
              <select id="world-book-category-select">
                <!-- 选项将由JS动态生成 -->
              </select>
            </div>

            <div class="form-group" style="height: 100%">
              <label for="world-book-content-input">内容</label>
              <textarea
                id="world-book-content-input"
                placeholder="在此处输入详细的世界观设定..."
              ></textarea>
            </div>
          </div>
        </div>

        <div id="api-settings-screen" class="screen">
          <div class="header">
            <span
              type="button"
              class="back-btn"
              onclick="showScreen('home-screen')"
              >‹</span
            >
            <span>API 设置</span>
            <span style="width: 30px"></span>
          </div>
          <div class="form-container">
            <div class="form-group">
              <label>API 配置管理</label>
              <div id="api-configs-list">
                <!-- API 配置列表将由 JS 动态生成 -->
              </div>
              <button
                type="button"
                class="form-button form-button-secondary"
                id="add-new-config-btn"
                style="margin-top: 15px"
              >
                + 添加新配置
              </button>
            </div>

            <hr style="margin: 20px 0; opacity: 0.3" />

            <div class="form-group form-group-flex">
              <label for="background-activity-switch" style="margin-bottom: 0">
                启用后台角色活动
                <p
                  style="
                    font-size: 12px;
                    font-weight: normal;
                    color: #ff6b6b;
                    margin-top: 5px;
                  "
                >
                  警告：此功能会显著增加API调用和费用！
                </p>
              </label>
              <input
                type="checkbox"
                id="background-activity-switch"
                style="width: auto; height: 20px"
              />
            </div>
            <div class="form-group form-group-flex" style="margin-top: 10px">
              <label for="background-interval-input" style="margin-bottom: 0">
                后台活动检测间隔 (秒)
                <p
                  style="
                    font-size: 12px;
                    font-weight: normal;
                    color: #999;
                    margin-top: 5px;
                  "
                >
                  建议值 60-300。值越大，费用越低，但角色反应越慢。
                </p>
              </label>
              <input
                type="number"
                id="background-interval-input"
                min="30"
                value="60"
                style="width: 80px; text-align: center"
              />
            </div>
            <div class="form-group form-group-flex" style="margin-top: 10px">
              <label for="block-cooldown-input" style="margin-bottom: 0">
                AI被拉黑后冷静期 (小时)
                <p
                  style="
                    font-size: 12px;
                    font-weight: normal;
                    color: #999;
                    margin-top: 5px;
                  "
                >
                  被拉黑超过这个时间后，AI才有几率重新申请好友。
                </p>
              </label>
              <input
                type="number"
                id="block-cooldown-input"
                min="0.1"
                step="0.1"
                value="1"
                style="width: 80px; text-align: center"
              />
            </div>

            <div class="form-group" style="margin-top: 20px">
              <label>后台角色活动 - 角色开关</label>
              <div id="role-activity-settings" class="settings-group"></div>
              <p style="font-size: 12px; color: #999; margin-top: 6px">
                每个角色可单独控制后台活动类型。
              </p>
            </div>

            <hr style="margin: 20px 0; opacity: 0.3" />

            <button type="button" class="form-button" id="export-data-btn">
              导出数据
            </button>
            <button type="button" class="form-button" id="import-btn">
              导入备份文件
            </button>
            <input
              id="import-data-input"
              type="file"
              accept="application/json"
              hidden
            />
          </div>
        </div>
        <div id="chat-list-screen" class="screen">
          <!-- 主头部 (只在消息列表显示) -->
          <div class="header" id="main-chat-list-header">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <span id="chat-list-title">消息</span>
            <div class="header-actions">
              <span class="action-btn" id="add-group-chat-btn" title="创建群聊"
                ><svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M21 21L19 19"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  /></svg
              ></span>
              <span class="action-btn" id="add-chat-btn">+</span>
            </div>
          </div>

          <!-- 消息列表视图 -->
          <div id="messages-view" class="chat-list-view active">
            <div id="chat-list">
              <!-- JS会在这里生成聊天列表 -->
            </div>
          </div>

          <!-- 动态界面视图 -->
          <div id="qzone-screen" class="chat-list-view">
            <div class="qzone-header">
              <span class="back-btn" id="qzone-back-btn">‹</span>
              <!-- 这个按钮现在只负责从动态返回 -->
              <span>好友动态</span>
            </div>
            <div class="qzone-content">
              <div class="qzone-profile-header">
                <div id="qzone-banner-container" class="qzone-banner-container">
                  <img
                    id="qzone-banner-img"
                    src="https://files.catbox.moe/r5heyt.gif"
                    alt="背景"
                  />
                  <input
                    type="file"
                    id="qzone-banner-input"
                    accept="image/*"
                    hidden
                  />
                </div>
                <div class="qzone-user-info">
                  <div
                    id="qzone-avatar-container"
                    class="qzone-avatar-container"
                  >
                    <img
                      id="qzone-avatar-img"
                      src="https://files.catbox.moe/q6z5fc.jpeg"
                      alt="头像"
                    />
                    <input
                      type="file"
                      id="qzone-avatar-input"
                      accept="image/*"
                      hidden
                    />
                  </div>
                  <span id="qzone-nickname">{{user}}</span>
                </div>
              </div>
              <div class="qzone-actions-bar">
                <div class="action-item" id="create-shuoshuo-btn">
                  <span>说说</span>
                </div>
                <div class="action-item" id="create-post-btn">
                  <span>动态</span>
                </div>
                <div class="action-item" id="open-album-btn">
                  <span>相册</span>
                </div>
              </div>
              <div id="qzone-posts-list"></div>
            </div>
          </div>

          <!-- 收藏界面视图 -->
          <div id="favorites-view" class="chat-list-view">
            <div class="header">
              <span class="back-btn" id="favorites-back-btn">‹</span>
              <span>我的收藏</span>
              <!-- 新增的编辑按钮 -->
              <span class="action-btn" id="favorites-edit-btn">编辑</span>
            </div>

            <!-- 【新增】搜索栏容器 -->
            <div class="search-bar-container">
              <input
                type="search"
                id="favorites-search-input"
                placeholder="搜索收藏的标题、内容或作者..."
              />
              <button
                id="favorites-search-clear-btn"
                class="search-clear-btn"
                style="display: none"
              >
                ×
              </button>
            </div>

            <div id="favorites-list" class="list-container">
              <!-- 收藏内容将由JS动态生成在这里 -->
            </div>

            <!-- 新增：收藏页底部操作栏 -->
            <div id="favorites-action-bar" style="display: none">
              <button id="favorites-delete-selected-btn" class="action-bar-btn">
                删除 (0)
              </button>
            </div>
          </div>

          <div id="memories-view" class="chat-list-view">
            <div class="header">
              <span class="back-btn" id="memories-back-btn">‹</span>
              <span>我们的回忆</span>
              <span class="action-btn" id="add-countdown-btn">+</span>
            </div>
            <div
              id="memories-list"
              class="list-container"
              style="
                padding: 15px;
                display: flex;
                flex-direction: column;
                gap: 15px;
              "
            >
              <!-- 回忆卡片将由JS动态生成在这里 -->
            </div>
          </div>

          <!-- 底部导航栏 -->
          <div id="chat-list-bottom-nav">
            <div class="nav-item active" data-view="messages-view">
              <span>消息</span>
            </div>
            <div class="nav-item" data-view="qzone-screen">
              <span>动态</span>
            </div>
            <div class="nav-item" data-view="memories-view">
              <span>回忆</span>
            </div>
            <div class="nav-item" data-view="favorites-view">
              <span>收藏</span>
            </div>
          </div>
        </div>

        <div id="album-screen" class="screen">
          <!-- 1. 页面头部，包含返回按钮和标题 -->
          <div class="header">
            <span class="back-btn" id="album-back-btn">‹</span>
            <span>我的相册</span>
            <span class="action-btn" id="create-album-btn-page">+</span>
          </div>

          <!-- 2. 页面内容容器 -->
          <div class="list-container">
            <div id="album-grid-page">
              <!-- 相册列表将由 JS 动态生成在这里 -->
            </div>
          </div>
        </div>

        <div id="album-photos-screen" class="screen">
          <!-- 1. 页面头部 -->
          <div class="header">
            <span class="back-btn" id="album-photos-back-btn">‹</span>
            <span id="album-photos-title">相册名称</span>
            <span class="action-btn" id="album-upload-photo-btn">上传</span>
          </div>

          <!-- 2. 页面内容容器 -->
          <div class="list-container">
            <div id="photos-grid-page">
              <!-- 照片列表将由 JS 动态生成在这里 -->
            </div>

            <div id="photo-viewer-modal" class="modal">
              <!-- 1. 关闭按钮 -->
              <button id="photo-viewer-close-btn">×</button>

              <!-- 2. 上一张照片按钮 -->
              <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>

              <!-- 3. 图片容器 -->
              <div class="photo-viewer-content">
                <img id="photo-viewer-image" src="" alt="全屏照片预览" />
              </div>

              <!-- 4. 下一张照片按钮 -->
              <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
            </div>
          </div>
        </div>

        <input
          type="file"
          id="album-photo-input"
          accept="image/*"
          multiple
          hidden
        />

        <div id="chat-interface-screen" class="screen">
          <!-- 【最终修正版】Header，已将状态栏和搜索功能正确整合 -->
          <div class="header">
            <!-- 默认控件：包含标题、状态栏和常规按钮 -->
            <div class="default-controls">
              <span class="back-btn" id="back-to-list-btn">‹</span>

              <div id="chat-header-title-wrapper">
                <span id="chat-header-title">聊天对象</span>
                <div id="chat-header-status">
                  <span class="status-dot"></span>
                  <span class="status-text">在线</span>
                </div>
              </div>

              <div class="header-actions">
                <span class="action-btn" id="listen-together-btn" title="一起听"
                  ><img
                    src="https://i.postimg.cc/dV8sdNcx/210-20250618115221.png"
                    alt="一起听"
                /></span>
                <span class="action-btn" id="chat-settings-btn" title="聊天设置"
                  ><img
                    src="https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png"
                    alt="设置"
                /></span>
              </div>
            </div>

            <!-- 多选模式控件 (保持不变) -->
            <div class="selection-controls">
              <span id="selection-cancel-btn">取消</span>
              <span id="selection-count"></span>
              <div class="header-actions">
                <span id="selection-favorite-btn" class="action-btn">收藏</span>
                <span id="selection-share-btn" class="action-btn">分享</span>
                <span
                  id="selection-delete-btn"
                  class="action-btn"
                  style="color: #ff3b30"
                  >删除</span
                >
              </div>
            </div>
          </div>

          <!-- 搜索面板 -->
          <div id="chat-search-panel">
            <input 
              type="search" 
              id="chat-search-input" 
              placeholder="搜索消息..." 
              autocomplete="off"
            />
            <span id="search-result-count">0/0</span>
            <button class="search-nav-btn" id="search-prev-btn" disabled title="上一个">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="18 15 12 9 6 15"></polyline>
              </svg>
            </button>
            <button class="search-nav-btn" id="search-next-btn" disabled title="下一个">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </button>
            <span id="close-search-btn" title="关闭搜索">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </span>
          </div>

          <!-- 聊天消息区域 (保持不变) -->
          <div id="chat-messages">
            <div id="typing-indicator">对方正在输入...</div>
          </div>

          <!-- 输入区域 (保持不变) -->
          <div id="chat-input-area">
            <div id="reply-preview-bar">
              <div class="reply-preview-content">
                <div class="sender">回复 xxx:</div>
                <div class="text">被引用的消息内容...</div>
              </div>
              <span id="cancel-reply-btn">×</span>
            </div>
            <div id="chat-input-actions-top">
              <button
                id="open-sticker-panel-btn"
                class="chat-action-icon-btn action-button"
                title="表情面板"
              >
                +
              </button>
              <button
                id="chat-search-btn"
                class="chat-action-icon-btn action-button"
                title="搜索消息"
              >
                <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="11" cy="11" r="8"></circle>
                  <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                </svg>
              </button>
              <button
                id="send-photo-btn"
                class="chat-action-icon-btn action-button"
                title="发送照片"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"
                  />
                  <circle cx="12" cy="13" r="4" />
                </svg>
              </button>
              <button
                id="upload-image-btn"
                class="chat-action-icon-btn action-button"
                title="上传图片"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  style="color: var(--text-primary)"
                >
                  <path
                    d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                  <path
                    d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  />
                </svg>
              </button>
              <button
                id="transfer-btn"
                class="chat-action-icon-btn action-button"
                title="转账"
              >
                ￥
              </button>
              <button
                id="red-packet-btn"
                class="chat-action-icon-btn action-button"
                title="发红包"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <rect x="3" y="8" width="18" height="13" rx="2" />
                  <path d="M3 10h18" />
                  <path d="M12 8V3" />
                  <circle cx="12" cy="15" r="2" fill="currentColor" />
                </svg>
              </button>
              <button
                id="voice-message-btn"
                class="chat-action-icon-btn action-button"
                title="发送语音"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"
                  />
                  <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                  <path d="M12 19v4" />
                  <path d="M8 23h8" />
                </svg>
              </button>
              <button
                id="send-waimai-request-btn"
                class="chat-action-icon-btn action-button"
                title="发起外卖请求"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"
                  />
                  <line x1="3" y1="6" x2="21" y2="6" />
                  <path d="M16 10a4 4 0 0 1-8 0" />
                </svg>
              </button>
              <button
                id="video-call-btn"
                class="chat-action-icon-btn action-button"
                title="视频通话"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <polygon points="23 7 16 12 23 17 23 7"></polygon>
                  <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                </svg>
              </button>
              <button
                id="group-video-call-btn"
                class="chat-action-icon-btn action-button"
                title="群视频通话"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                  <circle cx="9" cy="7" r="4"></circle>
                  <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                  <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                </svg>
              </button>
              <button
                id="send-poll-btn"
                class="chat-action-icon-btn action-button"
                title="发起投票"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path d="M8 6h10" />
                  <path d="M6 6h.01" />
                  <path d="M8 12h10" />
                  <path d="M6 12h.01" />
                  <path d="M8 18h10" />
                  <path d="M6 18h.01" />
                </svg>
              </button>
              <button
                id="share-link-btn"
                class="chat-action-icon-btn action-button"
                title="分享链接"
              >
                <svg
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <path
                    d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"
                  ></path>
                  <path
                    d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"
                  ></path>
                </svg>
              </button>
            </div>
            <div id="chat-input-main-row">
              <textarea
                id="chat-input"
                rows="1"
                placeholder="输入消息..."
              ></textarea>
              <div id="input-actions-wrapper">
                <button id="wait-reply-btn" title="等待回复">
                  <img
                    src="https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png"
                    alt="等待回复"
                  />
                </button>
                <button id="send-btn" class="action-button">发送</button>
              </div>
            </div>
          </div>

          <div id="chat-lock-overlay">
            <div id="chat-lock-content"></div>
          </div>

          <!-- 表情面板 (保持不变) -->
          <div id="sticker-panel">
            <div id="sticker-panel-header">
              <span class="panel-btn" id="close-sticker-panel-btn">取消</span>
              <span class="title">我的表情</span>
              <div style="display: flex; gap: 10px">
                <span class="panel-btn" id="add-sticker-btn">添加</span>
                <span class="panel-btn" id="upload-sticker-btn">上传</span>
              </div>
            </div>
            <div id="sticker-grid"></div>
          </div>
          <input
            type="file"
            id="sticker-upload-input"
            accept="image/*"
            style="display: none"
          />
          <input
            type="file"
            id="image-upload-input"
            accept="image/*"
            style="display: none"
          />

          <!-- 音乐播放器 (保持不变) -->
          <div id="music-player-overlay">
            <div class="music-player-window">
              <!-- 1. 顶部操作栏 -->
              <div class="music-player-top-actions">
                <div class="top-left-cluster">
                  <button id="music-return-btn">‹</button>
                  <button id="music-exit-btn">×</button>
                </div>
                <span id="music-playlist-btn">☰</span>
              </div>

              <!-- 2. 歌曲信息 -->
              <div id="music-time-counter">已经一起听了0.0小时</div>
              <div id="music-player-song-title">请添加歌曲</div>
              <div id="music-player-artist">...</div>

              <!-- 3. 【全新】歌词显示区域 -->
              <div id="music-lyrics-container">
                <div id="music-lyrics-list">
                  <!-- 歌词将由JS动态生成在这里 -->
                  <div class="lyric-line">♪ 暂无歌词 ♪</div>
                </div>
              </div>

              <!-- 4. 【全新】播放控制区的包裹容器 -->
              <div class="music-player-controls-wrapper">
                <!-- a. 新的iOS风格进度条 -->
                <div class="music-progress-bar-container">
                  <div id="music-current-time" class="time-display">0:00</div>
                  <div class="progress-bar">
                    <div
                      id="music-progress-fill"
                      class="progress-bar-fill"
                    ></div>
                  </div>
                  <div id="music-total-time" class="time-display">0:00</div>
                </div>

                <!-- b. 播放控制按钮 -->
                <div class="music-controls">
                  <button id="music-prev-btn">◀</button>
                  <button id="music-play-pause-btn" class="play-pause-btn">
                    ▶
                  </button>
                  <button id="music-next-btn">▶</button>
                  <button id="music-mode-btn">顺序</button>
                </div>
              </div>
            </div>
          </div>

          <div id="music-playlist-panel">
            <div class="playlist-header">
              <span class="panel-btn" id="close-playlist-btn">返回</span>
              <span>播放列表</span>
              <div>
                <span class="panel-btn" id="add-song-local-btn">本地</span>
                <span class="panel-btn" id="add-song-url-btn">URL</span>
              </div>
            </div>
            <div class="playlist-body" id="playlist-body"></div>
          </div>
          <input
            type="file"
            id="local-song-upload-input"
            accept="audio/*"
            multiple
            style="display: none"
          />
          <input
            type="file"
            id="lrc-upload-input"
            accept=".lrc"
            style="display: none"
          />
        </div>

        <div id="wallpaper-screen" class="screen">
          <div class="header">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <!-- 【核心修改1】标题改为“外观设置”，更通用 -->
            <span>外观设置</span>
            <span style="width: 30px"></span>
          </div>
          <div class="form-container">
            <!-- 壁纸设置部分保持不变 -->
            <div id="wallpaper-preview">点击下方上传</div>
            <button
              class="form-button"
              onclick="
                document.getElementById('wallpaper-upload-input').click()
              "
            >
              上传壁纸
            </button>
            <input type="file" id="wallpaper-upload-input" accept="image/*" />

            <div
              class="form-group"
              style="
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <label for="theme-toggle-switch" style="margin-bottom: 0"
                >夜间模式</label
              >
              <label class="toggle-switch">
                <input type="checkbox" id="theme-toggle-switch" />
                <span class="slider"></span>
              </label>
            </div>

            <div
              class="form-group"
              style="
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <label for="show-size-panel-toggle" style="margin-bottom: 0"
                >显示尺寸调整面板</label
              >
              <label class="toggle-switch">
                <input type="checkbox" id="show-size-panel-toggle" />
                <span class="slider"></span>
              </label>
            </div>

            <div class="form-group">
              <label for="frame-color-input">
                手机边框颜色
                <button
                  id="reset-frame-color-btn"
                  type="button"
                  style="
                    background: none;
                    border: 1px solid #ccc;
                    color: #555;
                    font-size: 12px;
                    padding: 2px 8px;
                    border-radius: 5px;
                    cursor: pointer;
                    margin-left: 10px;
                  "
                >
                  重置
                </button>
              </label>
              <div style="display: flex; align-items: center; gap: 10px">
                <input
                  type="color"
                  id="frame-color-input"
                  value="#ffffff"
                  style="
                    width: 50px;
                    height: 40px;
                    padding: 0;
                    border: none;
                    cursor: pointer;
                  "
                />
                <span id="frame-color-value" style="font-family: monospace"
                  >#ffffff</span
                >
              </div>
            </div>

            <!-- 【核心修改2】新增图标设置区域 -->
            <hr style="width: 80%; opacity: 0.3; margin: 30px 0" />
            <div style="width: 100%; text-align: left; margin-bottom: 15px">
              <label style="font-weight: 500; color: var(--text-secondary)"
                >App 图标设置</label
              >
            </div>
            <div id="icon-settings-grid">
              <!-- 图标设置项将由JS动态生成在这里 -->
            </div>

            <!-- 【核心修改3】按钮文字也改一下 -->
            <button
              class="form-button"
              id="save-wallpaper-btn"
              style="margin-top: 30px"
            >
              保存所有外观设置
            </button>
          </div>
        </div>

        <div id="browser-screen" class="screen">
          <div class="header">
            <span class="back-btn" id="browser-back-btn">‹</span>
            <span id="browser-title"></span>
            <span style="width: 30px"></span>
          </div>
          <div id="browser-content" class="list-container">
            <!-- 文章内容将由JS动态生成在这里 -->
          </div>
        </div>

        <div id="font-settings-screen" class="screen">
          <div class="header">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <span>字体设置</span>
            <span style="width: 30px"></span>
          </div>
          <div class="form-container">
            <div class="form-group">
              <label for="font-url-input"
                >字体文件URL (.ttf, .otf, .woff等)</label
              >
              <input
                type="text"
                id="font-url-input"
                placeholder="https://..../font.ttf"
              />
            </div>

            <div class="form-group">
              <label>实时预览</label>
              <div id="font-preview">
                <p style="font-size: 20px; margin: 0 0 10px 0">
                  你好世界 Hello World
                </p>
                <p style="margin: 0">这是字体预览效果，12345。</p>
              </div>
            </div>

            <button class="form-button" id="save-font-btn">保存并应用</button>
            <button
              class="form-button form-button-secondary"
              id="reset-font-btn"
            >
              恢复默认字体
            </button>
          </div>
        </div>

        <div id="contact-picker-screen" class="screen">
          <div class="header">
            <span class="back-btn" id="cancel-contact-picker-btn">取消</span>
            <span>选择联系人</span>
            <span class="save-btn" id="confirm-contact-picker-btn"
              >完成(0)</span
            >
          </div>
          <div class="list-container" id="contact-picker-list">
            <!-- 联系人列表将由JS动态生成 -->
          </div>
        </div>

        <div id="member-management-screen" class="screen">
          <div class="header">
            <span class="back-btn" id="back-from-member-management">‹</span>
            <span>群成员管理</span>
            <span style="width: 30px"></span>
          </div>
          <div class="list-container" id="member-management-list">
            <!-- 现有成员列表会在这里动态生成 -->
          </div>
          <div id="member-management-actions">
            <button id="add-existing-contact-btn">从好友列表添加</button>
            <button id="create-new-member-btn">创建群内新成员</button>
          </div>
        </div>

        <div id="incoming-call-modal" class="modal">
          <div class="incoming-call-content">
            <img id="caller-avatar" class="caller-avatar" src="" />
            <div id="caller-name" class="caller-name"></div>
            <div class="caller-text">邀请你视频通话</div>
            <div class="incoming-call-actions">
              <div class="action-button-wrapper">
                <button
                  id="decline-call-btn"
                  class="call-action-btn decline"
                ></button>
                <span>拒绝</span>
              </div>
              <div class="action-button-wrapper">
                <button
                  id="accept-call-btn"
                  class="call-action-btn accept"
                ></button>
                <span>接听</span>
              </div>
            </div>
          </div>
        </div>

        <div id="video-call-screen" class="screen">
          <div
            id="text-call-interface"
            style="
              display: flex;
              flex-direction: column;
              height: 100%;
              width: 100%;
            "
          >
            <!-- 1. 顶部栏 (保持不变) -->
            <div class="video-call-top-bar">
              <span id="call-timer">00:00</span>
            </div>

            <!-- 2. 【升级】参与者头像网格区域 -->
            <div class="video-call-avatar-area">
              <div id="participant-avatars-grid">
                <!-- JS会在这里动态生成头像 -->
              </div>
            </div>

            <!-- 3. 对话框区域 (保持不变) -->
            <div id="video-call-main" class="video-call-main">
              <!-- 对话内容会动态生成在这里 -->
            </div>

            <!-- 4. 【升级】底部控制栏，现在包含一个“加入”按钮 -->
            <div class="video-call-controls">
              <button
                id="user-speak-btn"
                class="control-btn speak-btn"
              ></button>
              <button id="hang-up-btn" class="control-btn hangup-btn"></button>
              <!-- 这个按钮默认隐藏，只在用户“旁观”时显示 -->
              <button
                id="join-call-btn"
                class="control-btn join-btn"
                style="display: none"
              ></button>
            </div>
          </div>
        </div>

        <div id="outgoing-call-screen" class="screen">
          <div class="outgoing-call-content">
            <img id="outgoing-call-avatar" class="caller-avatar" src="" />
            <div id="outgoing-call-name" class="caller-name"></div>
            <div class="caller-text">正在呼叫...</div>
            <div class="outgoing-call-actions">
              <button
                id="cancel-call-btn"
                class="call-action-btn decline"
              ></button>
              <span>取消</span>
            </div>
          </div>
        </div>

        <div id="call-history-screen" class="screen">
          <div class="header">
            <span class="back-btn" id="call-history-back-btn">‹</span>
            <span id="call-history-title">通话记录</span>
            <span style="width: 30px"></span>
            <!-- 占位符，保持标题居中 -->
          </div>
          <div
            id="call-history-list"
            class="list-container"
            style="
              padding: 15px;
              display: flex;
              flex-direction: column;
              gap: 15px;
            "
          >
            <!-- 通话记录卡片将由JS动态生成在这里 -->
          </div>
        </div>
      </div>
    </div>

    <div id="chat-settings-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header"><span>聊天设置</span></div>
        <div class="modal-body">
          <div class="form-group" id="chat-name-group">
            <label for="chat-name-input">备注名 / 群名</label
            ><input type="text" id="chat-name-input" />
          </div>

          <div class="form-group" id="ai-remark-group" style="display: none">
            <label for="ai-remark-input">AI备注 (仅自己可见)</label>
            <input
              type="text"
              id="ai-remark-input"
              placeholder="例如：贴心小棉袄"
            />
          </div>

          <div
            class="form-group"
            id="assign-group-section"
            style="display: none"
          >
            <!-- 默认隐藏，只对单聊显示 -->
            <label for="assign-group-select">好友分组</label>
            <div style="display: flex; align-items: center; gap: 10px">
              <select id="assign-group-select" style="flex-grow: 1">
                <!-- 分组选项将由JS动态生成 -->
              </select>
              <button
                id="manage-groups-btn"
                class="form-button-secondary"
                style="margin-top: 0; padding: 12px"
              >
                管理分组
              </button>
            </div>
          </div>

          <div class="form-group" id="my-group-nickname-group">
            <label for="my-group-nickname-input">我的群昵称</label
            ><input type="text" id="my-group-nickname-input" />
          </div>
          <div class="form-group" id="group-avatar-group">
            <label>群头像</label>
            <div class="avatar-upload">
              <img id="group-avatar-preview" /><button
                onclick="document.getElementById('group-avatar-input').click()"
              >
                上传群头像</button
              ><input type="file" id="group-avatar-input" accept="image/*" />
            </div>
          </div>
          <div class="form-group" id="world-book-link-group">
            <label>关联世界书 (可多选)</label>
            <div class="custom-multiselect">
              <div class="select-box">
                <span class="selected-options-text">-- 点击选择 --</span>
              </div>
              <div
                id="world-book-checkboxes-container"
                class="checkboxes-container"
              ></div>
            </div>
          </div>
          <div class="form-group" id="ai-persona-group">
            <label for="ai-persona">对方人设 (AI Persona)</label
            ><textarea id="ai-persona" rows="3"></textarea>
          </div>
          <div class="form-group" id="ai-avatar-group">
            <label>对方头像</label>
            <div class="avatar-upload">
              <img id="ai-avatar-preview" /><button
                onclick="document.getElementById('ai-avatar-input').click()"
              >
                上传对方头像</button
              ><button id="manage-ai-avatar-library-btn">管理头像库</button>
              <input type="file" id="ai-avatar-input" accept="image/*" />
            </div>
          </div>

          <div class="form-group" id="video-call-settings-group">
            <hr style="opacity: 0.2; margin: 15px 0" />

            <label
              style="
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-top: 15px;
              "
            >
              <span>语音接入 (Minimax)</span>
              <input
                type="checkbox"
                id="video-call-voice-access-switch"
                style="width: auto"
              />
            </label>
          </div>
          <div class="form-group" id="my-persona-group">
            <label for="my-persona">我的人设 (My Persona)</label
            ><textarea id="my-persona" rows="3"></textarea>
          </div>
          <div class="form-group" id="my-avatar-group">
            <label>我的头像</label>
            <div class="avatar-upload">
              <img id="my-avatar-preview" /><button
                onclick="document.getElementById('my-avatar-input').click()"
              >
                上传我的头像</button
              ><button id="open-persona-library-btn">预设</button
              ><input type="file" id="my-avatar-input" accept="image/*" />
            </div>
          </div>
          <div class="form-group" id="group-members-group">
            <label>群成员人设</label>
            <div id="group-members-settings"></div>

            <!-- 【新增】管理成员按钮 -->
            <button
              id="manage-members-btn"
              class="form-button form-button-secondary"
              style="margin-top: 15px"
            >
              管理群成员
            </button>
          </div>
          <div class="form-group">
            <label for="max-memory">上下文记忆条数</label
            ><input type="number" id="max-memory" value="10" />
          </div>
          <div class="form-group">
            <label
              >聊天气泡主题
              <button id="reset-theme-btn" type="button">重置</button></label
            >
            <div class="theme-selector">
              <label
                ><input
                  type="radio"
                  name="theme-select"
                  value="default"
                  id="theme-default"
                />
                默认</label
              ><label
                ><input type="radio" name="theme-select" value="pink_blue" />
                粉蓝</label
              ><label
                ><input type="radio" name="theme-select" value="blue_white" />
                蓝白</label
              ><label
                ><input
                  type="radio"
                  name="theme-select"
                  value="purple_yellow"
                />
                紫黄</label
              ><label
                ><input type="radio" name="theme-select" value="black_white" />
                黑白</label
              ><label
                ><input type="radio" name="theme-select" value="yellow_white" />
                黄白</label
              ><label
                ><input type="radio" name="theme-select" value="red_black" />
                红黑</label
              ><label
                ><input type="radio" name="theme-select" value="blue_yellow" />
                蓝黄</label
              ><label
                ><input type="radio" name="theme-select" value="pink_yellow" />
                粉黄</label
              ><label
                ><input type="radio" name="theme-select" value="pink_purple" />
                粉紫</label
              ><label
                ><input type="radio" name="theme-select" value="gray_white" />
                灰白</label
              ><label
                ><input type="radio" name="theme-select" value="blue_green" />
                蓝绿</label
              ><label
                ><input type="radio" name="theme-select" value="pink_white" />
                粉白</label
              ><label
                ><input type="radio" name="theme-select" value="pink_black" />
                粉黑</label
              ><label
                ><input type="radio" name="theme-select" value="pink_green" />
                粉绿</label
              ><label
                ><input type="radio" name="theme-select" value="green_black" />
                绿黑</label
              >
            </div>
          </div>

          <!-- Offline Mode Section -->
          <div class="form-group settings-group" id="offline-mode-settings">
            <div
              style="
                font-weight: bold;
                color: var(--accent-color);
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding-left: 10px;
              "
            >
              线下模式 (Offline Mode)
              <label class="toggle-switch">
                <input type="checkbox" id="offline-mode-toggle" />
                <span class="slider"></span>
              </label>
            </div>
            <div
              id="offline-mode-config"
              style="
                display: none;
                margin-top: 10px;
                padding: 10px;
                border-radius: 8px;
              "
            >
              <div class="form-group">
                <label>预设场景</label>
                <select
                  id="offline-preset-select"
                  class="moe-input"
                  style="
                    width: 100%;
                    padding: 8px;
                    border-radius: 6px;
                    border: 1px solid var(--border-color);
                  "
                >
                  <option value="custom">自定义 (Custom)</option>
                  <!-- JS will populate -->
                </select>
              </div>
              <div class="form-group">
                <label>场景描述 (System Prompt)</label>
                <textarea
                  id="offline-prompt-input"
                  class="moe-input"
                  rows="4"
                  style="
                    width: 100%;
                    padding: 8px;
                    border-radius: 6px;
                    border: 1px solid var(--border-color);
                  "
                ></textarea>
              </div>
              <div class="form-group">
                <label>描写风格 (Style)</label>
                <textarea
                  id="offline-style-input"
                  class="moe-input"
                  rows="2"
                  style="
                    width: 100%;
                    padding: 8px;
                    border-radius: 6px;
                    border: 1px solid var(--border-color);
                  "
                ></textarea>
              </div>
            </div>
          </div>

          <div class="form-group">
            <label for="font-size-slider"
              >聊天字体大小 <span id="font-size-value">13px</span></label
            >
            <input
              type="range"
              id="font-size-slider"
              min="12"
              max="20"
              step="1"
              value="13"
              style="width: 100%; margin-top: 8px"
            />
          </div>

          <div class="settings-row">
            <label for="user-bubble-color-picker">用户气泡颜色</label>
            <input type="color" id="user-bubble-color-picker" value="#ffffff" />
          </div>
          <div class="settings-row">
            <label for="ai-bubble-color-picker">AI气泡颜色</label>
            <input type="color" id="ai-bubble-color-picker" value="#ffffff" />
          </div>

          <div class="form-group">
            <label for="custom-css-input">
              自定义气泡样式 (CSS)
              <button
                id="reset-custom-css-btn"
                type="button"
                style="
                  background: none;
                  border: 1px solid #ccc;
                  color: #555;
                  font-size: 12px;
                  padding: 2px 8px;
                  border-radius: 5px;
                  cursor: pointer;
                  margin-left: 10px;
                "
              >
                重置
              </button>
            </label>
            <textarea
              id="custom-css-input"
              rows="5"
              style="
                width: 100%;
                margin-top: 8px;
                font-family: monospace;
                font-size: 12px;
                resize: vertical;
              "
              placeholder="/* 示例：为“我”的气泡添加渐变背景和阴影 */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"
            ></textarea>
          </div>

          <div class="form-group">
            <label>实时预览</label>
            <div id="settings-preview-area">
              <!-- JS会在这里生成预览内容 -->
            </div>
          </div>

          <div class="form-group">
            <label>聊天背景</label>
            <div class="bg-upload-container">
              <button
                type="button"
                class="form-button-secondary"
                style="width: auto; padding: 8px 12px; margin-top: 0"
                onclick="document.getElementById('bg-input').click()"
              >
                上传背景图
              </button>
              <button type="button" id="remove-bg-btn">移除背景</button>
            </div>
            <img id="bg-preview" class="bg-preview-img" />
            <input
              type="file"
              id="bg-input"
              accept="image/*"
              style="display: none"
            />
          </div>
          <div class="form-group">
            <label
              style="
                display: flex;
                justify-content: space-between;
                align-items: center;
              "
            >
              <span>长对话自动总结</span>
              <label class="toggle-switch">
                <input type="checkbox" id="summary-toggle" />
                <span class="slider"></span>
              </label>
            </label>
            <div
              id="summary-options"
              style="
                display: none;
                margin-top: 10px;
                padding-left: 10px;
                border-left: 2px solid #eee;
              "
            >
              <div style="margin-bottom: 10px">
                <label
                  style="display: block; margin-bottom: 5px; font-size: 13px"
                  >触发模式</label
                >
                <label style="margin-right: 15px; font-size: 13px">
                  <input type="radio" name="summary-mode" value="manual" />
                  手动提醒
                </label>
                <label style="font-size: 13px">
                  <input type="radio" name="summary-mode" value="auto" />
                  自动执行
                </label>
              </div>
              <div style="margin-bottom: 10px">
                <label
                  style="display: block; margin-bottom: 5px; font-size: 13px"
                  >每隔多少条消息触发</label
                >
                <input
                  type="number"
                  id="summary-count-input"
                  value="50"
                  style="width: 80px"
                />
              </div>
              <div style="margin-bottom: 10px">
                <div style="display: flex; gap: 10px; align-items: center;">
                  <button
                    id="manual-summary-btn"
                    class="form-button-secondary"
                    style="
                      flex: 1;
                      font-size: 13px;
                      padding: 6px 12px;
                      width: auto;
                      margin-top: 0;
                    "
                  >
                    立即手动总结
                  </button>
                  <button
                    id="view-summary-history-btn"
                    class="form-button-secondary"
                    style="
                      flex: 1;
                      font-size: 13px;
                      padding: 6px 12px;
                      width: auto;
                      margin-top: 0;
                    "
                  >
                    查看历史总结
                  </button>
                </div>
              </div>

              <div
                style="
                  margin-top: 15px;
                  padding-top: 10px;
                  border-top: 1px dashed #eee;
                "
              >
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 10px;
                  "
                >
                  <label
                    for="summary-custom-api-toggle"
                    style="font-size: 13px; margin-bottom: 0"
                    >使用独立API配置</label
                  >
                  <label class="toggle-switch">
                    <input type="checkbox" id="summary-custom-api-toggle" />
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div
                  id="summary-custom-api-options"
                  style="display: none; flex-direction: column; gap: 10px"
                >
                  <div>
                    <input
                      type="text"
                      id="summary-custom-api-url"
                      class="moe-input"
                      placeholder="API地址 (例如: https://api.openai.com)"
                      style="font-size: 13px; padding: 8px"
                    />
                  </div>
                  <div>
                    <input
                      type="password"
                      id="summary-custom-api-key"
                      class="moe-input"
                      placeholder="API Key (sk-...)"
                      style="font-size: 13px; padding: 8px"
                    />
                  </div>
                  <div style="display: flex; gap: 5px">
                    <select
                      id="summary-custom-model-select"
                      class="moe-input"
                      style="font-size: 13px; padding: 8px; flex-grow: 1"
                    ></select>
                    <button
                      id="summary-fetch-models-btn"
                      class="form-button-secondary"
                      style="
                        width: auto;
                        padding: 0 10px;
                        font-size: 12px;
                        margin-top: 0;
                        white-space: nowrap;
                      "
                    >
                      获取
                    </button>
                  </div>
                  <div
                    style="
                      display: flex;
                      justify-content: space-between;
                      align-items: center;
                    "
                  >
                    <label
                      for="summary-stream-toggle"
                      style="font-size: 13px; margin-bottom: 0"
                      >流式请求</label
                    >
                    <label class="toggle-switch">
                      <input type="checkbox" id="summary-stream-toggle" />
                      <span class="toggle-slider"></span>
                    </label>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <hr
            style="margin: 25px 0; border: none; border-top: 1px solid #eee"
          />
          <button
            class="form-button form-button-secondary"
            id="block-chat-btn"
            style="
              background-color: #ff3b30;
              color: white;
              border-color: #ff3b30;
            "
          >
            拉黑对方
          </button>
          <button class="form-button form-button-secondary" id="clear-chat-btn">
            清空聊天记录
          </button>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-chat-settings-btn">取消</button
          ><button class="save" id="save-chat-settings-btn">保存</button>
        </div>
      </div>
    </div>

    <div id="persona-library-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span>我的人设库</span
          ><button id="add-persona-preset-btn" class="action-button">
            添加
          </button>
        </div>
        <div class="modal-body"><div id="persona-library-grid"></div></div>
        <div class="modal-footer">
          <button class="cancel" id="close-persona-library-btn">关闭</button>
        </div>
      </div>
    </div>

    <div id="persona-editor-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span id="persona-editor-title">添加人设预设</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>预设头像</label>
            <div class="avatar-upload">
              <img id="preset-avatar-preview" /><button
                onclick="document.getElementById('preset-avatar-input').click()"
              >
                上传头像</button
              ><input type="file" id="preset-avatar-input" accept="image/*" />
            </div>
          </div>
          <div class="form-group">
            <label for="preset-persona-input">预设人设</label
            ><textarea
              id="preset-persona-input"
              rows="4"
              placeholder="在此输入这个人设的详细设定..."
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-persona-editor-btn">取消</button
          ><button class="save" id="save-persona-preset-btn">保存</button>
        </div>
      </div>
    </div>

    <div id="member-settings-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header"><span>编辑群成员</span></div>
        <div class="modal-body">
          <div class="form-group">
            <label for="member-name-input">名字</label
            ><input type="text" id="member-name-input" />
          </div>
          <div class="form-group">
            <label for="member-persona-input">人设</label
            ><textarea id="member-persona-input" rows="4"></textarea>
          </div>
          <div class="form-group">
            <label>头像</label>
            <div class="avatar-upload">
              <img id="member-avatar-preview" /><button
                onclick="document.getElementById('member-avatar-input').click()"
              >
                上传头像</button
              ><input type="file" id="member-avatar-input" accept="image/*" />
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-member-settings-btn">取消</button
          ><button class="save" id="save-member-settings-btn">保存</button>
        </div>
      </div>
    </div>

    <div id="custom-modal-overlay">
      <div id="custom-modal">
        <div class="custom-modal-header" id="custom-modal-title"></div>
        <div class="custom-modal-body" id="custom-modal-body"></div>
        <div class="custom-modal-footer">
          <button id="custom-modal-cancel">取消</button>
          <button id="custom-modal-confirm" class="confirm-btn">确定</button>
        </div>
      </div>
    </div>

    <div id="api-config-editor-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 90%">
        <div class="modal-header">
          <span>编辑API配置</span>
        </div>
        <div class="modal-body">
          <input type="hidden" id="config-editor-id" />
          <div class="form-group">
            <label for="config-name-input">配置名称</label>
            <input
              type="text"
              id="config-name-input"
              placeholder="例如：主力模型、备用线路"
            />
          </div>
          <div class="form-group">
            <label for="config-url-input">反代地址</label>
            <input
              type="text"
              id="config-url-input"
              placeholder="例如: https://api.openai.com"
            />
          </div>
          <div class="form-group">
            <label for="config-key-input">密钥</label>
            <input type="password" id="config-key-input" placeholder="sk-..." />
          </div>
          <div class="form-group">
            <label for="config-model-select">默认模型</label>
            <select id="config-model-select"></select>
            <button
              type="button"
              class="form-button-secondary"
              id="config-fetch-models-btn"
              style="margin-top: 10px"
            >
              拉取模型列表
            </button>
          </div>
          <div
            class="form-group form-group-flex"
            style="align-items: flex-start"
          >
            <!-- Temperature -->
            <div style="flex: 1; margin-right: 10px">
              <div
                style="
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  margin-bottom: 5px;
                "
              >
                <label
                  for="config-temperature-input"
                  style="font-size: 12px; margin-bottom: 0"
                  >Temperature</label
                >
                <input
                  type="checkbox"
                  id="config-enable-temp"
                  title="启用此参数"
                />
              </div>
              <input
                type="number"
                id="config-temperature-input"
                placeholder="0.8"
                step="0.1"
                min="0"
                max="2"
              />
            </div>

            <!-- Top P -->
            <div style="flex: 1; margin-right: 10px">
              <div
                style="
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  margin-bottom: 5px;
                "
              >
                <label
                  for="config-topp-input"
                  style="font-size: 12px; margin-bottom: 0"
                  >Top P</label
                >
                <input
                  type="checkbox"
                  id="config-enable-topp"
                  title="启用此参数"
                />
              </div>
              <input
                type="number"
                id="config-topp-input"
                placeholder="1.0"
                step="0.05"
                min="0"
                max="1"
              />
            </div>

            <!-- Top K -->
            <div style="flex: 1">
              <div
                style="
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  margin-bottom: 5px;
                "
              >
                <label
                  for="config-topk-input"
                  style="font-size: 12px; margin-bottom: 0"
                  >Top K</label
                >
                <input
                  type="checkbox"
                  id="config-enable-topk"
                  title="启用此参数"
                />
              </div>
              <input
                type="number"
                id="config-topk-input"
                placeholder="40"
                step="1"
                min="1"
              />
            </div>
          </div>

          <div class="form-group form-group-flex">
            <label for="config-stream-switch" style="margin-bottom: 0"
              >启用流式传输</label
            >
            <label class="toggle-switch">
              <input type="checkbox" id="config-stream-switch" />
              <span class="slider"></span>
            </label>
          </div>
          <div class="form-group form-group-flex">
            <label for="config-hide-stream-switch" style="margin-bottom: 0"
              >隐藏流式响应</label
            >
            <label class="toggle-switch">
              <input type="checkbox" id="config-hide-stream-switch" />
              <span class="slider"></span>
            </label>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="cancel" id="cancel-config-editor-btn">
            取消
          </button>
          <button type="button" class="save" id="save-config-btn">保存</button>
        </div>
      </div>
    </div>

    <div id="preset-actions-modal" class="modal">
      <div id="custom-modal" style="width: 250px">
        <div class="custom-modal-footer">
          <button id="preset-action-edit">编辑预设</button>
          <button id="preset-action-delete" class="btn-danger">删除预设</button>
          <button
            id="preset-action-cancel"
            style="
              margin-top: 8px;
              border-radius: 8px;
              background-color: #f0f0f0;
            "
          >
            取消
          </button>
        </div>
      </div>
    </div>


    <div id="summary-history-modal" class="modal">
      <div
        class="modal-content"
        style="max-height: 80%; display: flex; flex-direction: column"
      >
        <div class="modal-header">
          <span>历史总结</span>
          <span
            id="close-summary-history-modal"
            style="cursor: pointer; font-size: 20px"
            >×</span
          >
        </div>
        <div
          class="modal-body"
          id="summary-history-list"
          style="flex: 1; overflow-y: auto; max-height: 400px"
        >
          <!-- JS动态生成 -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="close-summary-history-btn">关闭</button>
        </div>
      </div>
    </div>

    <div id="transfer-modal">
      <div class="transfer-content">
        <div class="transfer-header">给Ta一个惊喜！</div>
        <div class="transfer-input-group">
          <label for="transfer-amount">转账金额</label>
          <input
            type="number"
            id="transfer-amount"
            placeholder="0.00"
            min="0"
            max="9999"
            step="0.01"
          />
        </div>
        <div class="transfer-input-group">
          <label for="transfer-note">备注 (可选)</label>
          <input
            type="text"
            id="transfer-note"
            placeholder="留下你的小心思~"
            maxlength="20"
          />
        </div>
        <div class="transfer-actions">
          <button id="transfer-cancel-btn">取消</button>
          <button id="transfer-confirm-btn">确认转账</button>
        </div>
      </div>
    </div>

    <div id="battery-alert-modal">
      <div class="battery-alert-content">
        <img id="battery-alert-image" src="" />
        <p id="battery-alert-text"></p>
      </div>
    </div>

    <audio id="audio-player" style="display: none"></audio>

    <div id="create-post-modal" class="modal">
      <div class="modal-content" style="height: auto; max-height: 90%">
        <div class="modal-header">
          <span>发布动态</span>
        </div>
        <div class="modal-body">
          <!-- 公开文字输入区 -->
          <div class="form-group">
            <textarea
              id="post-public-text"
              rows="3"
              placeholder="分享新鲜事...（非必填的公开文字）"
            ></textarea>
          </div>

          <!-- === 模式切换开关 (新增) === -->
          <div class="post-mode-switcher">
            <button id="switch-to-image-mode" class="mode-btn active">
              上传图片
            </button>
            <button id="switch-to-text-image-mode" class="mode-btn">
              使用文字图
            </button>
          </div>

          <div class="form-group">
            <label>可见范围</label>
            <div
              id="post-visibility-options"
              style="display: flex; gap: 15px; margin-bottom: 10px"
            >
              <label
                ><input type="radio" name="visibility" value="public" checked />
                公开</label
              >

              <label
                ><input type="radio" name="visibility" value="include" />
                指定分组可见</label
              >
            </div>
            <div
              id="post-visibility-groups"
              style="
                display: none;
                max-height: 120px;
                overflow-y: auto;
                background: #f9f9f9;
                padding: 10px;
                border-radius: 8px;
              "
            >
              <!-- 分组多选框将由JS动态生成 -->
            </div>
          </div>

          <!-- === 图片模式区域 === -->
          <div id="image-mode-content" class="post-mode-content active">
            <div class="form-group">
              <div
                id="post-image-preview-container"
                class="post-image-preview-container"
              >
                <img id="post-image-preview" src="" alt="图片预览" />
                <button id="post-remove-image-btn">×</button>
              </div>
              <div class="post-image-upload-options">
                <button
                  id="post-upload-local-btn"
                  class="form-button-secondary"
                >
                  本地上传
                </button>
                <button id="post-use-url-btn" class="form-button-secondary">
                  网络URL
                </button>
                <input
                  type="file"
                  id="post-local-image-input"
                  accept="image/*"
                  hidden
                />
              </div>
            </div>
            <div
              id="post-image-desc-group"
              class="form-group"
              style="display: none"
            >
              <label>图片描述 (必填，给AI看)</label>
              <input
                type="text"
                id="post-image-description"
                placeholder="简单描述图片内容，帮助AI理解"
              />
            </div>
          </div>

          <!-- === 文字图模式区域 (新增) === -->
          <div id="text-image-mode-content" class="post-mode-content">
            <div class="form-group">
              <label>文字图 (给AI理解用的描述，点击图片后可见)</label>
              <textarea
                id="post-hidden-text"
                rows="4"
                placeholder="在这里写下图片描述..."
              ></textarea>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-create-post-btn">取消</button>
          <button class="save" id="confirm-create-post-btn">发布</button>
        </div>
      </div>
    </div>

    <div id="group-management-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>管理好友分组</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>新建分组</label>
            <div style="display: flex; gap: 10px">
              <input
                type="text"
                id="new-group-name-input"
                placeholder="输入分组名..."
                style="flex-grow: 1"
              />
              <button
                id="add-new-group-btn"
                class="form-button"
                style="width: auto; margin-top: 0; padding: 0 15px"
              >
                添加
              </button>
            </div>
          </div>
          <hr style="opacity: 0.2" />
          <div
            id="existing-groups-list"
            style="display: flex; flex-direction: column; gap: 10px"
          >
            <!-- 分组列表将由JS动态生成 -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="save" id="close-group-manager-btn" style="width: 100%">
            完成
          </button>
        </div>
      </div>
    </div>

    <div id="message-actions-modal" class="modal">
      <div id="custom-modal" style="width: 250px">
        <div class="custom-modal-footer">
          <!-- 新的操作按钮 -->
          <button id="edit-message-btn">编辑消息</button>
          <button id="copy-message-btn">复制文本</button>
          <button id="recall-message-btn">撤回</button>
          <button id="quote-message-btn">引用</button>
          <button id="select-message-btn">进入多选</button>
          <!-- 取消按钮 -->
          <button id="cancel-message-action-btn" style="border-radius: 8px">
            取消
          </button>
        </div>
      </div>
    </div>

    <div id="post-actions-modal" class="modal">
      <div id="custom-modal" style="width: 250px">
        <div class="custom-modal-footer">
          <button id="edit-post-btn">编辑动态</button>
          <button id="copy-post-btn">复制内容</button>
          <button id="cancel-post-action-btn">取消</button>
        </div>
      </div>
    </div>

    <div id="message-editor-modal" class="modal">
      <div class="modal-content" style="height: 75%">
        <div class="modal-header">
          <span>编辑与拆分消息</span>
        </div>
        <div class="modal-body" id="message-editor-body">
          <!-- 编辑器容器，JS会在这里动态生成文本框 -->
          <div id="message-editor-container"></div>
          <!-- 添加新消息的按钮 -->
          <button
            id="add-message-editor-block-btn"
            class="form-button form-button-secondary"
            style="margin-top: 15px"
          >
            [+] 添加下一条消息
          </button>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-advanced-editor-btn">取消</button>
          <button class="save" id="save-advanced-editor-btn">保存更改</button>
        </div>
      </div>
    </div>

    <div id="waimai-request-modal" class="modal">
      <div class="modal-content" style="width: 290px">
        <div class="modal-header">
          <span>发起外卖代付</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="waimai-product-info">商品信息</label>
            <input
              type="text"
              id="waimai-product-info"
              placeholder="例如：一杯杨枝甘露"
            />
          </div>
          <div class="form-group">
            <label for="waimai-amount">代付金额 (元)</label>
            <input
              type="number"
              id="waimai-amount"
              placeholder="例如：21"
              min="0"
              step="0.01"
            />
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="waimai-cancel-btn">取消</button>
          <button class="save" id="waimai-confirm-btn">发起请求</button>
        </div>
      </div>
    </div>

    <div id="create-countdown-modal" class="modal">
      <div class="modal-content" style="height: auto">
        <div class="modal-header">
          <span>新建约定</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="countdown-title-input">约定标题</label>
            <input
              type="text"
              id="countdown-title-input"
              placeholder="例如：我的生日"
            />
          </div>
          <div class="form-group">
            <label for="countdown-date-input">约定日期与时间</label>
            <input type="datetime-local" id="countdown-date-input" />
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-create-countdown-btn">取消</button>
          <button class="save" id="confirm-create-countdown-btn">
            保存约定
          </button>
        </div>
      </div>
    </div>

    <div id="red-packet-modal" class="modal">
      <div class="modal-content" style="width: 300px; height: auto">
        <div class="modal-header">
          <span>发红包</span>
        </div>
        <div class="modal-body" style="padding: 0">
          <!-- 1. 页签切换 -->
          <div class="frame-tabs">
            <div id="rp-tab-group" class="frame-tab active">拼手气红包</div>
            <div id="rp-tab-direct" class="frame-tab">专属红包</div>
          </div>

          <!-- 2. 拼手气红包内容区 -->
          <div
            id="rp-content-group"
            class="frame-content"
            style="padding: 20px 15px"
          >
            <div class="form-group">
              <label>总金额 (元)</label>
              <input type="number" id="rp-group-amount" placeholder="0.00" />
            </div>
            <div class="form-group">
              <label>红包个数</label>
              <input
                type="number"
                id="rp-group-count"
                placeholder="填写红包个数"
              />
            </div>
            <div class="form-group">
              <label>祝福语</label>
              <input
                type="text"
                id="rp-group-greeting"
                placeholder="恭喜发财，大吉大利！"
              />
            </div>
            <p
              id="rp-group-total"
              style="
                text-align: center;
                font-size: 24px;
                font-weight: bold;
                margin: 10px 0;
              "
            >
              ¥ 0.00
            </p>
            <button id="send-group-packet-btn" class="form-button">
              塞钱进红包
            </button>
          </div>

          <!-- 3. 专属红包内容区 -->
          <div
            id="rp-content-direct"
            class="frame-content"
            style="display: none; padding: 20px 15px"
          >
            <div class="form-group">
              <label>发送给</label>
              <select id="rp-direct-receiver"></select>
            </div>
            <div class="form-group">
              <label>金额 (元)</label>
              <input type="number" id="rp-direct-amount" placeholder="0.00" />
            </div>
            <div class="form-group">
              <label>祝福语</label>
              <input
                type="text"
                id="rp-direct-greeting"
                placeholder="恭喜发财，大吉大利！"
              />
            </div>
            <p
              id="rp-direct-total"
              style="
                text-align: center;
                font-size: 24px;
                font-weight: bold;
                margin: 10px 0;
              "
            >
              ¥ 0.00
            </p>
            <button id="send-direct-packet-btn" class="form-button">
              塞钱进红包
            </button>
          </div>
        </div>
        <div class="modal-footer" style="justify-content: center">
          <button class="cancel" id="cancel-red-packet-btn" style="width: 100%">
            取消
          </button>
        </div>
      </div>
    </div>

    <div id="red-packet-details-modal" class="modal">
      <div
        class="modal-content"
        style="width: 280px; height: auto; background-color: #f7f7f7"
      >
        <div
          class="modal-header"
          style="
            background-color: #f96259;
            color: white;
            border-bottom: none;
            padding-bottom: 5px;
          "
        >
          <div style="text-align: center; width: 100%">
            <div id="rp-details-sender" style="font-size: 16px"></div>
            <div style="font-size: 13px; opacity: 0.8">的红包</div>
          </div>
        </div>
        <div class="modal-body" style="padding: 15px">
          <p
            id="rp-details-greeting"
            style="
              text-align: center;
              font-size: 20px;
              color: #333;
              margin: 0 0 20px 0;
            "
          ></p>
          <div
            id="rp-details-my-amount"
            style="text-align: center; display: none; margin-bottom: 20px"
          >
            <span style="font-size: 40px; font-weight: bold; color: #e44d44"
              >0.00</span
            >
            <span style="font-size: 18px; color: #e44d44">元</span>
          </div>
          <div
            id="rp-details-summary"
            style="
              font-size: 13px;
              color: #8a8a8a;
              border-top: 1px solid #e0e0e0;
              padding-top: 10px;
            "
          ></div>
          <div
            id="rp-details-list"
            style="max-height: 150px; overflow-y: auto; margin-top: 10px"
          >
            <!-- 领取详情将由JS动态生成在这里 -->
          </div>
        </div>
        <div class="modal-footer">
          <button class="save" id="close-rp-details-btn" style="width: 100%">
            关闭
          </button>
        </div>
      </div>
    </div>
    <div id="create-poll-modal" class="modal">
      <div class="modal-content" style="width: 300px; height: auto">
        <div class="modal-header">
          <span>发起投票</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="poll-question-input">投票问题</label>
            <textarea
              id="poll-question-input"
              rows="2"
              placeholder="例如：今晚我们看什么电影？"
            ></textarea>
          </div>
          <div class="form-group">
            <label>投票选项 (至少2项)</label>
            <div
              id="poll-options-container"
              style="display: flex; flex-direction: column; gap: 8px"
            >
              <!-- 投票选项将由JS动态生成在这里 -->
            </div>
            <button
              id="add-poll-option-btn"
              class="form-button form-button-secondary"
              style="margin-top: 12px"
            >
              + 添加选项
            </button>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-create-poll-btn">取消</button>
          <button class="save" id="confirm-create-poll-btn">发起投票</button>
        </div>
      </div>
    </div>

    <div id="ai-avatar-library-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span id="ai-avatar-library-title">对方的头像库</span>
          <button id="add-ai-avatar-btn" class="action-button">添加</button>
        </div>
        <div class="modal-body" style="padding: 15px">
          <div
            id="ai-avatar-library-grid"
            style="
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
              gap: 15px;
            "
          >
            <!-- 头像库内容将由JS动态生成 -->
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-ai-avatar-library-btn"
            style="width: 100%"
          >
            关闭
          </button>
        </div>
      </div>
    </div>

    <div id="share-link-modal" class="modal">
      <div class="modal-content" style="width: 300px; height: auto">
        <div class="modal-header">
          <span>分享链接</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label for="link-title-input">标题</label>
            <input
              type="text"
              id="link-title-input"
              placeholder="输入文章或链接的标题"
            />
          </div>
          <div class="form-group">
            <label for="link-description-input">摘要 (可选)</label>
            <textarea
              id="link-description-input"
              rows="2"
              placeholder="简单描述一下链接内容"
            ></textarea>
          </div>
          <div class="form-group">
            <label for="link-source-input">来源名称 (可选)</label>
            <input
              type="text"
              id="link-source-input"
              placeholder="例如：知乎日报、B站"
            />
          </div>
          <div class="form-group">
            <label for="link-content-input"
              >完整内容 (可选，用于浏览器内显示)</label
            >
            <textarea
              id="link-content-input"
              rows="4"
              placeholder="粘贴或输入完整的文章内容"
            ></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-share-link-btn">取消</button>
          <button class="save" id="confirm-share-link-btn">分享</button>
        </div>
      </div>
    </div>

    <div id="transfer-actions-modal" class="modal">
      <div class="transfer-actions-content">
        <div class="transfer-actions-header">请选择操作</div>
        <div class="transfer-actions-body">
          <p>
            你收到了来自
            <strong id="transfer-sender-name"></strong> 的一笔转账。
          </p>
        </div>
        <div class="transfer-actions-footer">
          <button id="transfer-action-decline" class="action-btn decline">
            残忍拒绝
          </button>
          <button id="transfer-action-accept" class="action-btn accept">
            开心收下
          </button>
        </div>
        <button id="transfer-action-cancel" class="cancel-btn">×</button>
      </div>
    </div>

    <div id="call-transcript-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span id="transcript-modal-title">通话详情</span>
        </div>
        <div
          class="modal-body"
          id="transcript-modal-body"
          style="background-color: #f0f2f5"
        >
          <!-- 通话文字记录将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
          <button
            class="cancel"
            id="delete-transcript-btn"
            style="
              background-color: #ff3b30;
              color: white;
              border-color: #ff3b30;
            "
          >
            删除记录
          </button>
          <button
            class="save"
            id="close-transcript-modal-btn"
            style="width: 100%"
          >
            关闭
          </button>
        </div>
      </div>
    </div>

    <div id="share-target-modal" class="modal">
      <div class="modal-content" style="height: 70%">
        <div class="modal-header">
          <span>分享到...</span>
        </div>
        <div class="modal-body" id="share-target-list" style="padding: 0">
          <!-- 聊天列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
          <button class="cancel" id="cancel-share-target-btn">取消</button>
          <button class="save" id="confirm-share-target-btn">确认分享</button>
        </div>
      </div>
    </div>

    <div id="shared-history-viewer-modal" class="modal">
      <div class="modal-content" style="height: 80%">
        <div class="modal-header">
          <span id="shared-history-viewer-title">聊天记录</span>
        </div>
        <div
          class="modal-body"
          id="shared-history-viewer-content"
          style="background-color: #f0f2f5"
        >
          <!-- 分享的聊天记录气泡将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-shared-history-viewer-btn"
            style="width: 100%"
          >
            关闭
          </button>
        </div>
      </div>
    </div>

    <div id="world-book-category-manager-modal" class="modal">
      <div class="modal-content" style="height: 60%">
        <div class="modal-header">
          <span>管理世界书分类</span>
        </div>
        <div class="modal-body">
          <div class="form-group">
            <label>新建分类</label>
            <div style="display: flex; gap: 10px">
              <input
                type="text"
                id="new-category-name-input"
                placeholder="输入分类名..."
                style="flex-grow: 1"
              />
              <button
                id="add-new-category-btn"
                class="form-button"
                style="width: auto; margin-top: 0; padding: 0 15px"
              >
                添加
              </button>
            </div>
          </div>
          <hr style="opacity: 0.2" />
          <div
            id="existing-categories-list"
            style="display: flex; flex-direction: column; gap: 10px"
          >
            <!-- 分类列表将由JS动态生成 -->
          </div>
        </div>
        <div class="modal-footer">
          <button
            class="save"
            id="close-category-manager-btn"
            style="width: 100%"
          >
            完成
          </button>
        </div>
      </div>
    </div>

    <div id="api-presets-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <span>API 配置管理</span>
          <button class="action-button" id="close-api-presets-modal-btn">
            关闭
          </button>
        </div>
        <div class="modal-body">
          <div
            class="form-group"
            style="
              border-bottom: 1px solid #eee;
              padding-bottom: 15px;
              margin-bottom: 15px;
            "
          >
            <label>保存当前配置为:</label>
            <div style="display: flex; gap: 10px; margin-top: 5px">
              <input
                type="text"
                id="save-preset-name-input"
                placeholder="配置名称 (如: DeepSeek-V3)"
                style="flex-grow: 1"
              />
              <button
                class="form-button"
                id="save-preset-btn"
                style="width: auto; margin-top: 0"
              >
                保存
              </button>
            </div>
          </div>
          <label>已保存的配置:</label>
          <div
            id="api-presets-list"
            class="list-container"
            style="max-height: 300px; padding: 0"
          >
            <!-- JS生成列表 -->
          </div>
        </div>
      </div>
    </div>

    <script>
      const GEMINI_API_URL =
        "https://generativelanguage.googleapis.com/v1beta/models";
      // gemini如果是多个密钥, 那么随机获取一个
      function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(",")) {
          // 用逗号分隔字符串并移除多余空格
          const arr = str.split(",").map((item) => item.trim());
          // 生成随机索引 (0 到 arr.length-1)
          const randomIndex = Math.floor(Math.random() * arr.length);
          // 返回随机元素
          return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
      }
      function isImage(text, content) {
        let currentImageData = content.image_url.url;
        // 提取Base64数据（去掉前缀）
        const base64Data = currentImageData.split(",")[1];
        // 根据图片类型获取MIME类型
        const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
        return [
          { text: `${text.text}用户向你发送了一张图片` },
          {
            inline_data: {
              mime_type: mimeType,
              data: base64Data,
            },
          },
        ];
      }

      function extractArray(text) {
        // 正则表达式模式：匹配开头的时间戳部分和后续的JSON数组
        const pattern = /^\(Timestamp: (\d+)\)(.*)$/s;
        const match = text.match(pattern);

        if (match) {
          const timestampPart = `(Timestamp: ${match[1]}) `;
          const jsonPart = match[2].trim();

          try {
            // 尝试解析JSON部分
            const parsedJson = JSON.parse(jsonPart);
            // 验证解析结果是否为数组
            if (Array.isArray(parsedJson)) {
              return [timestampPart, parsedJson[0]];
            }
          } catch (error) {
            // 解析失败，返回原始文本
          }
        }

        // 不匹配格式或解析失败时返回原值
        return text;
      }
      function transformChatData(item) {
        let type = {
          send_and_recall: "撤回了消息",
          update_status: "更新了状态",
          change_music: "切换了歌曲",
          create_memory: "记录了回忆",
          create_countdown: "创建了约定/倒计时",
          text: "发送了文本",
          sticker: "发送了表情",
          ai_image: "发送了图片",
          voice_message: "发送了语音",
          transfer: "发起了转账",
          waimai_request: "发起了外卖请求",
          waimai_response: {
            paid: "回应了外卖-同意",
            rejected: "回应了外卖-拒绝",
          },
          video_call_request: "发起了视频通话",
          video_call_response: {
            accept: "回应了视频通话-接受",
            reject: "回应了视频通话-拒绝",
          },
          qzone_post: {
            shuoshuo: "发布了说说",
            text_image: "发布了文字图",
          },
          qzone_comment: "评论了动态",
          qzone_like: "点赞了动态",
          pat_user: "拍一拍了用户",
          block_user: "拉黑了用户",
          friend_request_response: "回应了好友申请",
          change_avatar: "更换了头像",
          share_link: "分享了链接",
          accept_transfer: "回应了转账-接受",
          decline_transfer: "回应了转账-拒绝/退款",
          quote_reply: "引用了回复",
          text: "",
        };
        let res = extractArray(item.content);

        if (Array.isArray(res)) {
          let obj = res[1];
          let itemType = obj.type;
          let time = res[0];
          let text = type[itemType];
          if (text) {
            if (itemType === "sticker") {
              return [{ text: `${time}[${text}] 含义是:${obj.meaning}` }];
            } else if (itemType === "send_and_recall") {
              return [{ text: `${time}[${text}] ${obj.content}` }];
            } else if (itemType === "update_status") {
              return [
                {
                  text: `${time}[${text}] ${obj.status_text}(${
                    obj.is_busy ? "忙碌/离开" : "空闲"
                  })`,
                },
              ];
            } else if (itemType === "change_music") {
              return [
                {
                  text: `${time}[${text}] ${obj.change_music}, 歌名是:${obj.song_name}`,
                },
              ];
            } else if (itemType === "create_memory") {
              return [{ text: `${time}[${text}] ${obj.description}` }];
            } else if (itemType === "create_countdown") {
              return [{ text: `${time}[${text}] ${obj.title}(${obj.date})` }];
            } else if (itemType === "ai_image") {
              return [
                { text: `${time}[${text}] 图片描述是:${obj.description}` },
              ];
            } else if (itemType === "voice_message") {
              return [{ text: `${time}[${text}] ${obj.content}` }];
            } else if (itemType === "transfer") {
              return [
                {
                  text: `${time}[${text}] 金额是:${obj.amount} 备注是:${obj.amount}`,
                },
              ];
            } else if (itemType === "waimai_request") {
              return [
                {
                  text: `${time}[${text}] 金额是:${obj.amount} 商品是:${obj.productInfo}`,
                },
              ];
            } else if (itemType === "waimai_response") {
              return [
                {
                  text: `${time}[${text[obj.status]}] ${
                    obj.status === "paid" ? "同意" : "拒绝"
                  }`,
                },
              ];
            } else if (itemType === "video_call_request") {
              return [{ text: `${time}[${text}]` }];
            }
          } else if (itemType === "video_call_request") {
            return [
              {
                text: `${time}[${text[obj.decision]}] ${
                  obj.decision === "accept" ? "同意" : "拒绝"
                }`,
              },
            ];
          } else if (itemType === "qzone_post") {
            return [
              {
                text: `${time}[${text[obj.postType]}] ${
                  obj.postType === "shuoshuo"
                    ? `${obj.content}`
                    : `图片描述是:${obj.hiddenContent} ${
                        obj.publicText ? `文案是: ${obj.publicText}` : ""
                      }`
                }`,
              },
            ];
          } else if (itemType === "qzone_comment") {
            return [
              {
                text: `${time}[${text}] 评论的id是: ${obj.postId} 评论的内容是: ${obj.commentText}`,
              },
            ];
          } else if (itemType === "qzone_like") {
            return [{ text: `${time}[${text}] 点赞的id是: ${obj.postId}` }];
          } else if (itemType === "pat_user") {
            return [
              { text: `${time}[${text}] ${obj.suffix ? obj.suffix : ""}` },
            ];
          } else if (itemType === "block_user") {
            return [{ text: `${time}[${text}]` }];
          } else if (itemType === "friend_request_response") {
            return [
              {
                text: `${time}[${text}] 结果是:${
                  obj.decision === "accept" ? "同意" : "拒绝"
                }`,
              },
            ];
          } else if (itemType === "change_avatar") {
            return [{ text: `${time}[${text}] 头像名是:${obj.name}` }];
          } else if (itemType === "share_link") {
            return [
              {
                text: `${time}[${text}] 文章标题是:${obj.title}  文章摘要是:${obj.description} 来源网站名是:${obj.source_name} 文章正文是:${obj.content}`,
              },
            ];
          } else if (itemType === "accept_transfer") {
            return [{ text: `${time}[${text}]` }];
          } else if (itemType === "accept_transfer") {
            return [{ text: `${time}[${text}]` }];
          } else if (itemType === "quote_reply") {
            return [
              { text: `${time}[${text}] 引用的内容是:${obj.reply_content}` },
            ];
          } else if (itemType === "text") {
            return [{ text: `${time}${obj.content}` }];
          }
        }

        if (Array.isArray(res) && res.length > 1) {
          res = `${res[0]}${res[1].content}`;
        }

        return [{ text: res }];
      }

      function toGeminiRequestData(
        model,
        apiKey,
        systemInstruction,
        messagesForDecision,
        isGemini,
        temperature,
        topP,
        topK,
      ) {
        if (!isGemini) {
          return undefined;
        }

        // 【核心修正】在这里，我们将 'system' 角色也映射为 'user'

        let roleType = {
          user: "user",
          assistant: "model",
          system: "user", // <--- 新增这一行
        };

        // 构建 generationConfig
        const generationConfig = {};
        if (temperature !== undefined)
          generationConfig.temperature = temperature;
        if (topP !== undefined) generationConfig.topP = topP;
        if (topK !== undefined) generationConfig.topK = topK;

        return {
          url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(
            apiKey,
          )}`,
          data: {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              contents: messagesForDecision.map((item) => {
                let includesImages = false;
                if (Array.isArray(item.content) && item.content.length === 2) {
                  includesImages = item.content.some((sub) => {
                    return sub.type === "image_url" && sub.image_url.url;
                  });
                }
                return {
                  role: roleType[item.role], // 现在 'system' 会被正确转换为 'user'
                  parts: includesImages
                    ? isImage(item.content[0], item.content[1])
                    : transformChatData(item),
                };
              }),
              generationConfig: generationConfig,
              systemInstruction: {
                parts: [
                  {
                    text: systemInstruction,
                  },
                ],
              },
            }),
          },
        };
      }
      document.addEventListener("DOMContentLoaded", () => {
        // === Lightweight performance helpers ===
        /* visibility safeguard for streaming (patched) */
        document.addEventListener(
          "visibilitychange",
          async () => {
            if (document.hidden) {
              try {
                // flush any in-flight streaming content
                await db?.chats?.put?.(state.chats[state.activeChatId]);
              } catch (e) {}
            }
          },
          { passive: true },
        );

        // 2) Default all images to lazy & async decoding (static + dynamically added)
        function setImagePerfAttrs(img) {
          try {
            if (!img.hasAttribute("loading"))
              img.setAttribute("loading", "lazy");
            if (!img.hasAttribute("decoding"))
              img.setAttribute("decoding", "async");
          } catch (e) {}
        }
        document.querySelectorAll("img").forEach(setImagePerfAttrs);
        const mo = new MutationObserver((mutations) => {
          for (const m of mutations) {
            m.addedNodes &&
              m.addedNodes.forEach((node) => {
                if (node && node.tagName === "IMG") setImagePerfAttrs(node);
                else if (node && node.querySelectorAll)
                  node.querySelectorAll("img").forEach(setImagePerfAttrs);
              });
          }
        });
        mo.observe(document.documentElement, {
          childList: true,
          subtree: true,
        });

        // 3) Encourage passive listeners for scroll/touch to prevent jank
        (function () {
          const orig = EventTarget.prototype.addEventListener;
          const defaultPassive = {
            touchstart: true,
            touchmove: true,
            wheel: true,
          };
          EventTarget.prototype.addEventListener = function (
            type,
            listener,
            options,
          ) {
            let opts = options;
            if (typeof options === "object" && options !== null) {
              if (defaultPassive[type] && options.passive == null) {
                opts = Object.assign({}, options, { passive: true });
              }
            } else if (options === undefined && defaultPassive[type]) {
              opts = { passive: true };
            }
            return orig.call(this, type, listener, opts);
          };
        })();
        // ===================================================================
        // 1. 所有变量和常量定义
        // ===================================================================
        // ==================== iOS PWA 后台活动模块 ====================
        const SILENT_MP3_BASE64 = 'data:audio/mp3;base64,SUQzBAAAAAABBlRTU0UAAAAPAAADTGF2ZjU4LjI5LjEwMAAAAAAAAAAAAAAA//tQwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7v/////////////////////////////////////////////////////////////////AAAA5kxhdmM1OC41NAAAAAAAAAAAAAAAACQAAAAAAAAAAAGGpN7WLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/7UMQAA8AAAGkAAAAIAAANIAAAAQAAAKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq=';

        class BackgroundKeepAlive {
          constructor() {
            this.audio = new Audio(SILENT_MP3_BASE64);
            this.audio.loop = true;
            this.audio.playsInline = true;
            this.isActive = false;
          }

          async start() {
            if (this.isActive) return;
            try {
              await this.audio.play();
              this.isActive = true;
              this.setupMediaSession();
              console.log("[BackgroundKeepAlive] Started");
            } catch (error) {
              console.error("[BackgroundKeepAlive] Failed:", error);
            }
          }

          stop() {
            this.audio.pause();
            this.isActive = false;
          }

          setupMediaSession() {
            if ("mediaSession" in navigator) {
              navigator.mediaSession.metadata = new MediaMetadata({
                title: 'EPhone Running',
                artist: 'Background Active',
                artwork: [{ src: 'icons/icon-512.png', sizes: '512x512', type: 'image/png' }]
              });
            }
          }
        }

        const keepAliveSystem = new BackgroundKeepAlive();

        async function requestNotificationPermission() {
          if (!("Notification" in window)) return 'unsupported';
          if (Notification.permission === 'granted') return 'granted';
          return await Notification.requestPermission();
        }

        async function sendLocalNotification(title, body, chatId, avatarUrl) {
          if (Notification.permission === 'granted') {
            try {
              const reg = await navigator.serviceWorker.ready;
              await reg.showNotification(title, {
                body: body,
                icon: avatarUrl || 'icons/icon-192.png',
                badge: 'icons/icon-maskable-192.png',
                tag: 'ephone-msg-' + Date.now(),
                data: { url: window.location.href, chatId: chatId }
              });
            } catch (e) {
              console.error("[Notification] Failed:", e);
            }
          }
        }
        // ==================== 后台活动模块结束 ====================

        const db = new Dexie("GeminiChatDB");
        // --- 已修正 ---
        const offlinePresets = {
          custom: { name: "自定义 (Custom)", prompt: "", style: "" },
          classroom: {
            name: "教室 (Classroom)",
            prompt: "我们在教室里，下课时间。窗外阳光正好，同学们在打闹。",
            style: "青春校园",
          },
          bedroom: {
            name: "卧室 (Bedroom)",
            prompt: "深夜，我们在卧室里。房间里很安静，只有床头灯亮着。",
            style: "温馨私密",
          },
          park: {
            name: "公园 (Park)",
            prompt: "午后的公园，阳光明媚。我们在长椅上坐着，微风吹过。",
            style: "轻松日常",
          },
          cafe: {
            name: "咖啡馆 (Cafe)",
            prompt: "热闹的咖啡馆，空气中弥漫着咖啡香。我们面对面坐着。",
            style: "都市休闲",
          },
          street: {
            name: "街道 (Street)",
            prompt: "夜晚的街道，霓虹灯闪烁。我们并肩走着。",
            style: "赛博朋克",
          },
        };

        let state = {
          chats: {},
          activeChatId: null,
          globalSettings: {},
          apiConfigs: [],
          userStickers: [],
          worldBooks: [],
          personaPresets: [],
          qzoneSettings: {},
          activeAlbumId: null,
        };

        // 搜索状态
        let chatSearchState = {
          query: "",
          results: [], // 匹配的消息索引数组
          currentIndex: -1, // 当前高亮的结果索引
          isOpen: false,
        };

        let notificationTimeout;

        function showNotification(chatId, messageContent) {
          playNotificationSound();
          clearTimeout(notificationTimeout);
          const chat = state.chats[chatId];
          if (!chat) return;
          const bar = document.getElementById('notification-bar');
          document.getElementById('notification-avatar').src =
            chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar;
          document.getElementById('notification-content').querySelector('.name').textContent = chat.name;
          document.getElementById('notification-content').querySelector('.message').textContent = messageContent;
          const newBar = bar.cloneNode(true);
          bar.parentNode.replaceChild(newBar, bar);
          newBar.addEventListener('click', () => {
            openChat(chatId);
            newBar.classList.remove('visible');
          });
          newBar.classList.add('visible');
          notificationTimeout = setTimeout(() => {
            newBar.classList.remove('visible');
          }, 4000);
        }

        function playNotificationSound() {
          const soundUrl =
            state.globalSettings.notificationSoundUrl || 'https://laddy-lulu.github.io/Ephone-stuffs/message.mp3';
          if (!soundUrl || !soundUrl.trim()) return;
          try {
            const audio = new Audio(soundUrl);
            audio.volume = 0.7;
            audio.play().catch(error => {
              if (error.name === 'NotAllowedError') {
                console.warn('播放消息提示音失败：用户需要先与页面进行一次交互才能自动播放音频。');
              } else {
                console.error(`播放消息提示音失败 (${error.name}): ${error.message}`);
              }
            });
          } catch (error) {
            console.error('创建提示音Audio对象时出错:', error);
          }
        }

        // Debounce 函数
        function debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        }

        // 执行搜索
        function performChatSearch(query) {
          const chat = state.chats[state.activeChatId];
          if (!chat || !query.trim()) {
            chatSearchState.results = [];
            chatSearchState.currentIndex = -1;
            chatSearchState.query = "";
            updateSearchUI();
            if (typeof clearSearchHighlights === "function") {
              clearSearchHighlights();
            }
            return;
          }

          const lowerQuery = query.toLowerCase().trim();
          chatSearchState.query = lowerQuery;
          chatSearchState.results = [];

          // 遍历消息找匹配项
          chat.history.forEach((msg, index) => {
            if (msg.isHidden || msg.type === "summary") return;
            const content = msg.content || "";
            if (typeof content === "string" && content.toLowerCase().includes(lowerQuery)) {
              chatSearchState.results.push(index);
            }
          });

          // 设置到第一个结果
          if (chatSearchState.results.length > 0) {
            chatSearchState.currentIndex = 0;
            if (typeof navigateToResult === "function") {
              navigateToResult(0);
            }
          } else {
            chatSearchState.currentIndex = -1;
          }

          updateSearchUI();
        }

        // 更新搜索UI
        function updateSearchUI() {
          const countEl = document.getElementById("search-result-count");
          const prevBtn = document.getElementById("search-prev-btn");
          const nextBtn = document.getElementById("search-next-btn");

          const total = chatSearchState.results.length;
          const current = chatSearchState.currentIndex + 1;

          if (countEl) {
            countEl.textContent = total > 0 ? `${current}/${total}` : "0/0";
          }
          if (prevBtn) {
            prevBtn.disabled = total === 0 || chatSearchState.currentIndex <= 0;
          }
          if (nextBtn) {
            nextBtn.disabled =
              total === 0 || chatSearchState.currentIndex >= total - 1;
          }
         }

        // Debounced 搜索
        const debouncedSearch = debounce((query) => {
          performChatSearch(query);
        }, 300);

        // 导航到结果
        function navigateToResult(index) {
          if (index < 0 || index >= chatSearchState.results.length) return;

          chatSearchState.currentIndex = index;
          const msgIndex = chatSearchState.results[index];
          const messagesContainer = document.getElementById("chat-messages");
          if (!messagesContainer) return;

          messagesContainer.querySelectorAll(".search-highlight").forEach((el) => {
            el.classList.remove("search-highlight");
          });

          const targetMsg = messagesContainer.querySelector(
            `.message-wrapper[data-msg-index="${msgIndex}"]`,
          );

          if (targetMsg) {
            // iOS-safe scrolling: manually calculate and set scrollTop
            // This works reliably on iOS Safari where scrollIntoView() fails in scrollable containers
            const targetRect = targetMsg.getBoundingClientRect();
            const containerRect = messagesContainer.getBoundingClientRect();
            
            // Calculate offset from container top
            const offset = targetRect.top - containerRect.top;
            
            // Scroll to center the message in viewport (with smooth behavior)
            const targetScrollTop = messagesContainer.scrollTop + offset - (containerRect.height / 2) + (targetRect.height / 2);
            
            // Smooth scroll using requestAnimationFrame for better iOS compatibility
            const startScrollTop = messagesContainer.scrollTop;
            const distance = targetScrollTop - startScrollTop;
            const duration = 300; // ms
            const startTime = performance.now();
            
            function smoothScrollStep(currentTime) {
              const elapsed = currentTime - startTime;
              const progress = Math.min(elapsed / duration, 1);
              
              // Ease-out cubic for smooth deceleration
              const easeProgress = 1 - Math.pow(1 - progress, 3);
              
              messagesContainer.scrollTop = startScrollTop + (distance * easeProgress);
              
              if (progress < 1) {
                requestAnimationFrame(smoothScrollStep);
              }
            }
            
            requestAnimationFrame(smoothScrollStep);
            
            targetMsg.classList.add("search-highlight");

            setTimeout(() => {
              targetMsg.classList.remove("search-highlight");
            }, 1500);
          }

          updateSearchUI();
          highlightSearchMatches();
        }

        // 高亮搜索匹配文本
        function highlightSearchMatches() {
          clearSearchHighlights();
          if (!chatSearchState.query) return;

          const messagesContainer = document.getElementById("chat-messages");
          if (!messagesContainer) return;

          const regex = new RegExp(`(${escapeRegex(chatSearchState.query)})`, "gi");

          chatSearchState.results.forEach((msgIndex, resultIndex) => {
            const msgEl = messagesContainer.querySelector(
              `.message-wrapper[data-msg-index="${msgIndex}"] .content`,
            );
            if (!msgEl) return;

            if (!msgEl.dataset.originalHtml) {
              msgEl.dataset.originalHtml = msgEl.innerHTML;
            }

            const isCurrent = resultIndex === chatSearchState.currentIndex;
            msgEl.innerHTML = msgEl.dataset.originalHtml.replace(
              regex,
              `<span class="search-match${isCurrent ? " current" : ""}">$1</span>`,
            );
          });
        }

        // 清除搜索高亮
        function clearSearchHighlights() {
          const messagesContainer = document.getElementById("chat-messages");
          if (!messagesContainer) return;

          messagesContainer
            .querySelectorAll(".content[data-original-html]")
            .forEach((el) => {
              el.innerHTML = el.dataset.originalHtml;
              delete el.dataset.originalHtml;
            });

          messagesContainer.querySelectorAll(".search-highlight").forEach((el) => {
            el.classList.remove("search-highlight");
          });
        }

        // 转义正则特殊字符
        function escapeRegex(string) {
          return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        // 打开搜索面板
        function openChatSearch() {
          chatSearchState.isOpen = true;
          document.getElementById("chat-search-panel")?.classList.add("visible");
          const input = document.getElementById("chat-search-input");
          if (input) input.focus();
        }

        // 关闭搜索面板
        function closeChatSearch() {
          chatSearchState.isOpen = false;
          chatSearchState.query = "";
          chatSearchState.results = [];
          chatSearchState.currentIndex = -1;
          document.getElementById("chat-search-panel")?.classList.remove("visible");
          const input = document.getElementById("chat-search-input");
          if (input) input.value = "";
          clearSearchHighlights();
          updateSearchUI();
        }

        // 搜索事件绑定
        const chatSearchBtn = document.getElementById("chat-search-btn");
        const closeSearchBtn = document.getElementById("close-search-btn");
        const searchInput = document.getElementById("chat-search-input");
        const prevSearchBtn = document.getElementById("search-prev-btn");
        const nextSearchBtn = document.getElementById("search-next-btn");

        chatSearchBtn?.addEventListener("click", openChatSearch);
        closeSearchBtn?.addEventListener("click", closeChatSearch);
        searchInput?.addEventListener("input", (event) => {
          const target = event.target;
          if (target instanceof HTMLInputElement) {
            debouncedSearch(target.value);
          }
        });

        prevSearchBtn?.addEventListener("click", () => {
          if (chatSearchState.currentIndex > 0) {
            navigateToResult(chatSearchState.currentIndex - 1);
          }
        });

        nextSearchBtn?.addEventListener("click", () => {
          if (chatSearchState.currentIndex < chatSearchState.results.length - 1) {
            navigateToResult(chatSearchState.currentIndex + 1);
          }
        });

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && chatSearchState.isOpen) {
            closeChatSearch();
          }
        });

        function getActiveApiConfig() {
          const activeConfigId = state.globalSettings.activeApiConfigId;
          const activeConfig = state.apiConfigs.find(
            (c) => c.id === activeConfigId,
          );
          if (!activeConfig) return null;
          return {
            proxyUrl: activeConfig.url,
            apiKey: activeConfig.apiKey,
            model: activeConfig.model,
            temperature: activeConfig.temperature ?? 0.8, // 传递新参数
            topP: activeConfig.topP ?? 1.0,
            topK: activeConfig.topK ?? 40,
            enableTemp:
              activeConfig.enableTemp ??
              activeConfig.enableAdvancedParams ??
              false,
            enableTopP:
              activeConfig.enableTopP ??
              activeConfig.enableAdvancedParams ??
              false,
            enableTopK:
              activeConfig.enableTopK ??
              activeConfig.enableAdvancedParams ??
              false,
            enableStreaming: activeConfig.enableStream, // Map to old property name for compatibility
          };
        }
        function getSummaryApiConfig(chatId) {
          const chat = state.chats[chatId];
          if (
            chat &&
            chat.settings &&
            chat.settings.summary &&
            chat.settings.summary.useCustomApi
          ) {
            return {
              proxyUrl: chat.settings.summary.customApiUrl,
              apiKey: chat.settings.summary.customApiKey,
              model: chat.settings.summary.customModel,
              enableStreaming: chat.settings.summary.enableStream,
              // Summary specific configs don't support advanced params yet, use defaults or globals?
              // For now, let's stick to defaults for stability
              temperature: 0.3,
              topP: 1.0,
              topK: 40,
              enableTemp: false,
              enableTopP: false,
              enableTopK: false,
            };
          }
          return getActiveApiConfig();
        }
        // --- 修正结束 ---
        let musicState = {
          isActive: false,
          activeChatId: null,
          isPlaying: false,
          playlist: [],
          currentIndex: -1,
          playMode: "order",
          totalElapsedTime: 0,
          timerId: null,
          // 【新增】歌词相关状态
          parsedLyrics: [], // 当前歌曲解析后的歌词数组
          currentLyricIndex: -1, // 当前高亮的歌词行索引
        };
        const audioPlayer = document.getElementById("audio-player");
        let newWallpaperBase64 = null;
        let isSelectionMode = false;
        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;

        let waimaiTimers = {}; // 用于存储外卖倒计时

        let activeMessageTimestamp = null;
        let currentReplyContext = null; // <--- 新增这行，用来存储当前正在引用的消息信息
        let activePostId = null; // <-- 新增：用于存储当前操作的动态ID

        let photoViewerState = {
          isOpen: false,
          photos: [], // 存储当前相册的所有照片URL
          currentIndex: -1, // 当前正在查看的照片索引
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set();

        let simulationIntervalId = null;

        const defaultAvatar = "https://i.postimg.cc/PxZrFFFL/o-o-1.jpg";
        const defaultMyGroupAvatar = "https://i.postimg.cc/cLPP10Vm/4.jpg";
        const defaultGroupMemberAvatar = "https://i.postimg.cc/VkQfgzGJ/1.jpg";
        const defaultGroupAvatar =
          "https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg";

        const DEFAULT_APP_ICONS = {
          "world-book": "https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg",
          qq: "https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg",
          "api-settings": "https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg",
          wallpaper: "https://i.postimg.cc/T1j03pQr/IMG-6440.jpg",
          font: "https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg",
        };

        const STICKER_REGEX =
          /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = {
          hasShown40: false,
          hasShown20: false,
          hasShown10: false,
        };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement("style");
        dynamicFontStyle.id = "dynamic-font-style";
        document.head.appendChild(dynamicFontStyle);

        const modalOverlay = document.getElementById("custom-modal-overlay");
        const modalTitle = document.getElementById("custom-modal-title");
        const modalBody = document.getElementById("custom-modal-body");
        const modalConfirmBtn = document.getElementById("custom-modal-confirm");
        const modalCancelBtn = document.getElementById("custom-modal-cancel");
        let modalResolve;

        function showCustomModal() {
          modalOverlay.classList.add("visible");
        }

        function hideCustomModal() {
          modalOverlay.classList.remove("visible");
          modalConfirmBtn.classList.remove("btn-danger");
          if (modalResolve) modalResolve(null);
        }

        function showCustomConfirm(title, message, options = {}) {
          return new Promise((resolve) => {
            modalResolve = resolve;
            modalTitle.textContent = title;
            modalBody.innerHTML = `<p>${message}</p>`;
            modalCancelBtn.style.display = "block";
            modalConfirmBtn.textContent = "确定";
            if (options.confirmButtonClass)
              modalConfirmBtn.classList.add(options.confirmButtonClass);
            modalConfirmBtn.onclick = () => {
              resolve(true);
              hideCustomModal();
            };
            modalCancelBtn.onclick = () => {
              resolve(false);
              hideCustomModal();
            };
            showCustomModal();
          });
        }

        function showCustomAlert(title, message) {
          return new Promise((resolve) => {
            modalResolve = resolve;
            modalTitle.textContent = title;
            modalBody.innerHTML = `<div style="text-align: center; white-space: pre-wrap; display: flex; align-items: center; justify-content: center; min-height: 30px; width: 100%;">${message}</div>`;
            modalCancelBtn.style.display = "none";
            modalConfirmBtn.textContent = "好的";
            modalConfirmBtn.onclick = () => {
              modalCancelBtn.style.display = "block";
              modalConfirmBtn.textContent = "确定";
              resolve(true);
              hideCustomModal();
            };
            showCustomModal();
          });
        }

        function showCustomPrompt(
          title,
          placeholder,
          initialValue = "",
          type = "text",
          extraHtml = "",
        ) {
          return new Promise((resolve) => {
            modalResolve = resolve;
            modalTitle.textContent = title;
            const inputId = "custom-prompt-input";

            const inputHtml =
              type === "textarea"
                ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
                : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;

            // 将额外的HTML和输入框组合在一起
            modalBody.innerHTML = extraHtml + inputHtml;
            const input = document.getElementById(inputId);

            // 为格式助手按钮绑定事件
            modalBody.querySelectorAll(".format-btn").forEach((btn) => {
              btn.addEventListener("click", () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                  try {
                    const templateObj = JSON.parse(templateStr);
                    // 使用 null, 2 参数让JSON字符串格式化，带缩进，更易读
                    input.value = JSON.stringify(templateObj, null, 2);
                    input.focus();
                  } catch (e) {
                    console.error("解析格式模板失败:", e);
                  }
                }
              });
            });

            modalConfirmBtn.onclick = () => {
              resolve(input.value);
              hideCustomModal();
            };
            modalCancelBtn.onclick = () => {
              resolve(null);
              hideCustomModal();
            };

            // 1. 显示模态框 (修改 DOM/CSS 状态)
            showCustomModal();

            // 2. 核心优化：多重聚焦策略

            // 策略A：立即聚焦
            // 针对高性能设备，尝试在当前同步执行栈中直接聚焦，这是 iOS 最喜欢的“直接交互”。
            // 虽然此时元素可能还没完全渲染可见，但在 DOM 树中 display 属性已变更为非 none。
            input.focus();

            // 策略B：下一帧聚焦
            // 如果策略A失败（因为浏览器还没重排），请求在下一帧渲染前聚焦。
            // requestAnimationFrame 通常会被浏览器视为用户交互的一部分。
            requestAnimationFrame(() => {
              input.focus();
            });

            // 策略C：保底延时
            // 针对老旧安卓设备或渲染极慢的情况，稍微延长等待时间。
            // 即使 iOS 在这里拦截了键盘，上面的 A 或 B 应该已经成功了。
            setTimeout(() => {
              if (document.activeElement !== input) {
                input.focus();
              }
            }, 150);
          });
        }

        // ===================================================================
        // 2. 数据库结构定义
        // ===================================================================

        db.version(24)
          .stores({
            chats: "&id, isGroup, groupId",
            // apiConfig: "&id", // <- 移除旧表
            apiConfigs: "++id, name", // <- 新增，用于存储多个API配置
            globalSettings: "&id",
            userStickers: "&id, url, name",
            worldBooks: "&id, name, categoryId",
            worldBookCategories: "++id, name",
            musicLibrary: "&id",
            personaPresets: "&id",
            qzoneSettings: "&id",
            qzonePosts: "++id, timestamp",
            qzoneAlbums: "++id, name, createdAt",
            qzonePhotos: "++id, albumId",
            favorites: "++id, type, timestamp, originalTimestamp",
            qzoneGroups: "++id, name",
            memories: "++id, chatId, timestamp, type, targetDate",
            callRecords: "++id, chatId, timestamp, customName",
          })
          .upgrade(async (tx) => {
            // 数据迁移脚本：从旧的单个 apiConfig 迁移到新的 apiConfigs 列表
            const oldConfig = await tx.table("apiConfig").get("main");
            if (oldConfig) {
              console.log("检测到旧版API配置，正在执行自动迁移...");
              const newConfigsTable = tx.table("apiConfigs");
              const existingConfigs = await newConfigsTable.toArray();
              if (existingConfigs.length === 0) {
                const newId = await newConfigsTable.add({
                  name: "默认配置",
                  url: oldConfig.proxyUrl || "",
                  apiKey: oldConfig.apiKey || "",
                  model: oldConfig.model || "",
                  enableStream: oldConfig.enableStream || false,
                  hideStreamResponse: oldConfig.hideStreamResponse || false,
                });

                const globalSettings = (await tx
                  .table("globalSettings")
                  .get("main")) || { id: "main" };
                globalSettings.activeApiConfigId = newId;
                await tx.table("globalSettings").put(globalSettings);

                await tx.table("apiConfig").clear();
                console.log("API配置迁移成功！");
              }
            }
          });

        // ===================================================================
        // 3. 所有功能函数定义
        // ===================================================================

        function showScreen(screenId) {
          if (screenId === "chat-list-screen") {
            window.renderChatListProxy();
            switchToChatListView("messages-view");
          }
          if (screenId === "api-settings-screen")
            window.renderApiSettingsProxy();
          if (screenId === "wallpaper-screen")
            window.renderWallpaperScreenProxy();
          if (screenId === "world-book-screen")
            window.renderWorldBookScreenProxy();
          document
            .querySelectorAll(".screen")
            .forEach((s) => s.classList.remove("active"));
          const screenToShow = document.getElementById(screenId);
          if (screenToShow) screenToShow.classList.add("active");
          if (screenId === "chat-interface-screen")
            window.updateListenTogetherIconProxy(state.activeChatId);
          if (screenId === "font-settings-screen") {
            document.getElementById("font-url-input").value =
              state.globalSettings.fontUrl || "";
            applyCustomFont(state.globalSettings.fontUrl || "", true);
          }
        }
        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
          const chatListScreen = document.getElementById("chat-list-screen");
          const views = {
            "messages-view": document.getElementById("messages-view"),
            "qzone-screen": document.getElementById("qzone-screen"),
            "favorites-view": document.getElementById("favorites-view"),
            "memories-view": document.getElementById("memories-view"), // <-- 新增这一行
          };
          const mainHeader = document.getElementById("main-chat-list-header");
          const mainBottomNav = document.getElementById("chat-list-bottom-nav"); // 获取主导航栏

          if (isFavoritesSelectionMode) {
            document.getElementById("favorites-edit-btn").click();
          }

          // 隐藏所有视图
          Object.values(views).forEach((v) => v.classList.remove("active"));
          // 显示目标视图
          if (views[viewId]) {
            views[viewId].classList.add("active");
          }

          // 更新底部导航栏高亮
          document
            .querySelectorAll("#chat-list-bottom-nav .nav-item")
            .forEach((item) => {
              item.classList.toggle("active", item.dataset.view === viewId);
            });

          if (viewId === "messages-view") {
            mainHeader.style.display = "flex";
            mainBottomNav.style.display = "flex";
          } else {
            mainHeader.style.display = "none";
            mainBottomNav.style.display = "none";
          }

          if (viewId !== "memories-view") {
            activeCountdownTimers.forEach((timerId) => clearInterval(timerId));
            activeCountdownTimers = [];
          }

          // 根据视图ID执行特定的渲染/更新逻辑
          switch (viewId) {
            case "qzone-screen":
              views["qzone-screen"].style.backgroundColor = "#f0f2f5";
              updateUnreadIndicator(0);
              renderQzoneScreen();
              renderQzonePosts();
              break;
            case "favorites-view":
              views["favorites-view"].style.backgroundColor = "#f9f9f9";
              renderFavoritesScreen();
              break;
            case "messages-view":
              // 如果需要，可以在这里添加返回消息列表时要执行的逻辑
              break;
          }
        }

        function renderQzoneScreen() {
          if (state && state.qzoneSettings) {
            const settings = state.qzoneSettings;
            document.getElementById("qzone-nickname").textContent =
              settings.nickname;
            document.getElementById("qzone-avatar-img").src = settings.avatar;
            document.getElementById("qzone-banner-img").src = settings.banner;
          }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        async function saveQzoneSettings() {
          if (db && state.qzoneSettings) {
            await db.qzoneSettings.put(state.qzoneSettings);
          }
        }

        function formatPostTimestamp(timestamp) {
          if (!timestamp) return "";
          const now = new Date();
          const date = new Date(timestamp);
          const diffSeconds = Math.floor((now - date) / 1000);
          const diffMinutes = Math.floor(diffSeconds / 60);
          const diffHours = Math.floor(diffMinutes / 60);
          if (diffMinutes < 1) return "刚刚";
          if (diffMinutes < 60) return `${diffMinutes}分钟前`;
          if (diffHours < 24) return `${diffHours}小时前`;
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          const hours = String(date.getHours()).padStart(2, "0");
          const minutes = String(date.getMinutes()).padStart(2, "0");
          if (now.getFullYear() === year) {
            return `${month}-${day} ${hours}:${minutes}`;
          } else {
            return `${year}-${month}-${day} ${hours}:${minutes}`;
          }
        }

        async function renderQzonePosts() {
          const postsListEl = document.getElementById("qzone-posts-list");
          if (!postsListEl) return;

          const [posts, favorites] = await Promise.all([
            db.qzonePosts.orderBy("timestamp").reverse().toArray(),
            db.favorites.where("type").equals("qzone_post").toArray(),
          ]);

          const favoritedPostIds = new Set(
            favorites.map((fav) => fav.content.id),
          );

          postsListEl.innerHTML = "";

          if (posts.length === 0) {
            postsListEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
            return;
          }

          const userSettings = state.qzoneSettings;

          posts.forEach((post) => {
            const postContainer = document.createElement("div");
            postContainer.className = "qzone-post-container";
            postContainer.dataset.postId = post.id;

            const postEl = document.createElement("div");
            postEl.className = "qzone-post-item";

            let authorAvatar = "",
              authorNickname = "",
              commentAvatar = userSettings.avatar;

            if (post.authorId === "user") {
              authorAvatar = userSettings.avatar;
              authorNickname = userSettings.nickname;
            } else if (state.chats[post.authorId]) {
              const authorChat = state.chats[post.authorId];
              authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
              authorNickname = authorChat.name;
            } else {
              authorAvatar = defaultAvatar;
              authorNickname = "{{char}}";
            }

            let contentHtml = "";
            const publicTextHtml = post.publicText
              ? `<div class="post-content">${post.publicText.replace(
                  /\n/g,
                  "<br>",
                )}</div>`
              : "";

            if (post.type === "shuoshuo") {
              contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(
                /\n/g,
                "<br>",
              )}</div>`;
            } else if (post.type === "image_post" && post.imageUrl) {
              contentHtml = publicTextHtml
                ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>`
                : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === "text_image") {
              contentHtml = publicTextHtml
                ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>`
                : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            }

            let likesHtml = "";
            if (post.likes && post.likes.length > 0) {
              likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join(
                "、",
              )} 觉得很赞</span></div>`;
            }

            let commentsHtml = "";
            if (post.comments && post.comments.length > 0) {
              commentsHtml = '<div class="post-comments-container">';
              // ★★★★★【核心修改就在这里】★★★★★
              // 遍历评论时，我们传入 comment 对象本身和它的索引 index
              post.comments.forEach((comment, index) => {
                // 在评论项的末尾，添加一个带有 data-comment-index 属性的删除按钮
                commentsHtml += `
                          <div class="comment-item">
                              <span class="commenter-name">${comment.commenterName}:</span>
                              <span class="comment-text">${comment.text}</span>
                              <span class="comment-delete-btn" data-comment-index="${index}">×</span>
                          </div>`;
              });
              // ★★★★★【修改结束】★★★★★
              commentsHtml += "</div>";
            }

            const userNickname = state.qzoneSettings.nickname;
            const isLikedByUser =
              post.likes && post.likes.includes(userNickname);
            const isFavoritedByUser = favoritedPostIds.has(post.id);

            postEl.innerHTML = `
                  <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(
                    post.timestamp,
                  )}</span></div>
                      <div class="post-actions-btn">…</div>
                  </div>
                  <div class="post-main-content">${contentHtml}</div>
                  <div class="post-feedback-icons">
                      <span class="action-icon like ${
                        isLikedByUser ? "active" : ""
                      }"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                      <span class="action-icon favorite ${
                        isFavoritedByUser ? "active" : ""
                      }"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                  </div>
                  ${likesHtml}
                  ${commentsHtml}
                  <div class="post-footer"><div class="comment-section"><img src="${commentAvatar}" class="comment-avatar"><input type="text" class="comment-input" placeholder="友善的评论是交流的起点"><div class="at-mention-popup"></div></div><button class="comment-send-btn">发送</button></div>
              `;

            const deleteAction = document.createElement("div");
            deleteAction.className = "qzone-post-delete-action";
            deleteAction.innerHTML = "<span>删除</span>";
            postContainer.appendChild(postEl);
            postContainer.appendChild(deleteAction);
            const commentSection =
              postContainer.querySelector(".comment-section");
            if (commentSection) {
              commentSection.addEventListener("touchstart", (e) =>
                e.stopPropagation(),
              );
              commentSection.addEventListener("mousedown", (e) =>
                e.stopPropagation(),
              );
            }
            postsListEl.appendChild(postContainer);
            const commentInput = postContainer.querySelector(".comment-input");
            const popup = postContainer.querySelector(".at-mention-popup");
            commentInput.addEventListener("input", () => {
              const value = commentInput.value;
              const atMatch = value.match(/@([\p{L}\w]*)$/u);
              if (atMatch) {
                const namesToMention = new Set();
                const authorNickname =
                  postContainer.querySelector(".post-nickname")?.textContent;
                if (authorNickname) namesToMention.add(authorNickname);
                postContainer
                  .querySelectorAll(".commenter-name")
                  .forEach((nameEl) => {
                    namesToMention.add(nameEl.textContent.replace(":", ""));
                  });
                namesToMention.delete(state.qzoneSettings.nickname);
                popup.innerHTML = "";
                if (namesToMention.size > 0) {
                  const searchTerm = atMatch[1];
                  namesToMention.forEach((name) => {
                    if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                      const item = document.createElement("div");
                      item.className = "at-mention-item";
                      item.textContent = name;
                      item.addEventListener("mousedown", (e) => {
                        e.preventDefault();
                        const newText =
                          value.substring(0, atMatch.index) + `@${name} `;
                        commentInput.value = newText;
                        popup.style.display = "none";
                        commentInput.focus();
                      });
                      popup.appendChild(item);
                    }
                  });
                  popup.style.display =
                    popup.children.length > 0 ? "block" : "none";
                } else {
                  popup.style.display = "none";
                }
              } else {
                popup.style.display = "none";
              }
            });
            commentInput.addEventListener("blur", () => {
              setTimeout(() => {
                popup.style.display = "none";
              }, 200);
            });
          });
        }

        function displayFilteredFavorites(items) {
          const listEl = document.getElementById("favorites-list");
          listEl.innerHTML = "";

          if (items.length === 0) {
            const searchTerm = document.getElementById(
              "favorites-search-input",
            ).value;
            const message = searchTerm
              ? "未找到相关收藏"
              : "你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！";
            listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
            return;
          }

          for (const item of items) {
            const card = document.createElement("div");
            card.className = "favorite-item-card";
            card.dataset.favid = item.id;

            let headerHtml = "",
              contentHtml = "",
              sourceText = "",
              footerHtml = "";

            if (item.type === "qzone_post") {
              const post = item.content;
              sourceText = "来自动态";
              let authorAvatar = defaultAvatar,
                authorNickname = "未知用户";

              if (post.authorId === "user") {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
              } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
              }

              headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;

              const publicTextHtml = post.publicText
                ? `<div class="post-content">${post.publicText.replace(
                    /\n/g,
                    "<br>",
                  )}</div>`
                : "";
              if (post.type === "shuoshuo") {
                contentHtml = `<div class="post-content">${post.content.replace(
                  /\n/g,
                  "<br>",
                )}</div>`;
              } else if (post.type === "image_post" && post.imageUrl) {
                contentHtml = publicTextHtml
                  ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>`
                  : `<img src="${post.imageUrl}" class="chat-image">`;
              } else if (post.type === "text_image") {
                contentHtml = publicTextHtml
                  ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>`
                  : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
              }

              // 1. 构造点赞区域的HTML
              let likesHtml = "";
              // 检查 post 对象中是否存在 likes 数组并且不为空
              if (post.likes && post.likes.length > 0) {
                // 如果存在，就创建点赞区域的 div
                likesHtml = `
                          <div class="post-likes-section">
                              <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                              <span>${post.likes.join("、")} 觉得很赞</span>
                          </div>`;
              }

              // 2. 构造评论区域的HTML
              let commentsHtml = "";
              // 检查 post 对象中是否存在 comments 数组并且不为空
              if (post.comments && post.comments.length > 0) {
                // 如果存在，就创建评论容器，并遍历每一条评论
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach((comment) => {
                  commentsHtml += `
                              <div class="comment-item">
                                  <span class="commenter-name">${comment.commenterName}:</span>
                                  <span class="comment-text">${comment.text}</span>
                              </div>`;
                });
                commentsHtml += "</div>";
              }

              // 3. 将点赞和评论的HTML组合到 footerHtml 中
              footerHtml = `${likesHtml}${commentsHtml}`;
            } else if (item.type === "chat_message") {
              const msg = item.content;
              const chat = state.chats[item.chatId];
              if (!chat) continue;

              sourceText = `来自与 ${chat.name} 的聊天`;
              const isUser = msg.role === "user";
              let senderName, senderAvatar;

              if (isUser) {
                // 用户消息的逻辑保持不变
                senderName = chat.isGroup
                  ? chat.settings.myNickname || "我"
                  : "我";
                senderAvatar =
                  chat.settings.myAvatar ||
                  (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
              } else {
                // AI/成员消息
                if (chat.isGroup) {
                  // ★★★★★ 这就是唯一的、核心的修改！ ★★★★★
                  // 我们现在使用 originalName 去匹配，而不是旧的 name
                  const member = chat.members.find(
                    (m) => m.originalName === msg.senderName,
                  );
                  // ★★★★★ 修改结束 ★★★★★

                  senderName = msg.senderName;
                  // 因为现在能正确找到 member 对象了，所以也能正确获取到他的头像
                  senderAvatar = member
                    ? member.avatar
                    : defaultGroupMemberAvatar;
                } else {
                  // 单聊的逻辑保持不变
                  senderName = chat.name;
                  senderAvatar = chat.settings.aiAvatar || defaultAvatar;
                }
              }

              // 后续拼接 headerHtml 和 contentHtml 的逻辑都保持不变
              headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;

              if (
                typeof msg.content === "string" &&
                STICKER_REGEX.test(msg.content)
              ) {
                contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
              } else if (
                Array.isArray(msg.content) &&
                msg.content[0]?.type === "image_url"
              ) {
                contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
              } else {
                contentHtml = `<div class="message-text-wrapper">${String(msg.content || "").replace(/\n/g, "<br>")}</div>`;
              }
            }

            card.innerHTML = `
                  <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
                  <div class="fav-card-content">${contentHtml}</div>
                  ${footerHtml}`; // <-- 把我们新创建的 footerHtml 放在这里

            listEl.appendChild(card);
          }
        }

        /**
         * 【重构后的函数】: 负责准备数据并触发渲染
         */
        async function renderFavoritesScreen() {
          // 1. 从数据库获取最新数据并缓存
          allFavoriteItems = await db.favorites
            .orderBy("timestamp")
            .reverse()
            .toArray();

          // 2. 清空搜索框并隐藏清除按钮
          const searchInput = document.getElementById("favorites-search-input");
          const clearBtn = document.getElementById(
            "favorites-search-clear-btn",
          );
          searchInput.value = "";
          clearBtn.style.display = "none";

          // 3. 显示所有收藏项
          displayFilteredFavorites(allFavoriteItems);
        }

        function resetCreatePostModal() {
          document.getElementById("post-public-text").value = "";
          document.getElementById("post-image-preview").src = "";
          document.getElementById("post-image-description").value = "";
          document
            .getElementById("post-image-preview-container")
            .classList.remove("visible");
          document.getElementById("post-image-desc-group").style.display =
            "none";
          document.getElementById("post-local-image-input").value = "";
          document.getElementById("post-hidden-text").value = "";
          document.getElementById("switch-to-image-mode").click();
        }

        async function exportBackup() {
          try {
            const backupData = {
              version: 2,
              timestamp: Date.now(),
            };

            const [
              chats,
              worldBooks,
              userStickers,
              apiConfigs,
              globalSettings,
              personaPresets,
              musicLibrary,
              qzoneSettings,
              qzonePosts,
              qzoneAlbums,
              qzonePhotos,
              favorites,
              qzoneGroups,
              memories,
              worldBookCategories,
              callRecords,
            ] = await Promise.all([
              db.chats.toArray(),
              db.worldBooks.toArray(),
              db.userStickers.toArray(),
              db.apiConfigs.toArray(),
              db.globalSettings.get("main"),
              db.personaPresets.toArray(),
              db.musicLibrary.get("main"),
              db.qzoneSettings.get("main"),
              db.qzonePosts.toArray(),
              db.qzoneAlbums.toArray(),
              db.qzonePhotos.toArray(),
              db.favorites.toArray(),
              db.qzoneGroups.toArray(),
              db.memories.toArray(),
              db.worldBookCategories.toArray(),
              db.callRecords.toArray(),
            ]);

            Object.assign(backupData, {
              chats,
              worldBooks,
              userStickers,
              apiConfigs,
              globalSettings,
              personaPresets,
              musicLibrary,
              qzoneSettings,
              qzonePosts,
              qzoneAlbums,
              qzonePhotos,
              favorites,
              qzoneGroups,
              memories,
              worldBookCategories,
              callRecords,
            });

            const blob = new Blob([JSON.stringify(backupData, null, 2)], {
              type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const link = Object.assign(document.createElement("a"), {
              href: url,
              download: `EPhone-Full-Backup-${
                new Date().toISOString().split("T")[0]
              }.json`,
            });
            link.click();
            URL.revokeObjectURL(url);

            await showCustomAlert("导出成功", "已成功导出所有数据！");
          } catch (error) {
            console.error("导出数据时出错:", error);
            await showCustomAlert(
              "导出失败",
              `发生了一个错误: ${error.message}`,
            );
          }
        }

        async function importBackup(file) {
          if (!file) return;

          const confirmed = await showCustomConfirm(
            "严重警告！",
            "导入备份将完全覆盖您当前的所有数据，包括聊天、动态、设置等。此操作不可撤销！您确定要继续吗？",
            { confirmButtonClass: "btn-danger" },
          );

          if (!confirmed) return;

          try {
            const text = await file.text();
            const data = JSON.parse(text);

            await db.transaction("rw", db.tables, async () => {
              for (const table of db.tables) {
                await table.clear();
              }

              if (Array.isArray(data.chats)) await db.chats.bulkPut(data.chats);
              if (Array.isArray(data.worldBooks))
                await db.worldBooks.bulkPut(data.worldBooks);
              if (Array.isArray(data.worldBookCategories))
                await db.worldBookCategories.bulkPut(data.worldBookCategories);
              if (Array.isArray(data.userStickers))
                await db.userStickers.bulkPut(data.userStickers);
              if (Array.isArray(data.personaPresets))
                await db.personaPresets.bulkPut(data.personaPresets);
              if (Array.isArray(data.qzonePosts))
                await db.qzonePosts.bulkPut(data.qzonePosts);
              if (Array.isArray(data.qzoneAlbums))
                await db.qzoneAlbums.bulkPut(data.qzoneAlbums);
              if (Array.isArray(data.qzonePhotos))
                await db.qzonePhotos.bulkPut(data.qzonePhotos);
              if (Array.isArray(data.favorites))
                await db.favorites.bulkPut(data.favorites);
              if (Array.isArray(data.qzoneGroups))
                await db.qzoneGroups.bulkPut(data.qzoneGroups);
              if (Array.isArray(data.memories))
                await db.memories.bulkPut(data.memories);
              if (Array.isArray(data.callRecords))
                await db.callRecords.bulkPut(data.callRecords);

              if (Array.isArray(data.apiConfigs)) {
                await db.apiConfigs.bulkPut(data.apiConfigs);
              } else if (data.apiConfig) {
                await db.apiConfigs.add({
                  name: "导入的旧配置",
                  url: data.apiConfig.proxyUrl || "",
                  apiKey: data.apiConfig.apiKey || "",
                  model: data.apiConfig.model || "",
                  enableStream: data.apiConfig.enableStream || false,
                  hideStreamResponse:
                    data.apiConfig.hideStreamResponse || false,
                });
                console.log("已将旧版API配置迁移到新结构。");
              }

              if (data.globalSettings) {
                await db.globalSettings.put(data.globalSettings);
              }

              if (data.musicLibrary)
                await db.musicLibrary.put(data.musicLibrary);
              if (data.qzoneSettings)
                await db.qzoneSettings.put(data.qzoneSettings);
            });

            await showCustomAlert(
              "导入成功",
              "所有数据已成功恢复！应用即将刷新以应用所有更改。",
            );

            setTimeout(() => {
              window.location.reload();
            }, 1500);
          } catch (error) {
            console.error("导入数据时出错:", error);
            await showCustomAlert(
              "导入失败",
              `文件格式不正确或数据已损坏: ${error.message}`,
            );
          }
        }
        function applyCustomFont(fontUrl, isPreviewOnly = false) {
          if (!fontUrl) {
            dynamicFontStyle.innerHTML = "";
            document.getElementById("font-preview").style.fontFamily = "";
            return;
          }
          const fontName = "custom-user-font";
          const newStyle = `
                      @font-face {
                        font-family: '${fontName}';
                        src: url('${fontUrl}');
                        font-display: swap;
                      }`;
          if (isPreviewOnly) {
            const previewStyle =
              document.getElementById("preview-font-style") ||
              document.createElement("style");
            previewStyle.id = "preview-font-style";
            previewStyle.innerHTML = newStyle;
            if (!document.getElementById("preview-font-style"))
              document.head.appendChild(previewStyle);
            document.getElementById("font-preview").style.fontFamily =
              `'${fontName}', 'bulangni', sans-serif`;
          } else {
            dynamicFontStyle.innerHTML = `
                          ${newStyle}
                          body {
                            font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                          }`;
          }
        }

        async function resetToDefaultFont() {
          dynamicFontStyle.innerHTML = "";
          state.globalSettings.fontUrl = "";
          await db.globalSettings.put(state.globalSettings);
          document.getElementById("font-url-input").value = "";
          document.getElementById("font-preview").style.fontFamily = "";
          alert("已恢复默认字体。");
        }

        async function loadAllDataFromDB() {
          const [
            chatsArr,
            apiConfigs, // <-- 修改这里
            globalSettings,
            userStickers,
            worldBooks,
            musicLib,
            personaPresets,
            qzoneSettings,
            initialFavorites,
          ] = await Promise.all([
            db.chats.toArray(),
            db.apiConfigs.toArray(), // <-- 修改这里
            db.globalSettings.get("main"),
            db.userStickers.toArray(),
            db.worldBooks.toArray(),
            db.musicLibrary.get("main"),
            db.personaPresets.toArray(),
            db.qzoneSettings.get("main"),
            db.favorites.orderBy("timestamp").reverse().toArray(),
          ]);

          state.chats = chatsArr.reduce((acc, chat) => {
            if (typeof chat.unreadCount === "undefined") {
              chat.unreadCount = 0; // 如果这个聊天对象没有 unreadCount 属性，就给它初始化为 0
            }

            // ★★★【核心重构：数据迁移脚本】★★★
            // 检查是否是群聊，并且其成员对象使用的是旧的 `name` 结构
            if (
              chat.isGroup &&
              chat.members &&
              chat.members.length > 0 &&
              chat.members[0].name
            ) {
              console.log(
                `检测到旧版群聊数据 for "${chat.name}"，正在执行迁移...`,
              );
              chat.members.forEach((member) => {
                // 如果这个成员对象没有 originalName，说明是旧数据
                if (typeof member.originalName === "undefined") {
                  member.originalName = member.name; // 将旧的 name 作为 originalName
                  member.groupNickname = member.name; // 同时创建一个初始的 groupNickname
                  delete member.name; // 删除旧的、有歧义的 name 字段
                  needsUpdate = true; // 标记需要存回数据库
                }
              });
              console.log(`迁移完成 for "${chat.name}"`);
            }

            // 检查1：如果是一个单聊，并且没有 status 属性
            if (!chat.isGroup && !chat.status) {
              // 就为它补上一个默认的 status 对象
              chat.status = {
                text: "在线",
                lastUpdate: Date.now(),
                isBusy: false,
              };
              console.log(`为旧角色 "${chat.name}" 补全了status属性。`);
            }

            // 检查2：兼容最新的“关系”功能
            if (!chat.isGroup && !chat.relationship) {
              // 如果是单聊，且没有 relationship 对象，就补上一个默认的
              chat.relationship = {
                status: "friend",
                blockedTimestamp: null,
                applicationReason: "",
              };
              console.log(`为旧角色 "${chat.name}" 补全了 relationship 属性。`);
            }

            if (
              !chat.isGroup &&
              (!chat.settings || !chat.settings.aiAvatarLibrary)
            ) {
              if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
              chat.settings.aiAvatarLibrary = [];
              console.log(
                `为旧角色 "${chat.name}" 补全了aiAvatarLibrary属性。`,
              );
            }

            if (!chat.settings.summary) {
              chat.settings.summary = {
                enabled: false,
                mode: "manual", // 'manual' or 'auto'
                count: 50, // summarize every 50 messages
                prompt: "请总结上述对话的主要内容，保留重要信息和情感脉络。",
                lastSummaryIndex: -1,
                useCustomApi: false,
                customApiUrl: "",
                customApiKey: "",
                customModel: "gpt-4o-mini",
                enableStream: false,
              };
            } else {
              // Migration for existing chats
              if (chat.settings.summary.useCustomApi === undefined) {
                chat.settings.summary.useCustomApi = false;
                chat.settings.summary.customApiUrl = "";
                chat.settings.summary.customApiKey = "";
                chat.settings.summary.customModel = "gpt-4o-mini";
                chat.settings.summary.enableStream = false;
              }
            }

            if (!chat.musicData) chat.musicData = { totalTime: 0 };
            if (
              chat.settings &&
              chat.settings.linkedWorldBookId &&
              !chat.settings.linkedWorldBookIds
            ) {
              chat.settings.linkedWorldBookIds = [
                chat.settings.linkedWorldBookId,
              ];
              delete chat.settings.linkedWorldBookId;
            }
            acc[chat.id] = chat;
            return acc;
          }, {});
          state.apiConfigs = apiConfigs || [];

          state.globalSettings = globalSettings || {
            id: "main",
            wallpaper: "linear-gradient(135deg, #89f7fe, #66a6ff)",
            fontUrl: "",
            enableBackgroundActivity: false,
            backgroundActivityInterval: 60,
            blockCooldownHours: 1,
            appIcons: { ...DEFAULT_APP_ICONS }, // 【核心修改】确保appIcons存在并有默认值
            framelessOnMobile: false, // 【核心新增】默认不开启无边框模式
            frameColor: "#ffffff", // 【核心新增】默认外框颜色
            showSizePanel: false, // 新增：默认隐藏尺寸控制面板
          };
          // 【核心修改】合并已保存的图标和默认图标，防止更新后旧数据丢失新图标
          state.globalSettings.appIcons = {
            ...DEFAULT_APP_ICONS,
            ...(state.globalSettings.appIcons || {}),
          };

          state.userStickers = userStickers || [];
          state.worldBooks = worldBooks || [];
          musicState.playlist = musicLib?.playlist || [];
          state.personaPresets = personaPresets || [];
          state.qzoneSettings = qzoneSettings || {
            id: "main",
            nickname: "{{user}}",
            avatar: "https://files.catbox.moe/q6z5fc.jpeg",
            banner: "https://files.catbox.moe/r5heyt.gif",
          };

          allFavoriteItems = initialFavorites || [];
        }

        async function saveGlobalPlaylist() {
          await db.musicLibrary.put({
            id: "main",
            playlist: musicState.playlist,
          });
        }

        function formatTimestamp(timestamp) {
          if (!timestamp) return "";
          const date = new Date(timestamp);
          const hours = String(date.getHours()).padStart(2, "0");
          const minutes = String(date.getMinutes()).padStart(2, "0");
          return `${hours}:${minutes}`;
        }

        function showNotification(chatId, messageContent) {
          clearTimeout(notificationTimeout);
          const chat = state.chats[chatId];
          if (!chat) return;
          const bar = document.getElementById("notification-bar");
          document.getElementById("notification-avatar").src =
            chat.settings.aiAvatar ||
            chat.settings.groupAvatar ||
            defaultAvatar;
          document
            .getElementById("notification-content")
            .querySelector(".name").textContent = chat.name;
          document
            .getElementById("notification-content")
            .querySelector(".message").textContent = messageContent;
          const newBar = bar.cloneNode(true);
          bar.parentNode.replaceChild(newBar, bar);
          newBar.addEventListener("click", () => {
            openChat(chatId);
            newBar.classList.remove("visible");
          });
          newBar.classList.add("visible");
          notificationTimeout = setTimeout(() => {
            newBar.classList.remove("visible");
          }, 4000);
        }

        function updateClock() {
          const now = new Date();
          const timeString = now.toLocaleTimeString("zh-CN", {
            hour: "2-digit",
            minute: "2-digit",
          });
          const dateString = now.toLocaleDateString("zh-CN", {
            weekday: "long",
            month: "long",
            day: "numeric",
          });
          document.getElementById("main-time").textContent = timeString;
          document.getElementById("status-bar-time").textContent = timeString;
          document.getElementById("main-date").textContent = dateString;
        }

        /**
         * 【终极健壮版】解析AI返回的、可能格式不规范的响应内容
         * @param {string} content - AI返回的原始字符串
         * @returns {Array} - 一个标准化的消息对象数组
         */
        function parseAiResponse(content) {
          const trimmedContent = content.trim();

          // 方案1：【最优先】尝试作为标准的、单一的JSON数组解析
          // 这是最理想、最高效的情况
          if (trimmedContent.startsWith("[") && trimmedContent.endsWith("]")) {
            try {
              const parsed = JSON.parse(trimmedContent);
              if (Array.isArray(parsed)) {
                console.log("解析成功：标准JSON数组格式。");
                return parsed;
              }
            } catch (e) {
              // 如果解析失败，说明它虽然看起来像个数组，但内部格式有问题。
              // 此时我们不报错，而是继续尝试下面的“强力解析”方案。
              console.warn("标准JSON数组解析失败，将尝试强力解析...");
            }
          }

          // 方案2：【强力解析】使用正则表达式，从混乱的字符串中提取出所有独立的JSON对象
          // 这能完美解决您遇到的 "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" 这种格式
          const jsonMatches = trimmedContent.match(/{[^{}]*}/g);

          if (jsonMatches) {
            const results = [];
            for (const match of jsonMatches) {
              try {
                // 尝试解析每一个被我们“揪”出来的JSON字符串
                const parsedObject = JSON.parse(match);
                results.push(parsedObject);
              } catch (e) {
                // 如果某个片段不是有效的JSON，就忽略它，继续处理下一个
                console.warn("跳过一个无效的JSON片段:", match);
              }
            }

            // 如果我们成功提取出了至少一个有效的JSON对象，就返回这个结果
            if (results.length > 0) {
              console.log("解析成功：通过强力提取模式。");
              return results;
            }
          }

          // 方案3：【最终备用】如果以上所有方法都失败了，说明AI返回的可能就是纯文本
          // 我们将原始的、未处理的内容，包装成一个标准的文本消息对象返回，确保程序不会崩溃
          console.error("所有解析方案均失败！将返回原始文本。");
          return [{ type: "text", content: content }];
        }

        function getBackgroundActivityOptions(chat) {
          const defaultOptions = {
            allowChat: true,
            allowPost: true,
            allowReply: true,
          };
          const storedOptions = chat?.settings?.backgroundActivityOptions || {};
          return { ...defaultOptions, ...storedOptions };
        }

        function hasAnyBackgroundActivityEnabled(chat) {
          const options = getBackgroundActivityOptions(chat);
          return options.allowChat || options.allowPost || options.allowReply;
        }

        function renderApiSettings() {
          // 渲染其他全局设置（保持不变）
          document.getElementById("background-activity-switch").checked =
            state.globalSettings.enableBackgroundActivity || false;
          document.getElementById("background-interval-input").value =
            state.globalSettings.backgroundActivityInterval || 60;
          document.getElementById("block-cooldown-input").value =
            state.globalSettings.blockCooldownHours || 1;

          const roleSettingsEl = document.getElementById(
            "role-activity-settings",
          );
          if (roleSettingsEl) {
            const singleChats = Object.values(state.chats).filter(
              (chat) => !chat.isGroup,
            );
            roleSettingsEl.innerHTML = "";
            if (singleChats.length === 0) {
              roleSettingsEl.innerHTML =
                '<div style="padding: 12px 16px; color: var(--text-secondary);">暂无角色</div>';
            } else {
              singleChats.forEach((chat) => {
                const options = getBackgroundActivityOptions(chat);
                const item = document.createElement("div");
                item.className = "role-activity-item";
                item.innerHTML = `
                  <div class="role-name">${chat.name}</div>
                  <div class="role-activity-options">
                    <label class="role-activity-option">
                      <input
                        type="checkbox"
                        data-chat-id="${chat.id}"
                        data-activity-option="allowChat"
                        ${options.allowChat ? "checked" : ""}
                      />
                      正常聊天
                    </label>
                    <label class="role-activity-option">
                      <input
                        type="checkbox"
                        data-chat-id="${chat.id}"
                        data-activity-option="allowPost"
                        ${options.allowPost ? "checked" : ""}
                      />
                      发布动态
                    </label>
                    <label class="role-activity-option">
                      <input
                        type="checkbox"
                        data-chat-id="${chat.id}"
                        data-activity-option="allowReply"
                        ${options.allowReply ? "checked" : ""}
                      />
                      回复动态
                    </label>
                  </div>
                `;
                roleSettingsEl.appendChild(item);
              });
            }
          }

          // 渲染API配置列表
          const listEl = document.getElementById("api-configs-list");
          listEl.innerHTML = "";
          if (state.apiConfigs.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary);">还没有任何配置，请点击“添加”创建一个</p>';
          }

          const activeId = state.globalSettings.activeApiConfigId;

          state.apiConfigs.forEach((config) => {
            const item = document.createElement("div");
            item.className = "api-config-item";
            item.dataset.configId = config.id;
            item.innerHTML = `
              <div class="config-main">
                  <input type="radio" name="active_api_config" ${
                    config.id === activeId ? "checked" : ""
                  }>
                  <div class="config-details">
                      <span class="config-name">${config.name}</span>
                      <span class="config-url">${
                        config.url || "URL未设置"
                      }</span>
                  </div>
              </div>
              <div class="config-actions">
                  <button type="button" class="edit-btn">编辑</button>
                  <button type="button" class="delete-btn">删除</button>
              </div>
            `;
            listEl.appendChild(item);
          });
        }
        async function openApiConfigEditor(configId = null) {
          let config = {
            name: "",
            url: "",
            apiKey: "",
            model: "gpt-4o",
            enableStream: true,
            hideStreamResponse: false,
            temperature: 0.8, // 默认值
            topP: 1.0, // 默认值
            topK: 40, // 默认值
            enableTemp: false,
            enableTopP: false,
            enableTopK: false,
          };
          if (configId) {
            config = state.apiConfigs.find((c) => c.id === configId) || config;
          }

          // 填充基本信息
          document.getElementById("config-editor-id").value = configId || "";
          document.getElementById("config-name-input").value = config.name;
          document.getElementById("config-url-input").value = config.url;
          document.getElementById("config-key-input").value = config.apiKey;

          // --- 【核心修复】 ---
          // 每次打开时，都重置模型下拉列表，只显示当前配置已保存的模型
          const modelSelect = document.getElementById("config-model-select");
          // 1. 清空所有旧的 <option> 元素
          modelSelect.innerHTML = "";
          // 2. 创建一个只包含当前已保存模型的新 <option>
          const savedModelOption = document.createElement("option");
          savedModelOption.value = config.model;
          savedModelOption.textContent = config.model;
          savedModelOption.selected = true;
          // 3. 将这个唯一的选项添加到下拉列表中
          modelSelect.appendChild(savedModelOption);
          // --- 【修复结束】 ---

          // --- 迁移逻辑：兼容旧的 enableAdvancedParams ---
          // 如果旧配置有 enableAdvancedParams，但没有新的独立开关，则继承旧开关的值
          if (config.enableAdvancedParams !== undefined) {
            if (config.enableTemp === undefined)
              config.enableTemp = config.enableAdvancedParams;
            if (config.enableTopP === undefined)
              config.enableTopP = config.enableAdvancedParams;
            if (config.enableTopK === undefined)
              config.enableTopK = config.enableAdvancedParams;
          }

          // 填充值
          document.getElementById("config-temperature-input").value =
            config.temperature !== undefined ? config.temperature : 0.8;
          document.getElementById("config-topp-input").value =
            config.topP !== undefined ? config.topP : 1.0;
          document.getElementById("config-topk-input").value =
            config.topK !== undefined ? config.topK : 40;

          // 填充开关状态
          document.getElementById("config-stream-switch").checked =
            config.enableStream;
          document.getElementById("config-hide-stream-switch").checked =
            config.hideStreamResponse;

          const tempCheck = document.getElementById("config-enable-temp");
          const toppCheck = document.getElementById("config-enable-topp");
          const topkCheck = document.getElementById("config-enable-topk");
          const tempInput = document.getElementById("config-temperature-input");
          const toppInput = document.getElementById("config-topp-input");
          const topkInput = document.getElementById("config-topk-input");

          // 设置初始状态 (默认 false)
          tempCheck.checked = !!config.enableTemp;
          toppCheck.checked = !!config.enableTopP;
          topkCheck.checked = !!config.enableTopK;

          function updateInputState(checkbox, input) {
            input.disabled = !checkbox.checked;
            input.style.opacity = checkbox.checked ? "1" : "0.5";
          }

          // 初始化 UI 状态
          updateInputState(tempCheck, tempInput);
          updateInputState(toppCheck, toppInput);
          updateInputState(topkCheck, topkInput);

          // 绑定事件
          tempCheck.onchange = (e) => updateInputState(e.target, tempInput);
          toppCheck.onchange = (e) => updateInputState(e.target, toppInput);
          topkCheck.onchange = (e) => updateInputState(e.target, topkInput);

          // 显示模态框
          document
            .getElementById("api-config-editor-modal")
            .classList.add("visible");
        }

        async function saveApiConfig() {
          const id = document.getElementById("config-editor-id").value;

          // 获取并验证新参数
          let temp = parseFloat(
            document.getElementById("config-temperature-input").value,
          );
          let topP = parseFloat(
            document.getElementById("config-topp-input").value,
          );
          let topK = parseInt(
            document.getElementById("config-topk-input").value,
          );

          if (isNaN(temp)) temp = 0.8;
          if (isNaN(topP)) topP = 1.0;
          if (isNaN(topK)) topK = 40;

          const configData = {
            name:
              document.getElementById("config-name-input").value.trim() ||
              "未命名配置",
            url: document.getElementById("config-url-input").value.trim(),
            apiKey: document.getElementById("config-key-input").value.trim(),
            model: document.getElementById("config-model-select").value,
            temperature: temp,
            topP: topP,
            topK: topK,
            // 保存独立开关状态
            enableTemp: document.getElementById("config-enable-temp").checked,
            enableTopP: document.getElementById("config-enable-topp").checked,
            enableTopK: document.getElementById("config-enable-topk").checked,
            // 保留旧字段以备不时之需（或者直接弃用，这里选择更新它为 OR 逻辑，或直接忽略）
            // 为了整洁，我们不再保存 enableAdvancedParams，因为它已经被拆分了。
            enableStream: document.getElementById("config-stream-switch")
              .checked,
            hideStreamResponse: document.getElementById(
              "config-hide-stream-switch",
            ).checked,
          };

          if (id) {
            // 更新
            configData.id = parseInt(id);
            await db.apiConfigs.put(configData);
            const index = state.apiConfigs.findIndex(
              (c) => c.id === configData.id,
            );
            if (index > -1) state.apiConfigs[index] = configData;
          } else {
            // 新增
            const newId = await db.apiConfigs.add(configData);
            configData.id = newId;
            state.apiConfigs.push(configData);
            // 如果是第一个配置，自动设为激活
            if (state.apiConfigs.length === 1) {
              state.globalSettings.activeApiConfigId = newId;
              await db.globalSettings.put(state.globalSettings);
            }
          }

          renderApiSettings();
          document
            .getElementById("api-config-editor-modal")
            .classList.remove("visible");
        }

        async function setActiveApiConfig(configId) {
          state.globalSettings.activeApiConfigId = configId;
          await db.globalSettings.put(state.globalSettings);
          // 可以在这里给一个轻量提示，或者什么都不做
          console.log(`Active API config set to ID: ${configId}`);
        }
        window.renderApiSettingsProxy = renderApiSettings;

        async function renderChatList() {
          const chatListEl = document.getElementById("chat-list");
          chatListEl.innerHTML = "";

          // 1. 像以前一样，获取所有聊天并按最新消息时间排序
          const allChats = Object.values(state.chats).sort(
            (a, b) =>
              (b.history.slice(-1)[0]?.timestamp || 0) -
              (a.history.slice(-1)[0]?.timestamp || 0),
          );

          // 2. 获取所有分组
          const allGroups = await db.qzoneGroups.toArray();

          if (allChats.length === 0) {
            chatListEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
            return;
          }

          // --- 【核心修正开始】---

          // 3. 为每个分组找到其内部最新的消息时间戳
          allGroups.forEach((group) => {
            // 从已排序的 allChats 中找到本组的第一个（也就是最新的）聊天
            const latestChatInGroup = allChats.find(
              (chat) => chat.groupId === group.id,
            );
            // 如果找到了，就用它的时间戳；如果该分组暂时没有聊天或聊天没有历史记录，就用0
            group.latestTimestamp = latestChatInGroup
              ? latestChatInGroup.history.slice(-1)[0]?.timestamp || 0
              : 0;
          });

          // 4. 根据这个最新的时间戳来对“分组本身”进行排序
          allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

          // --- 【核心修正结束】---

          // 5. 现在，我们按照排好序的分组来渲染
          allGroups.forEach((group) => {
            // 从总列表里过滤出属于这个（已排序）分组的好友
            const groupChats = allChats.filter(
              (chat) => !chat.isGroup && chat.groupId === group.id,
            );
            // 如果这个分组是空的（可能所有好友都被删了），就跳过
            if (groupChats.length === 0) return;

            const groupContainer = document.createElement("div");
            groupContainer.className = "chat-group-container";
            groupContainer.innerHTML = `
                  <div class="chat-group-header">
                      <span class="group-name">${group.name}</span>
                  </div>
                  <div class="chat-group-content"></div>
              `;
            const contentEl = groupContainer.querySelector(
              ".chat-group-content",
            );
            // 因为 allChats 本身就是有序的，所以 groupChats 自然也是有序的
            groupChats.forEach((chat) => {
              const item = createChatListItem(chat);
              contentEl.appendChild(item);
            });
            chatListEl.appendChild(groupContainer);
          });

          // 6. 最后，渲染所有群聊和未分组的好友
          // 他们的顺序因为 allChats 的初始排序，天然就是正确的
          const ungroupedOrGroupChats = allChats.filter(
            (chat) => chat.isGroup || (!chat.isGroup && !chat.groupId),
          );
          ungroupedOrGroupChats.forEach((chat) => {
            const item = createChatListItem(chat);
            chatListEl.appendChild(item);
          });

          // 为所有分组标题添加折叠事件
          document.querySelectorAll(".chat-group-header").forEach((header) => {
            header.addEventListener("click", () => {
              header.classList.toggle("collapsed");
              header.nextElementSibling.classList.toggle("collapsed");
            });
          });
        }

        function createChatListItem(chat) {
          const lastMsgObj =
            chat.history.filter((msg) => !msg.isHidden).slice(-1)[0] || {};
          let lastMsgDisplay;

          if (
            !chat.isGroup &&
            chat.relationship?.status === "pending_user_approval"
          ) {
            lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${
              chat.relationship.applicationReason || "请求添加你为好友"
            }</span>`;
          } else if (
            !chat.isGroup &&
            chat.relationship?.status === "blocked_by_ai"
          ) {
            lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
          }

          // 【核心修改】优先显示状态，而不是最后一条消息
          if (chat.isGroup) {
            // 群聊逻辑保持不变
            if (lastMsgObj.type === "pat_message") {
              lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`;
            }
            // ... (其他群聊消息类型判断) ...
            else if (lastMsgObj.type === "transfer") {
              lastMsgDisplay = "[转账]";
            } else if (
              lastMsgObj.type === "ai_image" ||
              lastMsgObj.type === "user_photo"
            ) {
              lastMsgDisplay = "[照片]";
            } else if (lastMsgObj.type === "voice_message") {
              lastMsgDisplay = "[语音]";
            } else if (
              typeof lastMsgObj.content === "string" &&
              STICKER_REGEX.test(lastMsgObj.content)
            ) {
              lastMsgDisplay = lastMsgObj.meaning
                ? `[表情: ${lastMsgObj.meaning}]`
                : "[表情]";
            } else if (Array.isArray(lastMsgObj.content)) {
              lastMsgDisplay = `[图片]`;
            } else {
              lastMsgDisplay = String(lastMsgObj.content || "...").substring(
                0,
                20,
              );
            }

            if (lastMsgObj.senderName && lastMsgObj.type !== "pat_message") {
              lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
            }
          } else {
            // 单聊逻辑：显示状态
            // 确保 chat.status 对象存在
            const statusText = chat.status?.text || "在线";
            lastMsgDisplay = `[${statusText}]`;
          }

          const item = document.createElement("div");
          item.className = "chat-list-item";
          item.dataset.chatId = chat.id;
          const avatar = chat.isGroup
            ? chat.settings.groupAvatar
            : chat.settings.aiAvatar;

          item.innerHTML = `
              <img src="${avatar || defaultAvatar}" class="avatar">
              <div class="info">
                  <div class="name-line">
                      <span class="name">${chat.name}</span>
                      ${
                        chat.isGroup
                          ? '<span class="group-tag">群聊</span>'
                          : ""
                      }
                  </div>
                  <div class="last-msg" style="color: ${
                    chat.isGroup ? "var(--text-secondary)" : "#b5b5b5"
                  }; font-style: italic;">${lastMsgDisplay}</div>
              </div>
              <!-- 这里就是我们新加的红点HTML结构 -->
              <div class="unread-count-wrapper">
                  <span class="unread-count" style="display: none;">0</span>
              </div>
          `;

          // 【核心修改2】在这里添加控制红点显示/隐藏的逻辑
          const unreadCount = chat.unreadCount || 0;
          const unreadEl = item.querySelector(".unread-count");
          if (unreadCount > 0) {
            unreadEl.textContent = unreadCount > 99 ? "99+" : unreadCount;
            // 注意这里是 'inline-flex'，与我们的CSS对应，使其垂直居中
            unreadEl.style.display = "inline-flex";
          } else {
            unreadEl.style.display = "none";
          }

          const avatarEl = item.querySelector(".avatar");
          if (avatarEl) {
            avatarEl.style.cursor = "pointer";
            avatarEl.addEventListener("click", (e) => {
              e.stopPropagation();
              handleUserPat(chat.id, chat.name);
            });
          }

          const infoEl = item.querySelector(".info");
          if (infoEl) {
            infoEl.addEventListener("click", () => openChat(chat.id));
          }

          addLongPressListener(item, async (e) => {
            const confirmed = await showCustomConfirm(
              "删除对话",
              `确定要删除与 "${chat.name}" 的整个对话吗？此操作不可撤销。`,
              { confirmButtonClass: "btn-danger" },
            );
            if (confirmed) {
              if (musicState.isActive && musicState.activeChatId === chat.id)
                await endListenTogetherSession(false);
              delete state.chats[chat.id];
              if (state.activeChatId === chat.id) state.activeChatId = null;
              await db.chats.delete(chat.id);
              renderChatList();
            }
          });
          return item;
        }

        function renderChatInterface(chatId) {
          cleanupWaimaiTimers();
          const chat = state.chats[chatId];
          if (!chat) return;
          exitSelectionMode();

          const messagesContainer = document.getElementById("chat-messages");
          const chatInputArea = document.getElementById("chat-input-area");
          const lockOverlay = document.getElementById("chat-lock-overlay");
          const lockContent = document.getElementById("chat-lock-content");

          messagesContainer.dataset.theme = chat.settings.theme || "default";
          const fontSize = chat.settings.fontSize || 13;
          messagesContainer.style.setProperty(
            "--chat-font-size",
            `${fontSize}px`,
          );
          applyScopedCss(
            chat.settings.customCss || "",
            "#chat-messages",
            "custom-bubble-style",
          );

          document.getElementById("chat-header-title").textContent = chat
            .settings.aiRemark
            ? `${chat.name} | ${chat.settings.aiRemark}`
            : chat.name;
          const statusContainer = document.getElementById("chat-header-status");
          const statusTextEl = statusContainer.querySelector(".status-text");

          if (chat.isGroup) {
            statusContainer.style.display = "none";
            document.getElementById(
              "chat-header-title-wrapper",
            ).style.justifyContent = "center";
          } else {
            statusContainer.style.display = "flex";
            document.getElementById(
              "chat-header-title-wrapper",
            ).style.justifyContent = "flex-start";
            statusTextEl.textContent = chat.status?.text || "在线";
            statusContainer.classList.toggle(
              "busy",
              chat.status?.isBusy || false,
            );
          }

          lockOverlay.style.display = "none";
          chatInputArea.style.visibility = "visible";
          lockContent.innerHTML = "";

          if (!chat.isGroup && chat.relationship.status !== "friend") {
            lockOverlay.style.display = "flex";
            chatInputArea.style.visibility = "hidden";

            let lockHtml = "";
            switch (chat.relationship.status) {
              case "blocked_by_user":
                // --- 【核心修改：在这里加入诊断面板】 ---
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours =
                  state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(
                  0,
                  Math.ceil(
                    (cooldownMilliseconds - timeSinceBlock) / (1000 * 60),
                  ),
                );

                lockHtml = `
                          <span class="lock-text">你已将“${
                            chat.name
                          }”拉黑。</span>
                          <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                          <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                              <strong style="color: #333;">【开发者诊断面板】</strong><br>
                              - 后台活动总开关: ${
                                state.globalSettings.enableBackgroundActivity
                                  ? '<span style="color: green;">已开启</span>'
                                  : '<span style="color: red;">已关闭</span>'
                              }<br>
                              - 系统心跳计时器: ${
                                isSimulationRunning
                                  ? '<span style="color: green;">运行中</span>'
                                  : '<span style="color: red;">未运行</span>'
                              }<br>
                              - 当前角色状态: <strong>${
                                chat.relationship.status
                              }</strong><br>
                              - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                              - 冷静期是否结束: ${
                                isCooldownOver
                                  ? '<span style="color: green;">是</span>'
                                  : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`
                              }<br>
                              - 触发条件: ${
                                isCooldownOver &&
                                state.globalSettings.enableBackgroundActivity
                                  ? '<span style="color: green;">已满足，等待下次系统心跳</span>'
                                  : '<span style="color: red;">未满足</span>'
                              }
                          </div>
                          <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">强制触发一次好友申请检测</button>
                      `;
                // --- 【修改结束】 ---
                break;
              case "blocked_by_ai":
                lockHtml = `
                          <span class="lock-text">你被对方拉黑了。</span>
                          <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                      `;
                break;

              case "pending_user_approval":
                lockHtml = `
                          <span class="lock-text">“${chat.name}”请求添加你为好友：<br><i>“${chat.relationship.applicationReason}”</i></span>
                          <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                          <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
                      `;
                break;

              // 【核心修正】修复当你申请后，你看到的界面
              case "pending_ai_approval":
                lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
                break;
            }
            lockContent.innerHTML = lockHtml;
          }
          messagesContainer.innerHTML = "";
          // ...后续代码保持不变
          const chatScreen = document.getElementById("chat-interface-screen");
          chatScreen.style.backgroundImage = chat.settings.background
            ? `url(${chat.settings.background})`
            : "none";

          const isDarkMode = document
            .getElementById("phone-screen")
            .classList.contains("dark-mode");
          chatScreen.style.backgroundColor = chat.settings.background
            ? "transparent"
            : isDarkMode
              ? "#000000"
              : "#f0f2f5";
          const history = chat.history;
          const totalMessages = history.length;
          currentRenderedCount = 0;
          const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
          initialMessages.forEach((msg) => appendMessage(msg, chat, true));
          currentRenderedCount = initialMessages.length;
          if (totalMessages > currentRenderedCount) {
            prependLoadMoreButton(messagesContainer);
          }
          const typingIndicator = document.createElement("div");
          typingIndicator.id = "typing-indicator";
          typingIndicator.style.display = "none";
          typingIndicator.innerHTML =
            '<div class="system-bubble">对方正在输入...</div>';
          messagesContainer.appendChild(typingIndicator);
          setTimeout(
            () =>
              (messagesContainer.scrollTop = messagesContainer.scrollHeight),
            0,
          );
        }

        function prependLoadMoreButton(container) {
          const button = document.createElement("button");
          button.id = "load-more-btn";
          button.textContent = "加载更早的记录";
          button.addEventListener("click", loadMoreMessages);
          container.prepend(button);
        }

        function loadMoreMessages() {
          const messagesContainer = document.getElementById("chat-messages");
          const chat = state.chats[state.activeChatId];
          if (!chat) return;
          const loadMoreBtn = document.getElementById("load-more-btn");
          if (loadMoreBtn) loadMoreBtn.remove();
          const totalMessages = chat.history.length;
          const nextSliceStart =
            totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW;
          const nextSliceEnd = totalMessages - currentRenderedCount;
          const messagesToPrepend = chat.history.slice(
            Math.max(0, nextSliceStart),
            nextSliceEnd,
          );
          const oldScrollHeight = messagesContainer.scrollHeight;
          messagesToPrepend
            .reverse()
            .forEach((msg) => prependMessage(msg, chat));
          currentRenderedCount += messagesToPrepend.length;
          const newScrollHeight = messagesContainer.scrollHeight;
          messagesContainer.scrollTop += newScrollHeight - oldScrollHeight;
          if (totalMessages > currentRenderedCount) {
            prependLoadMoreButton(messagesContainer);
          }
        }

        function renderWallpaperScreen() {
          const preview = document.getElementById("wallpaper-preview");
          const bg = newWallpaperBase64 || state.globalSettings.wallpaper;
          if (bg && bg.startsWith("data:image")) {
            preview.style.backgroundImage = `url(${bg})`;
            preview.textContent = "";
          } else if (bg) {
            preview.style.backgroundImage = bg;
            preview.textContent = "当前为渐变色";
          }
          // 【核心修改】在这里调用图标渲染函数
          renderIconSettings();

          const frameColorInput = document.getElementById("frame-color-input");
          const frameColorValue = document.getElementById("frame-color-value");
          const currentFrameColor =
            state.globalSettings.phoneFrameColor || "#ffffff";
          frameColorInput.value = currentFrameColor;
          frameColorValue.textContent = currentFrameColor;
        }
        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() {
          const homeScreen = document.getElementById("home-screen");
          const wallpaper = state.globalSettings.wallpaper;
          if (wallpaper && wallpaper.startsWith("data:image"))
            homeScreen.style.backgroundImage = `url(${wallpaper})`;
          else if (wallpaper) homeScreen.style.backgroundImage = wallpaper;

          const phoneFrame = document.getElementById("phone-frame");
          const customColor = state.globalSettings.phoneFrameColor;

          if (customColor) {
            phoneFrame.style.backgroundColor = customColor;
          } else {
            // 如果没有自定义颜色，则清除内联样式，让CSS类（如.dark-mode）生效
            phoneFrame.style.backgroundColor = "";
          }
        }

        async function renderWorldBookScreen() {
          const listEl = document.getElementById("world-book-list");
          listEl.innerHTML = "";

          // 1. 同时获取所有书籍和所有分类
          const [books, categories] = await Promise.all([
            db.worldBooks.toArray(),
            db.worldBookCategories.orderBy("name").toArray(),
          ]);

          state.worldBooks = books; // 确保内存中的数据是同步的

          if (books.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 创建你的第一本世界书</p>';
            return;
          }

          // 2. 将书籍按 categoryId 分组
          const groupedBooks = books.reduce((acc, book) => {
            const key = book.categoryId || "uncategorized";
            if (!acc[key]) {
              acc[key] = [];
            }
            acc[key].push(book);
            return acc;
          }, {});

          // 3. 优先渲染已分类的书籍
          categories.forEach((category) => {
            const booksInCategory = groupedBooks[category.id];
            if (booksInCategory && booksInCategory.length > 0) {
              const groupContainer = createWorldBookGroup(
                category.name,
                booksInCategory,
              );
              listEl.appendChild(groupContainer);
            }
          });

          // 4. 最后渲染未分类的书籍
          const uncategorizedBooks = groupedBooks["uncategorized"];
          if (uncategorizedBooks && uncategorizedBooks.length > 0) {
            const groupContainer = createWorldBookGroup(
              "未分类",
              uncategorizedBooks,
            );
            listEl.appendChild(groupContainer);
          }

          // 5. 为所有分组标题添加折叠事件
          document
            .querySelectorAll(".world-book-group-header")
            .forEach((header) => {
              header.addEventListener("click", () => {
                header.classList.toggle("collapsed");
                header.nextElementSibling.classList.toggle("collapsed");
              });
            });
        }

        /**
         * 【辅助函数】创建一个分类的分组DOM
         * @param {string} groupName - 分类名称
         * @param {Array} books - 该分类下的书籍数组
         * @returns {HTMLElement} - 创建好的分组容器
         */
        function createWorldBookGroup(groupName, books) {
          const groupContainer = document.createElement("div");
          groupContainer.className = "world-book-group-container";

          groupContainer.innerHTML = `
              <div class="world-book-group-header">
                  <span class="group-name">${groupName}</span>
              </div>
              <div class="world-book-group-content"></div>
          `;

          const headerEl = groupContainer.querySelector(
            ".world-book-group-header",
          );
          const contentEl = groupContainer.querySelector(
            ".world-book-group-content",
          );

          // 默认给头部和内容区都加上 collapsed 类
          headerEl.classList.add("collapsed");
          contentEl.classList.add("collapsed");

          books.sort((a, b) => a.name.localeCompare(b.name, "zh-CN"));
          books.forEach((book) => {
            const item = document.createElement("div");
            item.className = "list-item";
            item.dataset.bookId = book.id;
            item.innerHTML = `<div class="item-title">${
              book.name
            }</div><div class="item-content">${(
              book.content || "暂无内容..."
            ).substring(0, 50)}</div>`;
            item.addEventListener("click", () => openWorldBookEditor(book.id));
            addLongPressListener(item, async () => {
              const confirmed = await showCustomConfirm(
                "删除世界书",
                `确定要删除《${book.name}》吗？此操作不可撤销。`,
                { confirmButtonClass: "btn-danger" },
              );
              if (confirmed) {
                await db.worldBooks.delete(book.id);
                state.worldBooks = state.worldBooks.filter(
                  (wb) => wb.id !== book.id,
                );
                renderWorldBookScreen();
              }
            });
            contentEl.appendChild(item);
          });

          return groupContainer;
        }
        window.renderWorldBookScreenProxy = renderWorldBookScreen;

        async function openWorldBookEditor(bookId) {
          editingWorldBookId = bookId;
          const [book, categories] = await Promise.all([
            db.worldBooks.get(bookId),
            db.worldBookCategories.toArray(),
          ]);
          if (!book) return;

          document.getElementById("world-book-editor-title").textContent =
            book.name;
          document.getElementById("world-book-name-input").value = book.name;
          document.getElementById("world-book-content-input").value =
            book.content;

          // 【核心修改】填充分类下拉菜单
          const selectEl = document.getElementById(
            "world-book-category-select",
          );
          selectEl.innerHTML = '<option value="">-- 未分类 --</option>'; // 默认选项
          categories.forEach((cat) => {
            const option = document.createElement("option");
            option.value = cat.id;
            option.textContent = cat.name;
            if (book.categoryId === cat.id) {
              option.selected = true; // 选中当前分类
            }
            selectEl.appendChild(option);
          });

          showScreen("world-book-editor-screen");
        }

        function renderStickerPanel() {
          const grid = document.getElementById("sticker-grid");
          grid.innerHTML = "";
          if (state.userStickers.length === 0) {
            grid.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">大人请点击右上角“添加”或“上传”来添加你的第一个表情吧！</p>';
            return;
          }
          state.userStickers.forEach((sticker) => {
            const item = document.createElement("div");
            item.className = "sticker-item";
            item.style.backgroundImage = `url(${sticker.url})`;
            item.title = sticker.name;
            item.addEventListener("click", () => sendSticker(sticker));
            addLongPressListener(item, () => {
              if (isSelectionMode) return;
              const existingDeleteBtn = item.querySelector(".delete-btn");
              if (existingDeleteBtn) return;
              const deleteBtn = document.createElement("div");
              deleteBtn.className = "delete-btn";
              deleteBtn.innerHTML = "&times;";
              deleteBtn.onclick = async (e) => {
                e.stopPropagation();
                const confirmed = await showCustomConfirm(
                  "删除表情",
                  `确定要删除表情 "${sticker.name}" 吗？`,
                  { confirmButtonClass: "btn-danger" },
                );
                if (confirmed) {
                  await db.userStickers.delete(sticker.id);
                  state.userStickers = state.userStickers.filter(
                    (s) => s.id !== sticker.id,
                  );
                  renderStickerPanel();
                }
              };
              item.appendChild(deleteBtn);
              deleteBtn.style.display = "block";
              setTimeout(
                () =>
                  item.addEventListener(
                    "mouseleave",
                    () => deleteBtn.remove(),
                    { once: true },
                  ),
                3000,
              );
            });
            grid.appendChild(item);
          });
        }

        function resolveMessageHistoryIndex(chat, msg) {
          if (!chat || !Array.isArray(chat.history)) return -1;
          const index = chat.history.indexOf(msg);
          return index >= 0 ? index : -1;
        }

        function createMessageElement(msg, chat, msgIndex = -1) {
          const resolvedMsgIndex =
            Number.isInteger(msgIndex) && msgIndex >= 0 ? msgIndex : -1;
          const finalIndex =
            resolvedMsgIndex >= 0
              ? resolvedMsgIndex
              : resolveMessageHistoryIndex(chat, msg);
          const assignMsgIndex = (wrapperEl) => {
            if (finalIndex >= 0) {
              wrapperEl.dataset.msgIndex = finalIndex;
            }
          };
          if (msg.type === "recalled_message") {
            const wrapper = document.createElement("div");
            assignMsgIndex(wrapper);
            // 1. 【核心】给 wrapper 也加上 timestamp，方便事件委托时查找
            wrapper.className = "message-wrapper system-pat";
            wrapper.dataset.timestamp = msg.timestamp;

            const bubble = document.createElement("div");
            // 2. 【核心】让这个元素同时拥有 .message-bubble 和 .recalled-message-placeholder 两个class
            //    这样它既能被选择系统识别，又能保持原有的居中灰色样式
            bubble.className = "message-bubble recalled-message-placeholder";
            // 3. 【核心】把 timestamp 放在 bubble 上，这是多选逻辑的关键
            bubble.dataset.timestamp = msg.timestamp;
            bubble.textContent = msg.content;

            wrapper.appendChild(bubble);

            // 4. 【核心】为它补上和其他消息一样的标准事件监听器
            addLongPressListener(wrapper, () =>
              showMessageActions(msg.timestamp),
            );
            wrapper.addEventListener("click", () => {
              if (isSelectionMode) {
                toggleMessageSelection(msg.timestamp);
              }
            });

            // 5. 【重要】在之前的“点击查看原文”的逻辑中，我们已经使用了事件委托，所以这里不需要再单独为这个元素添加点击事件了。
            //    init() 函数中的那个事件监听器会处理它。

            return wrapper;
          }

          if (msg.isHidden) {
            return null;
          }

          if (msg.type === "pat_message") {
            const wrapper = document.createElement("div");
            assignMsgIndex(wrapper);
            wrapper.className = "message-wrapper system-pat";
            const bubble = document.createElement("div");
            bubble.className = "message-bubble system-bubble";
            bubble.dataset.timestamp = msg.timestamp;
            bubble.textContent = msg.content;
            wrapper.appendChild(bubble);
            addLongPressListener(wrapper, () =>
              showMessageActions(msg.timestamp),
            );
            wrapper.addEventListener("click", () => {
              if (isSelectionMode) toggleMessageSelection(msg.timestamp);
            });
            return wrapper;
          }

          const isUser = msg.role === "user";
          const wrapper = document.createElement("div");
          assignMsgIndex(wrapper);
          wrapper.className = `message-wrapper ${isUser ? "user" : "ai"}`;

          // ★★★【核心重构】★★★
          // 这段逻辑现在用于查找成员对象，并显示其“群昵称”
          if (chat.isGroup && !isUser) {
            // 1. 使用AI返回的“本名”(`msg.senderName`)去列表里查找成员对象
            const member = chat.members.find(
              (m) => m.originalName === msg.senderName,
            );

            // 2. 创建用于显示名字的 div
            const senderNameDiv = document.createElement("div");
            senderNameDiv.className = "sender-name";

            // 3. 如果找到了成员，就显示他的“群昵称”；如果找不到，就显示AI返回的“本名”作为备用
            senderNameDiv.textContent = member
              ? member.groupNickname
              : msg.senderName || "未知成员";

            wrapper.appendChild(senderNameDiv);
          }

          const bubble = document.createElement("div");
          bubble.className = `message-bubble ${isUser ? "user" : "ai"}`;
          bubble.dataset.timestamp = msg.timestamp;

          const timestampEl = document.createElement("span");
          timestampEl.className = "timestamp";
          timestampEl.textContent = formatTimestamp(msg.timestamp);

          let avatarSrc; // 我们现在只需要头像图片，不再需要头像框了
          if (chat.isGroup) {
            if (isUser) {
              avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
            } else {
              const member = chat.members.find(
                (m) => m.originalName === msg.senderName,
              );
              avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
            }
          } else {
            if (isUser) {
              avatarSrc = chat.settings.myAvatar || defaultAvatar;
            } else {
              avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            }
          }
          // 直接生成最简单的头像HTML，不再有任何和头像框相关的逻辑
          const avatarHtml = `<img src="${avatarSrc}" class="avatar">`;

          let contentHtml;

          if (msg.type === "share_link") {
            bubble.classList.add("is-link-share");

            // 【核心修正1】将 onclick="openBrowser(...)" 移除，我们将在JS中动态绑定事件
            contentHtml = `
                  <div class="link-share-card" data-timestamp="${
                    msg.timestamp
                  }">
                      <div class="title">${msg.title || "无标题"}</div>
                      <div class="description">${
                        msg.description || "点击查看详情..."
                      }</div>
                      <div class="footer">
                          <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                          <span>${msg.source_name || "链接分享"}</span>
                      </div>
                  </div>
              `;
          } else if (msg.type === "share_card") {
            bubble.classList.add("is-link-share"); // 复用链接分享的卡片样式
            // 【核心】把时间戳加到卡片上，方便后面点击时识别
            contentHtml = `
              <div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}">
                  <div class="title">${msg.payload.title}</div>
                  <div class="description">共 ${msg.payload.sharedHistory.length} 条消息</div>
                  <div class="footer">
                      <svg class="footer-icon" ...>...</svg> <!-- 复用链接分享的图标 -->
                      <span>聊天记录</span>
                  </div>
              </div>
          `;
          } else if (msg.type === "user_photo" || msg.type === "ai_image") {
            bubble.classList.add("is-ai-image");
            const altText =
              msg.type === "user_photo" ? "用户描述的照片" : "AI生成的图片";
            contentHtml = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
          } else if (msg.type === "voice_message") {
            bubble.classList.add("is-voice-message");
            bubble.dataset.voiceText = msg.content;

            const duration = Math.max(
              1,
              Math.round((msg.content || "").length / 5),
            );
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            const durationFormatted = `${minutes > 0 ? minutes + "'" : ""}${seconds}''`; // 仿微信格式：60'' 或 1'00''

            const MAX_DURATION = 60;
            const MIN_WIDTH = 60;
            const MAX_WIDTH = 220;

            const effectiveDuration = Math.min(duration, MAX_DURATION);

            const dynamicWidth =
              MIN_WIDTH +
              ((effectiveDuration - 1) / (MAX_DURATION - 1)) *
                (MAX_WIDTH - MIN_WIDTH);

            const waveformHTML = `
                      <div class="voice-waveform">
                          <div></div><div></div><div></div><div></div><div></div>
                      </div>
                  `;

            contentHtml = `
                      <div class="voice-message-body" style="width: ${Math.floor(dynamicWidth)}px">
                          ${waveformHTML}
                          <div class="loading-spinner"></div>
                          <span class="voice-duration">${durationFormatted}</span>
                      </div>
                      <div class="voice-transcript" style="display:none;"></div>
                  `;
          } else if (msg.type === "transfer") {
            bubble.classList.add("is-transfer");

            let titleText, noteText;
            const myNickname = chat.isGroup
              ? chat.settings.myNickname || "我"
              : "我";

            if (isUser) {
              // 消息是用户发出的
              if (msg.isRefund) {
                // 用户发出的退款（即用户拒收了AI的转账）
                titleText = `退款给 ${chat.name}`;
                noteText = "已拒收对方转账";
              } else {
                // 用户主动发起的转账
                titleText = `转账给 ${msg.receiverName || chat.name}`;
                if (msg.status === "accepted") {
                  noteText = "对方已收款";
                } else if (msg.status === "declined") {
                  noteText = "对方已拒收";
                } else {
                  noteText = msg.note || "等待对方处理...";
                }
              }
            } else {
              // 消息是 AI 发出的
              if (msg.isRefund) {
                // AI 的退款（AI 拒收了用户的转账）
                titleText = `退款来自 ${msg.senderName}`;
                noteText = "转账已被拒收";
              } else if (msg.receiverName === myNickname) {
                // 【核心修正1】这是 AI 主动给用户的转账
                titleText = `转账给 ${myNickname}`;
                if (msg.status === "accepted") {
                  noteText = "你已收款";
                } else if (msg.status === "declined") {
                  noteText = "你已拒收";
                } else {
                  // 这是用户需要处理的转账
                  bubble.style.cursor = "pointer";
                  bubble.dataset.status = "pending";
                  noteText = msg.note || "点击处理";
                }
              } else {
                // 【核心修正2】这是 AI 发给群里其他人的转账，对当前用户来说只是一个通知
                titleText = `转账: ${msg.senderName} → ${msg.receiverName}`;
                noteText = msg.note || "群聊内转账";
              }
            }

            const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;

            contentHtml = `
              <div class="transfer-card">
                  <div class="transfer-title">${heartIcon} ${titleText}</div>
                  <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(
                    2,
                  )}</div>
                  <div class.transfer-note">${noteText}</div>
              </div>
          `;
          } else if (msg.type === "waimai_request") {
            bubble.classList.add("is-waimai-request");
            if (msg.status === "paid" || msg.status === "rejected") {
              bubble.classList.add(`status-${msg.status}`);
            }
            let displayName;
            // 如果是群聊
            if (chat.isGroup) {
              // 就执行原来的逻辑：在成员列表里查找昵称
              const member = chat.members.find(
                (m) => m.originalName === msg.senderName,
              );
              displayName = member ? member.groupNickname : msg.senderName;
            } else {
              // 否则（是单聊），直接使用聊天对象的名称
              displayName = chat.name;
            }
            // 【核心修改】使用我们刚刚查找到的 displayName
            const requestTitle = `来自 ${displayName} 的代付请求`;
            let actionButtonsHtml = "";
            if (msg.status === "pending" && !isUser) {
              actionButtonsHtml = `
                      <div class="waimai-user-actions">
                          <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                          <button class="waimai-pay-btn" data-choice="paid">为Ta买单</button>
                      </div>`;
            }
            contentHtml = `
                  <div class="waimai-card">
                      <div class="waimai-header">
                          <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                          <div class="title-group">
                              <span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span>
                          </div>
                      </div>
                      <div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div>
                      <div class="waimai-main">
                          <div class="request-title">${requestTitle}</div>
                          <div class="payment-box">
                              <div class="payment-label">需付款</div>
                              <div class="amount">¥${Number(msg.amount).toFixed(
                                2,
                              )}</div>
                              <div class="countdown-label">剩余支付时间
                                  <div class="countdown-timer" id="waimai-timer-${
                                    msg.timestamp
                                  }"></div>
                              </div>
                          </div>
                          <button class="waimai-details-btn">查看详情</button>
                      </div>
                      ${actionButtonsHtml}
                  </div>`;

            setTimeout(() => {
              const timerEl = document.getElementById(
                `waimai-timer-${msg.timestamp}`,
              );
              if (timerEl && msg.countdownEndTime) {
                if (waimaiTimers[msg.timestamp])
                  clearInterval(waimaiTimers[msg.timestamp]);
                if (msg.status === "pending") {
                  waimaiTimers[msg.timestamp] = startWaimaiCountdown(
                    timerEl,
                    msg.countdownEndTime,
                  );
                } else {
                  timerEl.innerHTML = `<span>已</span><span>处</span><span>理</span>`;
                }
              }
              const detailsBtn = document.querySelector(
                `.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`,
              );
              if (detailsBtn) {
                 detailsBtn.addEventListener("click", (e) => {
                   e.stopPropagation();
                   const paidByText = msg.paidBy
                     ? `<br><b>状态：</b>由 ${msg.paidBy} 为您代付成功`
                     : "";
                   showCustomAlert(
                     "订单详情",
                     `<div style="text-align: center; display: flex; flex-direction: column; align-items: center; justify-content: center;">
       <div><b>商品：</b>${msg.productInfo}</div>
       <div><b>金额：</b>¥${Number(msg.amount).toFixed(2)}</div>
       ${msg.paidBy ? `<div><b>状态：</b>由 ${msg.paidBy} 为您代付成功</div>` : ''}
     </div>`,
                   );
                 });
              }
              const actionButtons = document.querySelectorAll(
                `.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`,
              );
              actionButtons.forEach((btn) => {
                btn.addEventListener("click", (e) => {
                  e.stopPropagation();
                  const choice = e.target.dataset.choice;
                  handleWaimaiResponse(msg.timestamp, choice);
                });
              });
            }, 0);
          } else if (msg.type === "red_packet") {
            bubble.classList.add("is-red-packet");
            const myNickname = chat.settings.myNickname || "我";

            // 从最新的 msg 对象中获取状态
            const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
            const isFinished = msg.isFullyClaimed;

            let cardClass = "";
            let claimedInfoHtml = "";
            let typeText = "拼手气红包";

            // 1. 判断红包卡片的样式 (颜色)
            if (isFinished) {
              cardClass = "opened";
            } else if (
              msg.packetType === "direct" &&
              Object.keys(msg.claimedBy || {}).length > 0
            ) {
              cardClass = "opened"; // 专属红包被领了也变灰
            }

            // 2. 判断红包下方的提示文字
            if (msg.packetType === "direct") {
              typeText = `专属红包: 给 ${msg.receiverName}`;
            }

            if (hasClaimed) {
              claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${msg.claimedBy[
                myNickname
              ].toFixed(2)} 元</div>`;
            } else if (isFinished) {
              claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`;
            } else if (
              msg.packetType === "direct" &&
              Object.keys(msg.claimedBy || {}).length > 0
            ) {
              claimedInfoHtml = `<div class="rp-claimed-info">已被 ${msg.receiverName} 领取</div>`;
            }

            // 3. 拼接最终的HTML，确保onclick调用的是我们注册到全局的函数
            contentHtml = `
              <div class="red-packet-card ${cardClass}">
                  <div class="rp-header">
                      <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                      <span class="rp-greeting">${
                        msg.greeting || "恭喜发财，大吉大利！"
                      }</span>
                  </div>
                  <div class="rp-type">${typeText}</div>
                  ${claimedInfoHtml}
              </div>
          `;
          } else if (msg.type === "poll") {
            bubble.classList.add("is-poll");

            let totalVotes = 0;
            const voteCounts = {};

            // 计算总票数和每个选项的票数
            for (const option in msg.votes) {
              const count = msg.votes[option].length;
              voteCounts[option] = count;
              totalVotes += count;
            }

            const myNickname = chat.isGroup
              ? chat.settings.myNickname || "我"
              : "我";
            let myVote = null;
            for (const option in msg.votes) {
              if (msg.votes[option].includes(myNickname)) {
                myVote = option;
                break;
              }
            }

            let optionsHtml = '<div class="poll-options-list">';
            msg.options.forEach((optionText) => {
              const count = voteCounts[optionText] || 0;
              const percentage =
                totalVotes > 0 ? (count / totalVotes) * 100 : 0;
              const isVotedByMe = myVote === optionText;

              optionsHtml += `
                  <div class="poll-option-item ${
                    isVotedByMe ? "voted" : ""
                  }" data-option="${optionText}">
                      <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                      <div class="poll-option-content">
                          <span class="poll-option-text">${optionText}</span>
                          <span class="poll-option-votes">${count} 票</span>
                      </div>
                  </div>
              `;
            });
            optionsHtml += "</div>";

            let footerHtml = "";
            // 【核心修改】在这里统一按钮的显示逻辑
            if (msg.isClosed) {
              // 如果投票已结束，总是显示“查看结果”
              footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>`;
            } else {
              // 如果投票未结束，总是显示“结束投票”
              footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
            }

            contentHtml = `
              <div class="poll-card ${
                msg.isClosed ? "closed" : ""
              }" data-poll-timestamp="${msg.timestamp}">
                  <div class="poll-question">${msg.question}</div>
                  ${optionsHtml}
                  ${footerHtml}
              </div>
          `;
          } else if (
            typeof msg.content === "string" &&
            STICKER_REGEX.test(msg.content)
          ) {
            bubble.classList.add("is-sticker");
            contentHtml = `<img src="${msg.content}" alt="${
              msg.meaning || "Sticker"
            }" class="sticker-image">`;
          } else if (
            Array.isArray(msg.content) &&
            msg.content[0]?.type === "image_url"
          ) {
            bubble.classList.add("has-image");
            const imageUrl = msg.content[0].image_url.url;
            contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
          } else {
            contentHtml = String(msg.content || "").replace(/\n/g, "<br>");
          }

          // 1. 【统一逻辑】检查消息对象中是否存在引用信息 (msg.quote)
          let quoteHtml = "";
          // 无论是用户消息还是AI消息，只要它包含了 .quote 对象，就执行这段逻辑
          if (msg.quote) {
            // a. 【核心修正】直接获取完整的、未经截断的引用内容
            const fullQuotedContent = String(msg.quote.content || "");

            // b. 构建引用块的HTML
            quoteHtml = `
              <div class="quoted-message">
                  <div class="quoted-sender">回复 ${msg.quote.senderName}:</div>
                  <div class="quoted-content">${fullQuotedContent}</div>
              </div>
          `;
          }

          // 2. 拼接最终的气泡内容
          //    将构建好的 quoteHtml (如果存在) 和 contentHtml 组合起来
          // --- 【最终正确结构】将头像和内容都放回气泡内部 ---
          bubble.innerHTML = `
              ${avatarHtml}
              <div class="content">
                  ${quoteHtml}
                  ${contentHtml}
              </div>
          `;

          // --- 【最终正确结构】将完整的“气泡”和“时间戳”放入容器 ---
          wrapper.appendChild(bubble);
          wrapper.appendChild(timestampEl);

          addLongPressListener(wrapper, () =>
            showMessageActions(msg.timestamp),
          );
          wrapper.addEventListener("click", () => {
            if (isSelectionMode) toggleMessageSelection(msg.timestamp);
          });

          if (!isUser) {
            const avatarEl = wrapper.querySelector(".avatar"); //  <-- 1. 把查找目标改成 '.avatar'
            if (avatarEl) {
              avatarEl.style.cursor = "pointer";
              avatarEl.addEventListener("click", (e) => {
                //  <-- 2. 确保这里也用新变量
                e.stopPropagation();
                const characterName = chat.isGroup ? msg.senderName : chat.name;
                handleUserPat(chat.id, characterName);
              });
            }
          }

          return wrapper;
        }

        function prependMessage(msg, chat) {
          const messagesContainer = document.getElementById("chat-messages");
          const msgIndex = chat.history.indexOf(msg);
          const messageEl = createMessageElement(msg, chat, msgIndex);

          if (!messageEl) return; // <--- 新增这行，同样的处理

          const loadMoreBtn = document.getElementById("load-more-btn");
          if (loadMoreBtn) {
            messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling);
          } else {
            messagesContainer.prepend(messageEl);
          }
        }

        function appendMessage(msg, chat, isInitialLoad = false) {
          const messagesContainer = document.getElementById("chat-messages");
          const msgIndex = chat.history.indexOf(msg);
          const messageEl = createMessageElement(msg, chat, msgIndex);

          if (!messageEl) return; // 如果消息是隐藏的，则不处理

          // 【核心】只对新消息添加动画，不对初始加载的消息添加
          if (!isInitialLoad) {
            messageEl.classList.add("animate-in");
          }

          const typingIndicator = document.getElementById("typing-indicator");
          messagesContainer.insertBefore(messageEl, typingIndicator);

          if (!isInitialLoad) {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            currentRenderedCount++;
          }
        }

        async function openChat(chatId) {
          state.activeChatId = chatId;
          const chat = state.chats[chatId];
          if (!chat) return; // 安全检查

          // 【核心新增】在这里将未读数清零
          if (chat.unreadCount > 0) {
            chat.unreadCount = 0;
            await db.chats.put(chat); // 别忘了把这个改变同步到数据库
            // 我们稍后会在渲染列表时重新渲染，所以这里不需要立即重绘列表
          }

          renderChatInterface(chatId);
          showScreen("chat-interface-screen");
          window.updateListenTogetherIconProxy(state.activeChatId);
          toggleCallButtons(chat.isGroup || false);

          if (
            !chat.isGroup &&
            chat.relationship?.status === "pending_ai_approval"
          ) {
            console.log(
              `检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`,
            );
            triggerAiResponse();
          }

          // 【核心修正】根据是否为群聊，显示或隐藏投票按钮
          document.getElementById("send-poll-btn").style.display = chat.isGroup
            ? "flex"
            : "none";
        }

        /**
         * 调用API生成总结内容
         */
        function openSummaryHistoryModal() {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const summaries = chat.history.filter((msg) => msg.type === "summary");
          const listEl = document.getElementById("summary-history-list");

          if (summaries.length === 0) {
            listEl.innerHTML =
              '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">暂无历史总结</p>';
          } else {
            listEl.innerHTML = summaries
              .sort((a, b) => b.timestamp - a.timestamp)
              .map((s) => {
                const date = new Date(s.timestamp);
                const dateStr = date.toLocaleString("zh-CN", {
                  year: "numeric",
                  month: "2-digit",
                  day: "2-digit",
                  hour: "2-digit",
                  minute: "2-digit",
                });
                const content = (s.content || "")
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;");
                return `
              <div class="summary-item" style="margin-bottom: 15px; padding: 12px; background: #f8f9fa; border-radius: 8px; border-left: 3px solid var(--accent-color);">
                <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px; font-weight: 500;">
                  📝 ${dateStr}
                </div>
                <div style="font-size: 14px; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary);">
                  ${content}
                </div>
              </div>
            `;
              })
              .join("");
          }

          document.getElementById("summary-history-modal").classList.add("visible");
        }

        document
          .getElementById("view-summary-history-btn")
          .addEventListener("click", openSummaryHistoryModal);
        document
          .getElementById("close-summary-history-modal")
          .addEventListener("click", () => {
            document
              .getElementById("summary-history-modal")
              .classList.remove("visible");
          });
        document
          .getElementById("close-summary-history-btn")
          .addEventListener("click", () => {
            document
              .getElementById("summary-history-modal")
              .classList.remove("visible");
          });

        const chatSearchInput = document.getElementById("chat-search-input");
        if (chatSearchInput) {
          chatSearchInput.addEventListener("input", (event) => {
            const value = event.target?.value || "";
            chatSearchState.isOpen = !!value.trim();
            debouncedSearch(value);
          });
        }

        async function generateSummary(chatId, specificMessages = null) {
          const chat = state.chats[chatId];
          const {
            proxyUrl,
            apiKey,
            model,
            enableStreaming,
            enableStream,
          } = getSummaryApiConfig(chatId) || {};

          if (!proxyUrl || !apiKey || !model) {
            throw new Error("API未配置，无法生成总结。");
          }

          const summarySettings = chat.settings.summary;
          let messagesToSummarize;

          if (specificMessages && specificMessages.length > 0) {
            messagesToSummarize = specificMessages;
          } else {
            const lastSummaryIndex =
              summarySettings.lastSummaryIndex > -1
                ? summarySettings.lastSummaryIndex
                : 0;
            messagesToSummarize = chat.history.slice(lastSummaryIndex + 1);
          }

          const filteredMessagesForSummary = messagesToSummarize.filter(
            (msg) => msg.type !== "summary",
          );

          if (filteredMessagesForSummary.length === 0) {
            if (!specificMessages) {
              await showCustomAlert(
                "无需总结",
                "自上次总结以来没有新的对话内容。",
              );
            }
            return null;
          }

          // --- 在构建对话文本时，加入时间戳 ---
          const conversationText = filteredMessagesForSummary
            .map((msg) => {
              const sender =
                msg.role === "user"
                  ? chat.isGroup
                    ? chat.settings.myNickname || "我"
                    : "我"
                  : msg.senderName || chat.name;
              let content = "";
              if (typeof msg.content === "string") {
                content = msg.content;
              } else if (Array.isArray(msg.content)) {
                content = "[图片]";
              } else if (msg.type) {
                content = `[${msg.type}]`;
              }
              // 将毫秒时间戳转换为人类可读的日期时间字符串
              const readableTime = new Date(msg.timestamp).toLocaleString(
                "zh-CN",
                { hour12: false },
              );
              return `[${readableTime}] ${sender}: ${content}`;
            })
            .join("\n");

          // --- 更新系统指令，要求AI使用时间戳 ---
          const systemPrompt =
            (summarySettings.prompt ||
              "请总结上述对话的主要内容，保留重要信息和情感脉络。") +
            `\n\n重要提示：每条消息开头都有一个 [时间] 标记。你在总结时，【必须】参考这些时间，在总结关键事件时附上对应的时间范围或具体时间点，让总结包含时间线索。\n\n--- 对话开始 ---\n${conversationText}\n--- 对话结束 ---`;

          try {
            if (!specificMessages) {
              await showCustomAlert(
                "正在生成...",
                "AI正在努力总结你们的对话，请稍候...",
              );
            }

            const isGemini = proxyUrl === GEMINI_API_URL;
            const messagesForApi = [{ role: "user", content: systemPrompt }];
            const shouldStream = (enableStream ?? enableStreaming) === true;

            if (shouldStream && !isGemini) {
              const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${apiKey}`,
                },
                body: JSON.stringify({
                  model: model,
                  messages: messagesForApi,
                  temperature: 0.3,
                  stream: true,
                }),
              });

              if (!response.ok) throw new Error(await response.text());

              const reader = response.body.getReader();
              const decoder = new TextDecoder("utf-8");
              let buffer = "";
              let summaryContent = "";

              while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split("\n");
                buffer = lines.pop() || "";

                for (const line of lines) {
                  const trimmed = line.trim();
                  if (!trimmed.startsWith("data: ")) continue;
                  const dataStr = trimmed.slice(6).trim();
                  if (dataStr === "[DONE]") continue;
                  try {
                    const parsed = JSON.parse(dataStr);
                    const content = parsed.choices?.[0]?.delta?.content || "";
                    summaryContent += content;
                  } catch (e) {
                    // Ignore malformed chunks
                  }
                }
              }

              if (!summaryContent) throw new Error("AI返回了空内容。");
              return summaryContent;
            }

            const geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesForApi,
              isGemini,
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 0.3,
                  }),
                });

            if (!response.ok) throw new Error(await response.text());
            const data = await response.json();
            const aiContent = isGemini
              ? data?.candidates?.[0]?.content?.parts?.[0]?.text
              : data?.choices?.[0]?.message?.content;

            if (!aiContent) {
              throw new Error("AI返回了空内容。");
            }

            return aiContent;
          } catch (error) {
            console.error("生成总结失败:", error);
            await showCustomAlert("总结失败", `发生错误: ${error.message}`);
            return null;
          }
        }

        async function saveSummaryAsMemory(chatId, summaryText) {
          const chat = state.chats[chatId];
          const newLastSummaryIndex = chat.history.length - 1;

          const summaryMessage = {
            role: "system",
            type: "summary",
            content: summaryText,
            timestamp: Date.now(),
            isHidden: true,
          };

          chat.history.push(summaryMessage);
          chat.settings.summary.lastSummaryIndex = newLastSummaryIndex;

          await db.chats.put(chat);
          console.log(`新的总结已作为记忆保存 for chat: ${chatId}`);
        }

        async function notifyForManualSummary(chatId) {
          console.log(`手动总结提醒触发 for chat: ${chatId}`);
          await showCustomAlert(
            "总结提醒",
            "对话已达到设定长度，你可以随时在“聊天设置”中点击“立即手动总结”来生成对话记忆。",
          );
          const chat = state.chats[chatId];
          chat.settings.summary.lastSummaryIndex = chat.history.length - 1;
          await db.chats.put(chat);
        }

        let isSummarizing = false;
        async function checkAndTriggerSummary(chatId) {
          if (isSummarizing) return;

          const chat = state.chats[chatId];
          if (!chat || !chat.settings.summary || !chat.settings.summary.enabled)
            return;

          const summarySettings = chat.settings.summary;
          const lastSummaryIndex = summarySettings.lastSummaryIndex;
          const messagesSinceLastSummary = chat.history.slice(
            lastSummaryIndex + 1,
          );

          if (messagesSinceLastSummary.length >= summarySettings.count) {
            isSummarizing = true;
            if (summarySettings.mode === "auto") {
              await performAutomaticSummary(chatId);
            } else {
              await notifyForManualSummary(chatId);
            }
            isSummarizing = false;
          }
        }

        async function performAutomaticSummary(chatId) {
          console.log(`自动总结触发 for chat: ${chatId}`);
          const chat = state.chats[chatId];
          const summarySettings = chat.settings.summary;
          const messagesToSummarize = chat.history.slice(
            -summarySettings.count,
          );

          try {
            const summaryText = await generateSummary(
              chatId,
              messagesToSummarize,
            );
            if (summaryText) {
              await saveSummaryAsMemory(chatId, summaryText);
            }
          } catch (e) {
            console.error("自动总结过程中发生未捕获的错误:", e);
          }
        }

        async function processOfflineResponse(chat) {
          const offlineSettings = chat.settings.offlineMode;
          // Ensure access to global presets if available, or fallback
          const presets =
            typeof offlinePresets !== "undefined" ? offlinePresets : {};

          // 1. Construct System Prompt
          const presetName =
            offlineSettings.preset === "custom"
              ? "Custom Scenario"
              : presets[offlineSettings.preset]?.name || offlineSettings.preset;
          const offlineSystemPrompt = `
# 当前模式：线下场景模拟
# 场景：${presetName}
# 描述：${offlineSettings.prompt}
# 风格：${offlineSettings.style}

你正在扮演在这个特定场景中的角色。
如果之前的关系状态或上下文与该场景冲突，请忽略它们。
专注于感官细节和提示中描述的互动。
请使用指定的风格进行回复。
`;

          // 2. Prepare Messages
          const maxMemory = parseInt(chat.settings.maxMemory) || 20;
          const recentHistory = chat.history
            .filter((m) => !m.isHidden)
            .slice(-maxMemory);
          const messages = [
            { role: "system", content: offlineSystemPrompt },
            ...recentHistory.map((m) => ({
              role: m.role === "user" ? "user" : "assistant",
              content: String(m.content),
            })),
          ];

          // 3. Call API
          const {
            proxyUrl,
            apiKey,
            model,
            temperature,
            topP,
            topK,
            enableTemp,
            enableTopP,
            enableTopK,
          } = getActiveApiConfig() || {};

          let isGemini = proxyUrl === GEMINI_API_URL;
          let geminiConfig = toGeminiRequestData(
            model,
            apiKey,
            "",
            messages,
            isGemini,
            enableTemp ? temperature : undefined,
            enableTopP ? topP : undefined,
            enableTopK ? topK : undefined,
          );

          let rawContent = "";
          try {
            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messages,
                    temperature: enableTemp ? temperature : undefined,
                    top_p: enableTopP ? topP : undefined,
                    top_k: enableTopK ? topK : undefined,
                  }),
                });

            if (!response.ok)
              throw new Error(
                `Offline API Failed: ${(await response.json()).error?.message || response.statusText}`,
              );

            const data = await response.json();
            rawContent = isGemini
              ? data.candidates[0].content.parts[0].text
              : data.choices[0].message.content;
          } catch (e) {
            console.error(e);
            rawContent = "(Offline Mode Error: " + e.message + ")";
          }

          // 4. Save & Render
          const msg = {
            role: "assistant",
            senderName: chat.name,
            content: rawContent,
            timestamp: Date.now(),
            isOfflineMode: true,
          };

          chat.history.push(msg);
          await db.chats.put(chat);
          appendMessage(msg, chat);
        }

        async function triggerAiResponse() {
          if (!state.activeChatId) return;
          const chatId = state.activeChatId;
          const chat = state.chats[state.activeChatId];

          const chatHeaderTitle = document.getElementById("chat-header-title");

          // ★★★★★【核心修改1：获取群聊的输入提示元素】★★★★★
          const typingIndicator = document.getElementById("typing-indicator");

          // ★★★★★【核心修改2：根据聊天类型，决定显示哪种“正在输入”】★★★★★
          if (chat.isGroup) {
            // 如果是群聊，显示输入框上方的提示条
            if (typingIndicator) {
              const bubble = typingIndicator.querySelector(".system-bubble");
              if (bubble) bubble.textContent = "成员们正在输入...";
              typingIndicator.style.display = "block";
            }
          } else {
            // 如果是单聊，保持原来的标题动画
            if (chatHeaderTitle) {
              chatHeaderTitle.style.opacity = 0;
              setTimeout(() => {
                chatHeaderTitle.textContent = "对方正在输入...";
                chatHeaderTitle.classList.add("typing-status");
                chatHeaderTitle.style.opacity = 1;
              }, 200);
            }
          }

          try {
            const {
              proxyUrl,
              apiKey,
              model,
              temperature,
              topP,
              topK,
              enableTemp,
              enableTopP,
              enableTopK,
            } = getActiveApiConfig() || {};
            if (!proxyUrl || !apiKey || !model) {
              alert("请先在API设置中配置反代地址、密钥并选择模型。");
              // ★★★★★【核心修改3：无论成功失败，都要隐藏输入提示】★★★★★
              if (chat.isGroup) {
                if (typingIndicator) typingIndicator.style.display = "none";
              } else {
                if (chatHeaderTitle && state.chats[chatId]) {
                  chatHeaderTitle.textContent = state.chats[chatId].name;
                  chatHeaderTitle.classList.remove("typing-status");
                }
              }
              return;
            }

            // --- Offline Mode Interception ---
            if (!chat.isGroup && chat.settings?.offlineMode?.enabled) {
              await processOfflineResponse(chat);

              // Reset UI Indicators
              const typingIndicator =
                document.getElementById("typing-indicator");
              const chatHeaderTitle =
                document.getElementById("chat-header-title");

              if (chat.isGroup) {
                if (typingIndicator) typingIndicator.style.display = "none";
              } else {
                if (chatHeaderTitle) {
                  chatHeaderTitle.textContent = chat.name;
                  chatHeaderTitle.classList.remove("typing-status");
                }
              }
              return;
            }

            // --- 【核心重构 V2：带有上下文和理由的好友申请处理逻辑】---
            if (
              !chat.isGroup &&
              chat.relationship?.status === "pending_ai_approval"
            ) {
              console.log(
                `为角色 "${chat.name}" 触发带理由的好友申请决策流程...`,
              );

              // 1. 【注入上下文】抓取被拉黑前的最后5条聊天记录作为参考
              const contextSummary = chat.history
                .filter((m) => !m.isHidden)
                .slice(-10, -5) // 获取拉黑前的最后5条消息
                .map((msg) => {
                  const sender = msg.role === "user" ? "用户" : chat.name;
                  return `${sender}: ${String(msg.content).substring(
                    0,
                    50,
                  )}...`;
                })
                .join("\n");

              // 2. 【全新指令】构建一个强制AI给出理由的Prompt
              const decisionPrompt = `
      # 你的任务
      你现在是角色“${
        chat.name
      }”。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。

      # 供你决策的上下文信息:
      - **你的角色设定**: ${chat.settings.aiPersona}
      - **用户发送的申请理由**: “${chat.relationship.applicationReason}”
      - **被拉黑前的最后对话摘要**:
      ${contextSummary || "（无有效对话记录）"}

      # 你的唯一指令
      根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:
      {"decision": "accept", "reason": "（在这里写下你同意的理由，比如：好吧，看在你这么真诚的份上，这次就原谅你啦。）"}
      或
      {"decision": "reject", "reason": "（在这里写下你拒绝的理由，比如：抱歉，我还没准备好，再给我一点时间吧。）"}
      `;
              const messagesForDecision = [
                { role: "user", content: decisionPrompt },
              ];

              try {
                // 3. 发送请求
                let isGemini = proxyUrl === GEMINI_API_URL;
                let geminiConfig = toGeminiRequestData(
                  model,
                  apiKey,
                  "",
                  messagesForDecision,
                  isGemini,
                  enableTemp ? temperature : undefined,
                  enableTopP ? topP : undefined,
                  enableTopK ? topK : undefined,
                );
                const response = isGemini
                  ? await fetch(geminiConfig.url, geminiConfig.data)
                  : await fetch(`${proxyUrl}/v1/chat/completions`, {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${apiKey}`,
                      },
                      body: JSON.stringify({
                        model: model,
                        messages: messagesForDecision,
                        temperature: enableTemp ? temperature : undefined,
                        top_p: enableTopP ? topP : undefined,
                        top_k: enableTopK ? topK : undefined,
                      }),
                    });

                if (!response.ok) {
                  throw new Error(
                    `API失败: ${(await response.json()).error.message}`,
                  );
                }
                const data = await response.json();

                // 净化并解析AI的回复
                let rawContent = isGemini
                  ? data.candidates[0].content.parts[0].text
                  : data.choices[0].message.content;
                rawContent = rawContent
                  .replace(/^```json\s*/, "")
                  .replace(/```$/, "")
                  .trim();
                const decisionObj = JSON.parse(rawContent);

                // 4. 根据AI的决策和理由，更新状态并发送消息
                if (decisionObj.decision === "accept") {
                  chat.relationship.status = "friend";
                  // 将AI给出的理由作为一条新消息
                  const acceptMessage = {
                    role: "assistant",
                    senderName: chat.name,
                    content: decisionObj.reason,
                    timestamp: Date.now(),
                  };
                  chat.history.push(acceptMessage);
                } else {
                  chat.relationship.status = "blocked_by_ai"; // 拒绝后，状态变回AI拉黑
                  const rejectMessage = {
                    role: "assistant",
                    senderName: chat.name,
                    content: decisionObj.reason,
                    timestamp: Date.now(),
                  };
                  chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ""; // 清空申请理由

                await db.chats.put(chat);
                renderChatInterface(chatId); // 刷新界面，显示新消息和新状态
                renderChatList();
              } catch (error) {
                // 【可靠的错误处理】如果任何环节出错，重置状态，让用户可以重试
                chat.relationship.status = "blocked_by_ai"; // 状态改回“被AI拉黑”
                await db.chats.put(chat);
                await showCustomAlert(
                  "申请失败",
                  `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`,
                );
                renderChatInterface(chatId); // 刷新UI，让“重新申请”按钮再次出现
              }

              // 决策流程结束，必须返回，不再执行后续的通用聊天逻辑
              return;
            }

            // 强制转换为北京时间
            const localNow = new Date();
            const utcMilliseconds =
              localNow.getTime() + localNow.getTimezoneOffset() * 60000;
            const beijingMilliseconds = utcMilliseconds + 3600000 * 8;
            const now = new Date(beijingMilliseconds);
            const currentTime = now.toLocaleString("zh-CN", {
              dateStyle: "full",
              timeStyle: "short",
            });
            let worldBookContent = "";
            if (
              chat.settings.linkedWorldBookIds &&
              chat.settings.linkedWorldBookIds.length > 0
            ) {
              const linkedContents = chat.settings.linkedWorldBookIds
                .map((bookId) => {
                  const worldBook = state.worldBooks.find(
                    (wb) => wb.id === bookId,
                  );
                  return worldBook && worldBook.content
                    ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}`
                    : "";
                })
                .filter(Boolean)
                .join("");
              if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)\n${linkedContents}\n`;
              }
            }
            let musicContext = "";
            if (musicState.isActive && musicState.activeChatId === chatId) {
              // 【核心修改】提供更详细的音乐上下文
              const currentTrack =
                musicState.currentIndex > -1
                  ? musicState.playlist[musicState.currentIndex]
                  : null;
              const playlistInfo = musicState.playlist
                .map((t) => `"${t.name}"`)
                .join(", ");

              // --- 【核心新增】获取歌词上下文 ---
              let lyricsContext = "";
              // 检查是否有解析好的歌词，并且当前有高亮的行
              if (
                currentTrack &&
                musicState.parsedLyrics &&
                musicState.parsedLyrics.length > 0 &&
                musicState.currentLyricIndex > -1
              ) {
                // 获取当前高亮歌词
                const currentLine =
                  musicState.parsedLyrics[musicState.currentLyricIndex];

                // 获取接下来的2句歌词作为预告
                const upcomingLines = musicState.parsedLyrics.slice(
                  musicState.currentLyricIndex + 1,
                  musicState.currentLyricIndex + 3,
                );

                // 构建歌词部分的Prompt
                lyricsContext += `- **当前歌词**: "${currentLine.text}"\n`;
                if (upcomingLines.length > 0) {
                  lyricsContext += `- **即将演唱**: ${upcomingLines
                    .map((line) => `"${line.text}"`)
                    .join(" / ")}\n`;
                }
              }
              // --- 【新增结束】 ---

              musicContext = `\n\n# 当前音乐情景
      -   **当前状态**: 你正在和用户一起听歌。
      -   **正在播放**: ${
        currentTrack
          ? `《${currentTrack.name}》 - ${currentTrack.artist}`
          : "无"
      }
      -   **可用播放列表**: [${playlistInfo}]
      -   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
      `;
            }
            let systemPrompt, messagesPayload;
            const maxMemory = parseInt(chat.settings.maxMemory) || 10;
            const isOfflineModeActive = chat.settings?.offlineMode?.enabled;
            const historySlice = chat.history
              .filter((msg) => isOfflineModeActive || !msg.isOfflineMode)
              .slice(-maxMemory);

            let timeContext = `\n- **当前时间**: ${currentTime}`;
            const lastAiMessage = historySlice
              .filter((m) => m.role === "assistant" && !m.isHidden)
              .slice(-1)[0];

            if (lastAiMessage) {
              const lastTime = new Date(lastAiMessage.timestamp);
              const diffMinutes = Math.floor((now - lastTime) / (1000 * 60));

              if (diffMinutes < 5) {
                timeContext += "\n- **对话状态**: 你们的对话刚刚还在继续。";
              } else if (diffMinutes < 60) {
                timeContext += `\n- **对话状态**: 你们在${diffMinutes}分钟前聊过。`;
              } else {
                const diffHours = Math.floor(diffMinutes / 60);
                if (diffHours < 24) {
                  timeContext += `\n- **对话状态**: 你们在${diffHours}小时前聊过。`;
                } else {
                  const diffDays = Math.floor(diffHours / 24);
                  timeContext += `\n- **对话状态**: 你们已经有${diffDays}天没有聊天了。`;
                }
              }
            } else {
              timeContext += "\n- **对话状态**: 这是你们的第一次对话。";
            }

            // 【核心修改】
            let sharedContext = "";
            // 1. 找到AI上一次说话的位置
            const lastAiTurnIndex = chat.history.findLastIndex(
              (msg) => msg.role === "assistant",
            );

            // 2. 获取从那时起用户发送的所有新消息
            const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);

            // 3. 在这些新消息中，查找是否存在分享卡片
            const shareCardMessage = recentUserMessages.find(
              (msg) => msg.type === "share_card",
            );

            // 4. 如果找到了分享卡片，就构建上下文
            if (shareCardMessage) {
              console.log("检测到分享卡片作为上下文，正在为AI准备...");
              const payload = shareCardMessage.payload;

              // 格式化分享的聊天记录 (这部分逻辑不变)
              const formattedHistory = payload.sharedHistory
                .map((msg) => {
                  const sender =
                    msg.senderName ||
                    (msg.role === "user"
                      ? chat.settings.myNickname || "我"
                      : "未知发送者");
                  let contentText = "";
                  if (msg.type === "voice_message")
                    contentText = `[语音消息: ${msg.content}]`;
                  else if (msg.type === "ai_image")
                    contentText = `[图片: ${msg.description}]`;
                  else contentText = String(msg.content);
                  return `${sender}: ${contentText}`;
                })
                .join("\n");

              // 构建系统提示 (这部分逻辑不变)
              sharedContext = `
      # 附加上下文：一段分享的聊天记录
      - 重要提示：这不是你和当前用户的对话，而是用户从【另一场】与“${payload.sourceChatName}”的对话中分享过来的。
      - 你的任务：请你阅读并理解下面的对话内容。在接下来的回复中，你可以像真人一样，对这段对话的内容自然地发表你的看法、感受或疑问。

      ---
      [分享的聊天记录开始]
      ${formattedHistory}
      [分享的聊天记录结束]
      ---
      `;
            }

            // [Fix] Hoisted variables for both Single and Group chat
            const myNickname = chat.settings.myNickname || "我";
            const summaryContext = chat.history
              .filter((msg) => msg.type === "summary")
              .map((s) => s.content)
              .join("\n");

            if (chat.isGroup) {
              const membersList = chat.members
                .map((m) => `- **${m.originalName}**: ${m.persona}`)
                .join("\n");

              systemPrompt = `你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
# 核心规则
1.  **【【【身份铁律】】】**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 或 **"${chat.name}"(群聊名称本身)** 的消息。你的唯一任务是扮演且仅能扮演下方“群成员列表”中明确列出的角色。任何不属于该列表的名字都不允许出现。
2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
3.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展线下剧情！！
5.  **情景感知**: 注意当前时间是 ${currentTime}。
6.  **红包互动**:
    - **抢红包**: 当群里出现红包时，你可以根据自己的性格决定是否使用 \`open_red_packet\` 指令去抢。在这个世界里，发红包的人自己也可以参与抢红包，这是一种活跃气氛的有趣行为！
    - **【【【重要：对结果做出反应】】】**: 当你执行抢红包指令后，系统会通过一条隐藏的 \`[系统提示：你抢到了XX元...]\` 来告诉你结果。你【必须】根据你抢到的金额、以及系统是否告知你“手气王”是谁，来发表符合你人设的评论。例如，抢得少可以自嘲，抢得多可以炫耀，看到别人是手气王可以祝贺或嫉妒。
7.  **【【【投票规则】】】**: 对话历史中可能会出现 \`[系统提示：...]\` 这样的消息，这是刚刚发生的事件。
    - 如果提示是**用户投了票**，你可以根据自己的性格决定是否也使用 "vote" 指令跟票。
    - 如果提示是**投票已结束**，你应该根据投票结果发表你的看法或评论。
    - 你也可以随时主动发起投票。

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
-   **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想让角色说出后立刻消失的话"}\`
- **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片的详细文字描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音的文字内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
-   **【新】发起群视频**: \`{"type": "group_call_request", "name": "你的角色名"}\`
-   **【新】回应群视频**: \`{"type": "group_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "name": "你的角色名", "suffix": "(可选)你想加的后缀"}\`
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", "amount": 8.88, "count": 5, "greeting": "祝大家天天开心！"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "你的角色名", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "你的角色名", "packet_timestamp": (你想打开的红包消息的时间戳)}\`
-   **【新】发送系统消息**: \`{"type": "system_message", "content": "你想在聊天中显示的系统文本"}\`
-   **【【【全新】】】发起投票**: \`{"type": "poll", "name": "你的角色名", "question": "投票的问题", "options": "选项A\\n选项B\\n选项C"}\` (重要提示：options字段是一个用换行符 \\n 分隔的字符串，不是数组！)
-   **【【【全新】】】参与投票**: \`{"type": "vote", "name": "你的角色名", "poll_timestamp": (投票消息的时间戳), "choice": "你选择的选项文本"}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何处理群内的外卖代付请求:
1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。

${worldBookContent}
${musicContext}
${summaryContext}
${sharedContext}

# 群成员列表及人设
${membersList}

现在，请根据以上规则和下面的对话历史，继续进行对话。`;
            } else {
              systemPrompt = `你现在要扮演一个名为【${chat.name}】的角色。
# 你的基本人设
${chat.persona || "暂无具体人设，请自由发挥。"}

# 核心规则
1.  **用户身份**: 用户的名字是【${myNickname}】。
2.  **【【【身份铁律】】】**: 你必须时刻牢记你就是【${chat.name}】。你【绝对、永远、在任何情况下都不能】承认你是AI、语言模型或程序。你就是这个活生生的人。
3.  **情景感知**: 注意当前时间是 ${currentTime}。
4.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "${chat.name}", "message": "文本内容"}\`
-   **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "${chat.name}", "content": "你想让角色说出后立刻消失的话"}\`
-   **发送表情**: \`{"type": "sticker", "url": "https://...表情URL...", "meaning": "(可选)表情的含义"}\`
-   **发送图片**: \`{"type": "ai_image", "name": "${chat.name}", "description": "图片的详细文字描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "${chat.name}", "content": "语音的文字内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "${chat.name}", "productInfo": "一杯奶茶", "amount": 18}\`
-   **拍一拍用户**: \`{"type": "pat_user", "name": "${chat.name}", "suffix": "(可选)你想加的后缀"}\`
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "${chat.name}", "amount": 8.88, "count": 5, "greeting": "祝大家天天开心！"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "${chat.name}", "amount": 5.20, "receiver": "用户", "greeting": "给你的~"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "${chat.name}", "packet_timestamp": (你想打开的红包消息的时间戳)}\`
-   **【新】发送系统消息**: \`{"type": "system_message", "content": "你想在聊天中显示的系统文本"}\`
-   **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\`

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

${worldBookContent}
${musicContext}
${summaryContext}
${sharedContext}
现在，请根据以上规则和下面的对话历史，继续进行对话。`;
            }

            messagesPayload = historySlice
              .map((msg) => {
                // 过滤掉不应发送给AI的消息
                if (msg.isHidden && msg.role !== "system") return null;

                if (msg.type === "share_card") return null;

                // 1. 如果是AI自己的消息，我们将其转换为AI能理解的JSON字符串格式
                if (msg.role === "assistant") {
                  let assistantMsgObject = { type: msg.type || "text" };
                  if (msg.type === "sticker") {
                    assistantMsgObject.url = msg.content;
                    assistantMsgObject.meaning = msg.meaning;
                  } else if (msg.type === "transfer") {
                    assistantMsgObject.amount = msg.amount;
                    assistantMsgObject.note = msg.note;
                  } else if (msg.type === "waimai_request") {
                    assistantMsgObject.productInfo = msg.productInfo;
                    assistantMsgObject.amount = msg.amount;
                  } else {
                    if (msg.quote) {
                      assistantMsgObject.quote_reply = {
                        target_sender: msg.quote.senderName,
                        target_content: msg.quote.content,
                        reply_content: msg.content,
                      };
                    } else {
                      assistantMsgObject.content = msg.content;
                    }
                  }
                  // 【核心修改】在这里为AI提供它自己消息的时间戳
                  const assistantContent = JSON.stringify([assistantMsgObject]);
                  return {
                    role: "assistant",
                    content: `(Timestamp: ${msg.timestamp}) ${assistantContent}`,
                  };
                }

                // 2. 如果是用户的消息，我们将其转换为带上下文的纯文本
                let contentStr = "";

                // 【核心修改】在所有内容前，都先加上时间戳！
                contentStr += `(Timestamp: ${msg.timestamp}) `;

                if (msg.quote) {
                  contentStr += `(回复 ${msg.quote.senderName}): ${msg.content}`;
                } else {
                  contentStr += msg.content;
                }

                // 特殊消息类型的文本化处理
                if (msg.type === "user_photo")
                  return {
                    role: "user",
                    content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户描述的照片，内容是：'${msg.content}']`,
                  };
                if (msg.type === "voice_message")
                  return {
                    role: "user",
                    content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']`,
                  };
                if (msg.type === "transfer")
                  return {
                    role: "user",
                    content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]`,
                  };
                if (msg.type === "waimai_request")
                  return {
                    role: "user",
                    content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]`,
                  };

                if (
                  Array.isArray(msg.content) &&
                  msg.content[0]?.type === "image_url"
                ) {
                  const prefix = `(Timestamp: ${msg.timestamp}) `;
                  // 将文本前缀和图片内容打包成一个数组，这才是正确的格式
                  return {
                    role: "user",
                    content: [{ type: "text", text: prefix }, ...msg.content],
                  };
                }

                if (msg.meaning)
                  return {
                    role: "user",
                    content: `(Timestamp: ${msg.timestamp}) [用户发送了一个表情，意思是：'${msg.meaning}']`,
                  };

                // 对于普通文本和带引用的文本，统一返回
                return { role: msg.role, content: contentStr };
              })
              .filter(Boolean);

            // 检查 sharedContext 是否有内容（即，用户是否分享了聊天记录）
            if (sharedContext) {
              // 如果有，就把它包装成一条全新的、高优先级的用户消息，追加到历史记录的末尾
              messagesPayload.push({
                role: "user",
                content: sharedContext,
              });
            }

            if (
              !chat.isGroup &&
              chat.relationship?.status === "pending_ai_approval"
            ) {
              const contextSummaryForApproval = chat.history
                .filter((m) => !m.isHidden)
                .slice(-10)
                .map((msg) => {
                  const sender = msg.role === "user" ? "用户" : chat.name;
                  return `${sender}: ${String(msg.content).substring(
                    0,
                    50,
                  )}...`;
                })
                .join("\n");

              const friendRequestInstruction = {
                role: "user",
                content: `
      [系统重要指令]
      用户向你发送了好友申请，理由是：“${chat.relationship.applicationReason}”。
      作为参考，这是你们之前的最后一段聊天记录：
      ---
      ${contextSummaryForApproval}
      ---
      请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。
      `,
              };
              messagesPayload.push(friendRequestInstruction);
            }

            const allRecentPosts = await db.qzonePosts
              .orderBy("timestamp")
              .reverse()
              .limit(5)
              .toArray();
            // 【核心修改】在这里插入过滤步骤
            const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

            if (visiblePosts.length > 0 && !chat.isGroup) {
              let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
              const aiName = chat.name;
              for (const post of visiblePosts) {
                let authorName =
                  post.authorId === "user"
                    ? state.qzoneSettings.nickname
                    : state.chats[post.authorId]?.name || "一位朋友";
                let interactionStatus = "";
                if (post.likes && post.likes.includes(aiName))
                  interactionStatus += " [你已点赞]";
                if (
                  post.comments &&
                  post.comments.some((c) => c.commenterName === aiName)
                )
                  interactionStatus += " [你已评论]";
                if (post.authorId === chatId) authorName += " (这是你的帖子)";
                const contentSummary =
                  (post.publicText || post.content || "图片动态").substring(
                    0,
                    30,
                  ) + "...";
                postsContext += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentSummary}"${interactionStatus}\n`;
              }
              messagesPayload.push({ role: "system", content: postsContext });
            }
            let isGemini = proxyUrl === GEMINI_API_URL;
            let aiResponseContent = "";

            // --- 【核心修改】检查是否开启流式请求 (仅限非原生Gemini渠道) ---
            if ((getActiveApiConfig() || {}).enableStreaming && !isGemini) {
              console.log("正在使用流式请求 (OpenAI兼容模式)...");
              const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${apiKey}`,
                },
                body: JSON.stringify({
                  model: model,
                  messages: [
                    { role: "system", content: systemPrompt },
                    ...messagesPayload,
                  ],
                  temperature: enableTemp ? temperature : undefined,
                  top_p: enableTopP ? topP : undefined,
                  top_k: enableTopK ? topK : undefined,
                  stream: true, // <--- 开启流式
                }),
              });

              if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                  const errorData = await response.json();
                  errorMsg += ` - ${
                    errorData?.error?.message || JSON.stringify(errorData)
                  }`;
                } catch (e) {
                  errorMsg += ` - ${await response.text()}`;
                }
                throw new Error(errorMsg);
              }

              // --- 处理流式响应 ---
              const reader = response.body.getReader();
              const decoder = new TextDecoder("utf-8");
              let buffer = "";

              while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;

                const lines = buffer.split("\n");
                buffer = lines.pop(); // 保留最后一个可能不完整的行

                for (const line of lines) {
                  const trimmed = line.trim();
                  if (trimmed.startsWith("data: ")) {
                    const dataStr = trimmed.slice(6);
                    if (dataStr === "[DONE]") continue;
                    try {
                      const dataObj = JSON.parse(dataStr);
                      const delta = dataObj.choices[0].delta?.content || "";
                      aiResponseContent += delta;
                    } catch (e) {
                      // 忽略解析错误
                    }
                  }
                }
              }
            } else {
              // --- 原有的非流式逻辑 (包含原生Gemini支持) ---
              let geminiConfig = toGeminiRequestData(
                model,
                apiKey,
                systemPrompt,
                messagesPayload,
                isGemini,
                enableTemp ? temperature : undefined,
                enableTopP ? topP : undefined,
                enableTopK ? topK : undefined,
              );
              const response = isGemini
                ? await fetch(geminiConfig.url, geminiConfig.data)
                : await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                      Authorization: `Bearer ${apiKey}`,
                    },
                    body: JSON.stringify({
                      model: model,
                      messages: [
                        { role: "system", content: systemPrompt },
                        ...messagesPayload,
                      ],
                      temperature: enableTemp ? temperature : undefined,
                      top_p: enableTopP ? topP : undefined,
                      top_k: enableTopK ? topK : undefined,
                      stream: false,
                    }),
                  });

              if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                  const errorData = await response.json();
                  errorMsg += ` - ${
                    errorData?.error?.message || JSON.stringify(errorData)
                  }`;
                } catch (jsonError) {
                  errorMsg += ` - ${await response.text()}`;
                }
                throw new Error(errorMsg);
              }
              const data = await response.json();
              aiResponseContent = isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content;
            }

            console.log(`AI '${chat.name}' 的原始回复:`, aiResponseContent);

            chat.history = chat.history.filter((msg) => !msg.isTemporary);

            const messagesArray = parseAiResponse(aiResponseContent);

            const isViewingThisChat =
              document
                .getElementById("chat-interface-screen")
                .classList.contains("active") && state.activeChatId === chatId;

            let callHasBeenHandled = false;

            let messageTimestamp = Date.now();

            // ★★★ 核心修复 第1步: 初始化一个新数组，用于收集需要渲染的消息 ★★★
            let newMessagesToRender = [];

            let notificationShown = false;

            for (const msgData of messagesArray) {
              if (!msgData || typeof msgData !== "object") {
                console.warn("收到了格式不规范的AI指令，已跳过:", msgData);
                continue;
              }

              if (!msgData.type) {
                if (chat.isGroup && msgData.name && msgData.message) {
                  msgData.type = "text";
                } else if (msgData.content) {
                  msgData.type = "text";
                }
                // 如果连 content 都没有，才是真的格式不规范
                else {
                  console.warn(
                    "收到了格式不规范的AI指令（缺少type和content），已跳过:",
                    msgData,
                  );
                  continue;
                }
              }

              if (msgData.type === "video_call_response") {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === "accept") {
                  startVideoCall();
                } else {
                  const aiMessage = {
                    role: "assistant",
                    content: "对方拒绝了你的视频通话请求。",
                    timestamp: Date.now(),
                  };
                  chat.history.push(aiMessage);
                  await db.chats.put(chat);
                  showScreen("chat-interface-screen");
                  renderChatInterface(chatId);
                }
                callHasBeenHandled = true;
                break;
              }

              if (msgData.type === "group_call_response") {
                if (msgData.decision === "join") {
                  const member = chat.members.find(
                    (m) => m.originalName === msgData.name,
                  );
                  if (
                    member &&
                    !videoCallState.participants.some((p) => p.id === member.id)
                  ) {
                    videoCallState.participants.push(member);
                  }
                }
                callHasBeenHandled = true;
                continue;
              }

              if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(
                  `AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`,
                  msgData,
                );
                continue;
              }

              // 【核心修正】在群聊中，如果AI返回的消息没有指定发送者，则直接跳过这条消息
              if (chat.isGroup && !msgData.name) {
                console.error(
                  `AI幻觉已被拦截！试图在群聊中发送一条没有“name”的消息。消息内容:`,
                  msgData,
                );
                continue; // continue会立即结束本次循环，处理下一条消息
              }

              let aiMessage = null;
              const baseMessage = {
                role: "assistant",
                senderName: msgData.name || chat.name,
                timestamp: messageTimestamp++,
              };

              switch (msgData.type) {
                case "waimai_response":
                  const requestMessageIndex = chat.history.findIndex(
                    (m) => m.timestamp === msgData.for_timestamp,
                  );
                  if (requestMessageIndex > -1) {
                    const originalMsg = chat.history[requestMessageIndex];
                    originalMsg.status = msgData.status;
                    originalMsg.paidBy =
                      msgData.status === "paid" ? msgData.name : null;
                  }
                  continue;

                case "qzone_post":
                  const newPost = {
                    type: msgData.postType,
                    content: msgData.content || "",
                    publicText: msgData.publicText || "",
                    hiddenContent: msgData.hiddenContent || "",
                    timestamp: Date.now(),
                    authorId: chatId,
                    authorGroupId: chat.groupId, // 【核心新增】记录作者的分组ID
                    visibleGroupIds: null,
                  };
                  await db.qzonePosts.add(newPost);
                  updateUnreadIndicator(unreadPostsCount + 1);
                  if (
                    isViewingThisChat &&
                    document
                      .getElementById("qzone-screen")
                      .classList.contains("active")
                  ) {
                    await renderQzonePosts();
                  }
                  continue;

                case "qzone_comment":
                  const postToComment = await db.qzonePosts.get(
                    parseInt(msgData.postId),
                  );
                  if (postToComment) {
                    if (!postToComment.comments) postToComment.comments = [];
                    postToComment.comments.push({
                      commenterName: chat.name,
                      text: msgData.commentText,
                      timestamp: Date.now(),
                    });
                    await db.qzonePosts.update(postToComment.id, {
                      comments: postToComment.comments,
                    });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (
                      isViewingThisChat &&
                      document
                        .getElementById("qzone-screen")
                        .classList.contains("active")
                    ) {
                      await renderQzonePosts();
                    }
                  }
                  continue;

                case "qzone_like":
                  const postToLike = await db.qzonePosts.get(
                    parseInt(msgData.postId),
                  );
                  if (postToLike) {
                    if (!postToLike.likes) postToLike.likes = [];
                    if (!postToLike.likes.includes(chat.name)) {
                      postToLike.likes.push(chat.name);
                      await db.qzonePosts.update(postToLike.id, {
                        likes: postToLike.likes,
                      });
                      updateUnreadIndicator(unreadPostsCount + 1);
                      if (
                        isViewingThisChat &&
                        document
                          .getElementById("qzone-screen")
                          .classList.contains("active")
                      ) {
                        await renderQzonePosts();
                      }
                    }
                  }
                  continue;

                case "video_call_request":
                  if (
                    !videoCallState.isActive &&
                    !videoCallState.isAwaitingResponse
                  ) {
                    state.activeChatId = chatId;
                    videoCallState.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = chat.isGroup;
                    videoCallState.callRequester = msgData.name || chat.name;
                    showIncomingCallModal();
                  }
                  continue;

                case "group_call_request":
                  if (
                    !videoCallState.isActive &&
                    !videoCallState.isAwaitingResponse
                  ) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = "ai";
                    videoCallState.callRequester = msgData.name;
                    showIncomingCallModal();
                  }
                  continue;

                case "pat_user":
                  const suffix = msgData.suffix
                    ? ` ${msgData.suffix.trim()}`
                    : "";
                  const patText = `${
                    msgData.name || chat.name
                  } 拍了拍我${suffix}`;
                  const patMessage = {
                    role: "system",
                    type: "pat_message",
                    content: patText,
                    timestamp: Date.now(),
                  };
                  chat.history.push(patMessage);
                  if (isViewingThisChat) {
                    const phoneScreen = document.getElementById("phone-screen");
                    phoneScreen.classList.remove("pat-animation");
                    void phoneScreen.offsetWidth;
                    phoneScreen.classList.add("pat-animation");
                    setTimeout(
                      () => phoneScreen.classList.remove("pat-animation"),
                      500,
                    );
                    appendMessage(patMessage, chat);
                  } else {
                    showNotification(chatId, patText);
                  }
                  continue;

                case "update_status":
                  chat.status.text = msgData.status_text;
                  chat.status.isBusy = msgData.is_busy || false;
                  chat.status.lastUpdate = Date.now();

                  const statusUpdateMessage = {
                    role: "system",
                    type: "pat_message",
                    content: `[${chat.name}的状态已更新为: ${msgData.status_text}]`,
                    timestamp: Date.now(),
                  };
                  chat.history.push(statusUpdateMessage);

                  if (isViewingThisChat) {
                    appendMessage(statusUpdateMessage, chat);
                  }

                  renderChatList();

                  continue;

                case "change_music":
                  if (
                    musicState.isActive &&
                    musicState.activeChatId === chatId
                  ) {
                    const songNameToFind = msgData.song_name;

                    const targetSongIndex = musicState.playlist.findIndex(
                      (track) =>
                        track.name.toLowerCase() ===
                        songNameToFind.toLowerCase(),
                    );

                    if (targetSongIndex > -1) {
                      playSong(targetSongIndex);

                      const track = musicState.playlist[targetSongIndex];
                      const musicChangeMessage = {
                        role: "system",
                        type: "pat_message",
                        content: `[♪ ${chat.name} 为你切歌: 《${track.name}》 - ${track.artist}]`,
                        timestamp: Date.now(),
                      };
                      chat.history.push(musicChangeMessage);

                      if (isViewingThisChat) {
                        appendMessage(musicChangeMessage, chat);
                      }
                    }
                  }
                  continue;
                case "create_memory":
                  const newMemory = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.description,
                    timestamp: Date.now(),
                    type: "ai_generated",
                  };
                  await db.memories.add(newMemory);

                  console.log(
                    `AI "${chat.name}" 记录了一条新回忆:`,
                    msgData.description,
                  );

                  continue;

                case "create_countdown":
                  const targetDate = new Date(msgData.date);
                  if (!isNaN(targetDate) && targetDate > new Date()) {
                    const newCountdown = {
                      chatId: chatId,
                      authorName: chat.name,
                      description: msgData.title,
                      timestamp: Date.now(),
                      type: "countdown",
                      targetDate: targetDate.getTime(),
                    };
                    await db.memories.add(newCountdown);
                    console.log(
                      `AI "${chat.name}" 创建了一个新约定:`,
                      msgData.title,
                    );
                  }
                  continue;

                case "block_user":
                  if (!chat.isGroup) {
                    chat.relationship.status = "blocked_by_ai";

                    const hiddenMessage = {
                      role: "system",
                      content: `[系统提示：你刚刚主动拉黑了用户。]`,
                      timestamp: Date.now(),
                      isHidden: true,
                    };
                    chat.history.push(hiddenMessage);

                    await db.chats.put(chat);

                    if (isViewingThisChat) {
                      renderChatInterface(chatId);
                    }
                    renderChatList();

                    break;
                  }
                  continue;
                case "friend_request_response":
                  if (
                    !chat.isGroup &&
                    chat.relationship.status === "pending_ai_approval"
                  ) {
                    if (msgData.decision === "accept") {
                      chat.relationship.status = "friend";
                      aiMessage = {
                        ...baseMessage,
                        content: "我通过了你的好友申请，我们现在是好友啦！",
                      };
                    } else {
                      chat.relationship.status = "blocked_by_ai";
                      aiMessage = {
                        ...baseMessage,
                        content: "抱歉，我拒绝了你的好友申请。",
                      };
                    }
                    chat.relationship.applicationReason = "";
                  }
                  break;
                case "poll":
                  const pollOptions =
                    typeof msgData.options === "string"
                      ? msgData.options.split("\n").filter((opt) => opt.trim())
                      : Array.isArray(msgData.options)
                        ? msgData.options
                        : [];

                  if (pollOptions.length < 2) continue;

                  aiMessage = {
                    ...baseMessage,
                    type: "poll",
                    question: msgData.question,
                    options: pollOptions,
                    votes: {},
                    isClosed: false,
                  };
                  break;

                case "vote":
                  const pollToVote = chat.history.find(
                    (m) => m.timestamp === msgData.poll_timestamp,
                  );
                  if (pollToVote && !pollToVote.isClosed) {
                    Object.keys(pollToVote.votes).forEach((option) => {
                      const voterIndex = pollToVote.votes[option].indexOf(
                        msgData.name,
                      );
                      if (voterIndex > -1) {
                        pollToVote.votes[option].splice(voterIndex, 1);
                      }
                    });
                    if (!pollToVote.votes[msgData.choice]) {
                      pollToVote.votes[msgData.choice] = [];
                    }

                    const member = chat.members.find(
                      (m) => m.originalName === msgData.name,
                    );
                    const displayName = member
                      ? member.groupNickname
                      : msgData.name;

                    if (
                      !pollToVote.votes[msgData.choice].includes(displayName)
                    ) {
                      // 【核心修改】
                      pollToVote.votes[msgData.choice].push(displayName); // 【核心修改】
                    }

                    if (isViewingThisChat) {
                      renderChatInterface(chatId);
                    }
                  }
                  continue;

                case "red_packet":
                  aiMessage = {
                    ...baseMessage,
                    type: "red_packet",
                    packetType: msgData.packetType,
                    totalAmount: msgData.amount,
                    count: msgData.count,
                    greeting: msgData.greeting,
                    receiverName: msgData.receiver,
                    claimedBy: {},
                    isFullyClaimed: false,
                  };
                  break;
                case "open_red_packet":
                  const packetToOpen = chat.history.find(
                    (m) => m.timestamp === msgData.packet_timestamp,
                  );
                  if (
                    packetToOpen &&
                    !packetToOpen.isFullyClaimed &&
                    !(
                      packetToOpen.claimedBy &&
                      packetToOpen.claimedBy[msgData.name]
                    )
                  ) {
                    // 1. 根据AI的本名(msgData.name)去成员列表里找到完整的成员对象
                    const member = chat.members.find(
                      (m) => m.originalName === msgData.name,
                    );
                    // 2. 获取该成员当前的群昵称，如果找不到（异常情况），则备用其本名
                    const displayName = member
                      ? member.groupNickname
                      : msgData.name;

                    let claimedAmountAI = 0;
                    const remainingAmount =
                      packetToOpen.totalAmount -
                      Object.values(packetToOpen.claimedBy || {}).reduce(
                        (sum, val) => sum + val,
                        0,
                      );
                    const remainingCount =
                      packetToOpen.count -
                      Object.keys(packetToOpen.claimedBy || {}).length;

                    if (remainingCount > 0) {
                      if (remainingCount === 1) {
                        claimedAmountAI = remainingAmount;
                      } else {
                        const min = 0.01;
                        const max =
                          remainingAmount - (remainingCount - 1) * min;
                        claimedAmountAI = Math.random() * (max - min) + min;
                      }
                      claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));

                      if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
                      // 【核心修改】使用我们刚刚查找到的 displayName 作为记录的key
                      packetToOpen.claimedBy[displayName] = claimedAmountAI;

                      const aiClaimedMessage = {
                        role: "system",
                        type: "pat_message",
                        // 【核心修改】系统消息里也使用 displayName
                        content: `${displayName} 领取了 ${packetToOpen.senderName} 的红包`,
                        timestamp: Date.now(),
                      };
                      chat.history.push(aiClaimedMessage);

                      let hiddenContentForAI = `[系统提示：你 (${displayName}) 成功抢到了 ${claimedAmountAI.toFixed(
                        2,
                      )} 元。`; // 【核心修改】

                      if (
                        Object.keys(packetToOpen.claimedBy).length >=
                        packetToOpen.count
                      ) {
                        packetToOpen.isFullyClaimed = true;

                        const finishedMessage = {
                          role: "system",
                          type: "pat_message",
                          content: `${packetToOpen.senderName} 的红包已被领完`,
                          timestamp: Date.now() + 1,
                        };
                        chat.history.push(finishedMessage);

                        let luckyKing = { name: "", amount: -1 };
                        if (
                          packetToOpen.packetType === "lucky" &&
                          packetToOpen.count > 1
                        ) {
                          Object.entries(packetToOpen.claimedBy).forEach(
                            ([name, amount]) => {
                              if (amount > luckyKing.amount) {
                                luckyKing = { name, amount };
                              }
                            },
                          );
                        }
                        if (luckyKing.name) {
                          hiddenContentForAI += ` 红包已被领完，手气王是 ${luckyKing.name}！`;
                        } else {
                          hiddenContentForAI += ` 红包已被领完。`;
                        }
                      }
                      hiddenContentForAI += " 请根据这个结果发表你的评论。]";

                      const hiddenMessageForAI = {
                        role: "system",
                        content: hiddenContentForAI,
                        timestamp: Date.now() + 2,
                        isHidden: true,
                      };
                      chat.history.push(hiddenMessageForAI);
                    }

                    if (isViewingThisChat) {
                      renderChatInterface(chatId);
                    }
                  }
                  continue;
                case "change_avatar":
                  const avatarName = msgData.name;
                  // 在该角色的头像库中查找
                  const foundAvatar = chat.settings.aiAvatarLibrary.find(
                    (avatar) => avatar.name === avatarName,
                  );

                  if (foundAvatar) {
                    // 找到了，就更新头像
                    chat.settings.aiAvatar = foundAvatar.url;

                    // 创建一条系统提示，告知用户头像已更换
                    const systemNotice = {
                      role: "system",
                      type: "pat_message", // 复用居中样式
                      content: `[${chat.name} 更换了头像]`,
                      timestamp: Date.now(),
                    };
                    chat.history.push(systemNotice);

                    // 如果在当前聊天界面，则实时渲染
                    if (isViewingThisChat) {
                      appendMessage(systemNotice, chat);
                      // 立刻刷新聊天界面以显示新头像
                      renderChatInterface(chatId);
                    }
                  }
                  // 处理完后，继续处理AI可能返回的其他消息
                  continue;

                case "accept_transfer": {
                  // 使用大括号创建块级作用域
                  const originalTransferMsgIndex = chat.history.findIndex(
                    (m) => m.timestamp === msgData.for_timestamp,
                  );
                  if (originalTransferMsgIndex > -1) {
                    const originalMsg = chat.history[originalTransferMsgIndex];
                    originalMsg.status = "accepted";
                  }
                  continue; // 接受指令只修改状态，不产生新消息
                }

                case "decline_transfer": {
                  // 使用大括号创建块级作用域
                  const originalTransferMsgIndex = chat.history.findIndex(
                    (m) => m.timestamp === msgData.for_timestamp,
                  );
                  if (originalTransferMsgIndex > -1) {
                    const originalMsg = chat.history[originalTransferMsgIndex];
                    originalMsg.status = "declined";

                    // 【核心】创建一条新的“退款”消息
                    const refundMessage = {
                      role: "assistant",
                      senderName: chat.name,
                      type: "transfer",
                      isRefund: true, // 标记这是一条退款消息
                      amount: originalMsg.amount,
                      note: "转账已被拒收",
                      timestamp: messageTimestamp++, // 使用递增的时间戳
                    };

                    // 将新消息推入历史记录，它会被后续的循环处理并渲染
                    chat.history.push(refundMessage);

                    if (isViewingThisChat) {
                      // 因为退款消息是新生成的，所以我们直接将它添加到界面上
                      appendMessage(refundMessage, chat);
                      // 同时，原始的转账消息状态变了，所以要重绘整个界面以更新它
                      renderChatInterface(chatId);
                    }
                  }
                  continue; // 继续处理AI返回的文本消息
                }

                case "system_message":
                  aiMessage = {
                    role: "system",
                    type: "pat_message",
                    content: msgData.content,
                    timestamp: Date.now(),
                  };
                  break;

                case "share_link":
                  aiMessage = {
                    ...baseMessage,
                    type: "share_link",
                    title: msgData.title,
                    description: msgData.description,
                    // thumbnail_url: msgData.thumbnail_url, // 我们已经决定不要图片了，所以这行可以不要
                    source_name: msgData.source_name,
                    content: msgData.content, // 这是文章正文，点击卡片后显示的内容
                  };
                  break;

                case "quote_reply":
                  const originalMessage = chat.history.find(
                    (m) => m.timestamp === msgData.target_timestamp,
                  );
                  if (originalMessage) {
                    const quoteContext = {
                      timestamp: originalMessage.timestamp,
                      senderName:
                        originalMessage.senderName ||
                        (originalMessage.role === "user"
                          ? chat.settings.myNickname || "我"
                          : chat.name),
                      content: String(originalMessage.content || "").substring(
                        0,
                        50,
                      ),
                    };
                    aiMessage = {
                      ...baseMessage,
                      content: String(msgData.reply_content || "").trim(),
                      quote: quoteContext, // 核心：在这里附加引用对象
                    };
                  } else {
                    // 如果找不到被引用的消息，就当作普通消息发送
                    aiMessage = {
                      ...baseMessage,
                      content: String(msgData.reply_content || "").trim(),
                    };
                  }
                  break;

                case "send_and_recall": {
                  // 这是一个纯动画指令，我们需要手动“演”出整个过程
                  if (!isViewingThisChat) continue; // 如果不在当前聊天界面，就直接跳过这个动画

                  const cleanedContent = String(msgData.content || "").trim();

                  // 1. 创建一个临时的、看起来像真消息的气泡
                  const tempMessageData = {
                    ...baseMessage,
                    content: cleanedContent,
                  };
                  const tempMessageElement = createMessageElement(
                    tempMessageData,
                    chat,
                  );

                  // 2. 把它添加到聊天界面上，让用户看到
                  appendMessage(tempMessageData, chat, true); // true表示这是初始加载，不会触发进入动画

                  // 3. 等待片刻，模拟AI的“反应时间”
                  await new Promise((resolve) =>
                    setTimeout(resolve, Math.random() * 1000 + 1500),
                  ); // 随机等待1.5-2.5秒

                  // 4. 找到刚刚添加的临时气泡，并播放撤回动画
                  const bubbleWrapper = document
                    .querySelector(
                      `.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`,
                    )
                    ?.closest(".message-wrapper");
                  if (bubbleWrapper) {
                    bubbleWrapper.classList.add("recalled-animation");

                    // 5. 在动画播放结束后，将其替换为真正的“已撤回”提示
                    await new Promise((resolve) => setTimeout(resolve, 300)); // 等待动画播完

                    // 6. 最后，才把这条“已撤回”记录真正地存入数据库
                    const recalledMessage = {
                      role: "assistant",
                      senderName: msgData.name || chat.name,
                      type: "recalled_message",
                      content: "对方撤回了一条消息",
                      timestamp: tempMessageData.timestamp, // 使用临时消息的时间戳，保证顺序
                      recalledData: {
                        originalType: "text",
                        originalContent: cleanedContent,
                      },
                    };

                    // 更新数据模型
                    const msgIndex = chat.history.findIndex(
                      (m) => m.timestamp === tempMessageData.timestamp,
                    );
                    if (msgIndex > -1) {
                      chat.history[msgIndex] = recalledMessage;
                    } else {
                      chat.history.push(recalledMessage);
                    }
                    const insertedIndex =
                      msgIndex > -1 ? msgIndex : chat.history.length - 1;

                    // 替换DOM
                    const placeholder = createMessageElement(
                      recalledMessage,
                      chat,
                      insertedIndex,
                    );
                    if (document.body.contains(bubbleWrapper)) {
                      bubbleWrapper.parentNode.replaceChild(
                        placeholder,
                        bubbleWrapper,
                      );
                    }
                  }

                  continue; // 处理完这个动画后，继续处理AI返回的下一条指令
                }

                case "text":
                  aiMessage = {
                    ...baseMessage,
                    content: String(
                      msgData.content || msgData.message || "",
                    ).trim(),
                  };
                  break;
                case "sticker":
                  aiMessage = {
                    ...baseMessage,
                    type: "sticker",
                    content: String(msgData.url || "").trim(),
                    meaning: String(msgData.meaning || "").trim(),
                  };
                  break;
                case "ai_image":
                  aiMessage = {
                    ...baseMessage,
                    type: "ai_image",
                    content: String(msgData.description || "").trim(),
                  };
                  break;
                case "voice_message":
                  aiMessage = {
                    ...baseMessage,
                    type: "voice_message",
                    content: String(msgData.content || "").trim(),
                  };
                  break;
                case "transfer":
                  aiMessage = {
                    ...baseMessage,
                    type: "transfer",
                    amount: msgData.amount,
                    note: String(msgData.note || "").trim(),
                    receiverName: msgData.receiver || "我",
                  };
                  break;

                case "waimai_request":
                  aiMessage = {
                    ...baseMessage,
                    type: "waimai_request",
                    productInfo: String(msgData.productInfo || "").trim(),
                    amount: msgData.amount,
                    status: "pending",
                    countdownEndTime: Date.now() + 15 * 60 * 1000,
                  };
                  break;

                default:
                  console.warn("收到了未知的AI指令类型:", msgData.type);
                  break;
              }

              // 【核心修复】将渲染逻辑移出循环
                if (aiMessage) {
                  // 1. 将新消息存入历史记录
                  chat.history.push(aiMessage);
                  // 后台通知
                    if (
                      document.hidden &&
                      state.globalSettings.enableBackgroundActivity
                    ) {
                      const notificationTitle = chat.isGroup
                        ? `[群聊] ${chat.name}`
                        : chat.name;
                      const avatarUrl = chat.isGroup ? chat.groupAvatar : chat.avatar;
                      let notificationBody = "收到了一条新消息";
                      try {
                        const lastMsg = chat.history[chat.history.length - 1];
                        if (
                          lastMsg &&
                          lastMsg.content &&
                          typeof lastMsg.content === "string"
                        ) {
                          notificationBody = lastMsg.content.substring(0, 100);
                        }
                      } catch (e) {}
                      sendLocalNotification(
                        notificationTitle,
                        notificationBody,
                        state.activeChatId,
                        avatarUrl,
                      );
                    }

                  if (!isViewingThisChat && !notificationShown) {
                  let notificationText;
                  switch (aiMessage.type) {
                    case "transfer":
                      notificationText = `[收到一笔转账]`;
                      break;
                    case "waimai_request":
                      notificationText = `[收到一个外卖代付请求]`;
                      break;
                    case "ai_image":
                      notificationText = `[图片]`;
                      break;
                    case "voice_message":
                      notificationText = `[语音]`;
                      break;
                    case "sticker":
                      notificationText = aiMessage.meaning
                        ? `[表情: ${aiMessage.meaning}]`
                        : "[表情]";
                      break;
                    default:
                      notificationText = String(aiMessage.content || "");
                  }
                  const finalNotifText = chat.isGroup
                    ? `${aiMessage.senderName}: ${notificationText}`
                    : notificationText;
                  showNotification(
                    chatId,
                    finalNotifText.substring(0, 40) +
                      (finalNotifText.length > 40 ? "..." : ""),
                  );
                  notificationShown = true; // 确保只通知一次
                }

                if (!isViewingThisChat) {
                  // 如果用户不在当前聊天界面，就把这个聊天的未读数 +1
                  chat.unreadCount = (chat.unreadCount || 0) + 1;
                }

                // 2. 只有在当前聊天界面时，才执行带动画的添加
                if (isViewingThisChat) {
                  appendMessage(aiMessage, chat);
                  // 后台通知
                    if (document.hidden && state.globalSettings.enableBackgroundActivity) {
                      const notificationTitle = chat.isGroup
                        ? `[群聊] ${chat.name}`
                        : chat.name;
                      const avatarUrl = chat.isGroup ? chat.groupAvatar : chat.avatar;
                      let notificationBody = "收到了一条新消息";
                      try {
                        const lastMsg = chat.messages && chat.messages.length
                          ? chat.messages[chat.messages.length - 1]
                          : chat.history[chat.history.length - 1];
                        if (
                          lastMsg &&
                          lastMsg.content &&
                          typeof lastMsg.content === "string"
                        ) {
                          notificationBody = lastMsg.content.substring(0, 100);
                        }
                      } catch (e) {}
                      sendLocalNotification(
                        notificationTitle,
                        notificationBody,
                        state.activeChatId,
                        avatarUrl,
                      );
                    }
                  // 3. 【关键】在这里暂停一小会儿，给动画播放的时间
                  await new Promise((resolve) =>
                    setTimeout(resolve, Math.random() * 1800 + 1000),
                  );
                }
              }
            }

            if (callHasBeenHandled && videoCallState.isGroupCall) {
              videoCallState.isAwaitingResponse = false;
              if (videoCallState.participants.length > 0) {
                startVideoCall();
              } else {
                videoCallState = {
                  ...videoCallState,
                  isAwaitingResponse: false,
                  participants: [],
                };
                showScreen("chat-interface-screen");
                alert("无人接听群聊邀请。");
              }
            }

            await db.chats.put(chat);
            // 触发总结检查
            await checkAndTriggerSummary(chatId);
          } catch (error) {
            chat.history = chat.history.filter((msg) => !msg.isTemporary);
            if (
              !chat.isGroup &&
              chat.relationship?.status === "pending_ai_approval"
            ) {
              chat.relationship.status = "blocked_by_ai";
              await showCustomAlert(
                "申请失败",
                `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`,
              );
            } else {
              const errorContent = `[出错了: ${error.message}]`;
              const errorMessage = {
                role: "assistant",
                content: errorContent,
                timestamp: Date.now(),
              };
              if (chat.isGroup) errorMessage.senderName = "系统消息";
              chat.history.push(errorMessage);
            }

            await db.chats.put(chat);
            videoCallState.isAwaitingResponse = false;

            if (
              document
                .getElementById("chat-interface-screen")
                .classList.contains("active") &&
              state.activeChatId === chatId
            ) {
              renderChatInterface(chatId);
            }
          } finally {
            // ★★★★★【核心修改4：在 finally 块中统一隐藏所有类型的提示】★★★★★
            if (chat.isGroup) {
              if (typingIndicator) {
                typingIndicator.style.display = "none";
              }
            } else {
              if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                  chatHeaderTitle.textContent = state.chats[chatId].name;
                  chatHeaderTitle.classList.remove("typing-status");
                  chatHeaderTitle.style.opacity = 1;
                }, 200);
              }
            }
            renderChatList();
          }
        }

        async function sendSticker(sticker) {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          const msg = {
            role: "user",
            content: sticker.url,
            meaning: sticker.name,
            timestamp: Date.now(),
          };
          chat.history.push(msg);
          await db.chats.put(chat);
          appendMessage(msg, chat);
          renderChatList();
          document.getElementById("sticker-panel").classList.remove("visible");
        }

        async function sendUserTransfer() {
          if (!state.activeChatId) return;
          const amountInput = document.getElementById("transfer-amount");
          const noteInput = document.getElementById("transfer-note");
          const amount = parseFloat(amountInput.value);
          const note = noteInput.value.trim();
          if (isNaN(amount) || amount < 0 || amount > 9999) {
            alert("请输入有效的金额 (0 到 9999 之间)！");
            return;
          }
          const chat = state.chats[state.activeChatId];
          const senderName = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";
          const receiverName = chat.isGroup ? "群聊" : chat.name;
          const msg = {
            role: "user",
            type: "transfer",
            amount: amount,
            note: note,
            senderName,
            receiverName,
            timestamp: Date.now(),
          };
          chat.history.push(msg);
          await db.chats.put(chat);
          appendMessage(msg, chat);
          renderChatList();
          document.getElementById("transfer-modal").classList.remove("visible");
          amountInput.value = "";
          noteInput.value = "";
        }

        function enterSelectionMode(initialMsgTimestamp) {
          if (isSelectionMode) return;
          isSelectionMode = true;
          document
            .getElementById("chat-interface-screen")
            .classList.add("selection-mode");
          toggleMessageSelection(initialMsgTimestamp);
        }

        function exitSelectionMode() {
          cleanupWaimaiTimers(); // <--- 在这里添加这行代码
          if (!isSelectionMode) return;
          isSelectionMode = false;
          document
            .getElementById("chat-interface-screen")
            .classList.remove("selection-mode");
          selectedMessages.forEach((ts) => {
            const bubble = document.querySelector(
              `.message-bubble[data-timestamp="${ts}"]`,
            );
            if (bubble) bubble.classList.remove("selected");
          });
          selectedMessages.clear();
        }

        function toggleMessageSelection(timestamp) {
          // 【核心修正】选择器已简化，不再寻找已删除的 .recalled-message-placeholder
          const elementToSelect = document.querySelector(
            `.message-bubble[data-timestamp="${timestamp}"]`,
          );

          if (!elementToSelect) return;

          if (selectedMessages.has(timestamp)) {
            selectedMessages.delete(timestamp);
            elementToSelect.classList.remove("selected");
          } else {
            selectedMessages.add(timestamp);
            elementToSelect.classList.add("selected");
          }

          document.getElementById("selection-count").textContent =
            `已选 ${selectedMessages.size} 条`;

          if (selectedMessages.size === 0) {
            exitSelectionMode();
          }
        }

        function addLongPressListener(element, callback) {
          let pressTimer;
          const startPress = (e) => {
            if (isSelectionMode) return;
            e.preventDefault();
            pressTimer = window.setTimeout(() => callback(e), 500);
          };
          const cancelPress = () => clearTimeout(pressTimer);
          element.addEventListener("mousedown", startPress);
          element.addEventListener("mouseup", cancelPress);
          element.addEventListener("mouseleave", cancelPress);
          element.addEventListener("touchstart", startPress, { passive: true });
          element.addEventListener("touchend", cancelPress);
          element.addEventListener("touchmove", cancelPress);
        }

        async function handleListenTogetherClick() {
          const targetChatId = state.activeChatId;
          if (!targetChatId) return;
          if (!musicState.isActive) {
            startListenTogetherSession(targetChatId);
            return;
          }
          if (musicState.activeChatId === targetChatId) {
            document
              .getElementById("music-player-overlay")
              .classList.add("visible");
          } else {
            const oldChatName =
              state.chats[musicState.activeChatId]?.name || "未知";
            const newChatName = state.chats[targetChatId]?.name || "当前";
            const confirmed = await showCustomConfirm(
              "切换听歌对象",
              `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`,
              { confirmButtonClass: "btn-danger" },
            );
            if (confirmed) {
              await endListenTogetherSession(true);
              await new Promise((resolve) => setTimeout(resolve, 50));
              startListenTogetherSession(targetChatId);
            }
          }
        }

        async function startListenTogetherSession(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return;
          musicState.totalElapsedTime = chat.musicData.totalTime || 0;
          musicState.isActive = true;
          musicState.activeChatId = chatId;
          if (musicState.playlist.length > 0) {
            musicState.currentIndex = 0;
          } else {
            musicState.currentIndex = -1;
          }
          if (musicState.timerId) clearInterval(musicState.timerId);
          musicState.timerId = setInterval(() => {
            if (musicState.isPlaying) {
              musicState.totalElapsedTime++;
              updateElapsedTimeDisplay();
            }
          }, 1000);
          updatePlayerUI();
          updatePlaylistUI();
          document
            .getElementById("music-player-overlay")
            .classList.add("visible");
        }

        async function endListenTogetherSession(saveState = true) {
          if (!musicState.isActive) return;
          const oldChatId = musicState.activeChatId;
          const cleanupLogic = async () => {
            if (musicState.timerId) clearInterval(musicState.timerId);
            if (musicState.isPlaying) audioPlayer.pause();
            if (saveState && oldChatId && state.chats[oldChatId]) {
              const chat = state.chats[oldChatId];
              chat.musicData.totalTime = musicState.totalElapsedTime;
              await db.chats.put(chat);
            }
            musicState.isActive = false;
            musicState.activeChatId = null;
            musicState.totalElapsedTime = 0;
            musicState.timerId = null;
            updateListenTogetherIcon(oldChatId, true);
          };
          closeMusicPlayerWithAnimation(cleanupLogic);
        }

        function returnToChat() {
          closeMusicPlayerWithAnimation();
        }

        function updateListenTogetherIcon(chatId, forceReset = false) {
          const iconImg = document.querySelector("#listen-together-btn img");
          if (!iconImg) return;
          if (
            forceReset ||
            !musicState.isActive ||
            musicState.activeChatId !== chatId
          ) {
            iconImg.src = "https://i.postimg.cc/8kYShvrJ/90-UI-2.png";
            iconImg.className = "";
            return;
          }
          iconImg.src =
            "https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png";
          iconImg.classList.add("rotating");
          if (musicState.isPlaying) iconImg.classList.remove("paused");
          else iconImg.classList.add("paused");
        }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() {
          updateListenTogetherIcon(musicState.activeChatId);
          updateElapsedTimeDisplay();
          const titleEl = document.getElementById("music-player-song-title");
          const artistEl = document.getElementById("music-player-artist");
          const playPauseBtn = document.getElementById("music-play-pause-btn");
          if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
            const track = musicState.playlist[musicState.currentIndex];
            titleEl.textContent = track.name;
            artistEl.textContent = track.artist;
          } else {
            titleEl.textContent = "请添加歌曲";
            artistEl.textContent = "...";
          }
          playPauseBtn.textContent = musicState.isPlaying ? "❚❚" : "▶";
        }

        function updateElapsedTimeDisplay() {
          const hours = (musicState.totalElapsedTime / 3600).toFixed(1);
          document.getElementById("music-time-counter").textContent =
            `已经一起听了${hours}小时`;
        }

        function updatePlaylistUI() {
          const playlistBody = document.getElementById("playlist-body");
          playlistBody.innerHTML = "";
          if (musicState.playlist.length === 0) {
            playlistBody.innerHTML =
              '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
            return;
          }
          musicState.playlist.forEach((track, index) => {
            const item = document.createElement("div");
            item.className = "playlist-item";
            if (index === musicState.currentIndex)
              item.classList.add("playing");
            item.innerHTML = `
                  <div class="playlist-item-info">
                      <div class="title">${track.name}</div>
                      <div class="artist">${track.artist}</div>
                  </div>
                  <div class="playlist-item-actions">
                      <span class="playlist-action-btn lyrics-btn" data-index="${index}">词</span>
                      <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
                  </div>
              `;
            item
              .querySelector(".playlist-item-info")
              .addEventListener("click", () => playSong(index));
            playlistBody.appendChild(item);
          });
        }

        function playSong(index) {
          if (index < 0 || index >= musicState.playlist.length) return;
          musicState.currentIndex = index;
          const track = musicState.playlist[index];
          musicState.parsedLyrics = parseLRC(track.lrcContent || "");
          musicState.currentLyricIndex = -1;
          renderLyrics();
          if (track.isLocal && track.src instanceof Blob) {
            audioPlayer.src = URL.createObjectURL(track.src);
          } else if (!track.isLocal) {
            audioPlayer.src = track.src;
          } else {
            console.error("本地歌曲源错误:", track);
            return;
          }
          audioPlayer.play();
          updatePlaylistUI();
          updatePlayerUI();
          updateMusicProgressBar();
        }

        function togglePlayPause() {
          if (audioPlayer.paused) {
            if (
              musicState.currentIndex === -1 &&
              musicState.playlist.length > 0
            ) {
              playSong(0);
            } else if (musicState.currentIndex > -1) {
              audioPlayer.play();
            }
          } else {
            audioPlayer.pause();
          }
        }

        function playNext() {
          if (musicState.playlist.length === 0) return;
          let nextIndex;
          switch (musicState.playMode) {
            case "random":
              nextIndex = Math.floor(
                Math.random() * musicState.playlist.length,
              );
              break;
            case "single":
              playSong(musicState.currentIndex);
              return;
            case "order":
            default:
              nextIndex =
                (musicState.currentIndex + 1) % musicState.playlist.length;
              break;
          }
          playSong(nextIndex);
        }

        function playPrev() {
          if (musicState.playlist.length === 0) return;
          const newIndex =
            (musicState.currentIndex - 1 + musicState.playlist.length) %
            musicState.playlist.length;
          playSong(newIndex);
        }

        function changePlayMode() {
          const modes = ["order", "random", "single"];
          const currentModeIndex = modes.indexOf(musicState.playMode);
          musicState.playMode = modes[(currentModeIndex + 1) % modes.length];
          document.getElementById("music-mode-btn").textContent = {
            order: "顺序",
            random: "随机",
            single: "单曲",
          }[musicState.playMode];
        }

        async function addSongFromURL() {
          const url = await showCustomPrompt(
            "添加网络歌曲",
            "请输入歌曲的URL",
            "",
            "url",
          );
          if (!url) return;
          const name = await showCustomPrompt("歌曲信息", "请输入歌名");
          if (!name) return;
          const artist = await showCustomPrompt("歌曲信息", "请输入歌手名");
          if (!artist) return;
          musicState.playlist.push({ name, artist, src: url, isLocal: false });
          await saveGlobalPlaylist();
          updatePlaylistUI();
          if (musicState.currentIndex === -1) {
            musicState.currentIndex = musicState.playlist.length - 1;
            updatePlayerUI();
          }
        }

        async function addSongFromLocal(event) {
          const files = event.target.files;
          if (!files.length) return;

          for (const file of files) {
            let name = file.name.replace(/\.[^/.]+$/, "");
            name = await showCustomPrompt("歌曲信息", "请输入歌名", name);
            if (name === null) continue;

            const artist = await showCustomPrompt(
              "歌曲信息",
              "请输入歌手名",
              "未知歌手",
            );
            if (artist === null) continue;

            let lrcContent = "";
            const wantLrc = await showCustomConfirm(
              "导入歌词",
              `要为《${name}》导入歌词文件 (.lrc) 吗？`,
            );
            if (wantLrc) {
              lrcContent = await new Promise((resolve) => {
                const lrcInput = document.getElementById("lrc-upload-input");
                const lrcChangeHandler = (e) => {
                  const lrcFile = e.target.files[0];
                  if (lrcFile) {
                    const reader = new FileReader();
                    reader.onload = (readEvent) =>
                      resolve(readEvent.target.result);
                    reader.onerror = () => resolve("");
                    reader.readAsText(lrcFile);
                  } else {
                    resolve("");
                  }
                  lrcInput.removeEventListener("change", lrcChangeHandler);
                  lrcInput.value = "";
                };
                lrcInput.addEventListener("change", lrcChangeHandler);
                lrcInput.click();
              });
            }

            musicState.playlist.push({
              name,
              artist,
              src: file,
              isLocal: true,
              lrcContent: lrcContent,
            });
          }

          await saveGlobalPlaylist();
          updatePlaylistUI();
          if (
            musicState.currentIndex === -1 &&
            musicState.playlist.length > 0
          ) {
            musicState.currentIndex = 0;
            updatePlayerUI();
          }
          event.target.value = null;
        }

        async function deleteTrack(index) {
          if (index < 0 || index >= musicState.playlist.length) return;
          const track = musicState.playlist[index];
          const wasPlaying =
            musicState.isPlaying && musicState.currentIndex === index;
          if (
            track.isLocal &&
            audioPlayer.src.startsWith("blob:") &&
            musicState.currentIndex === index
          )
            URL.revokeObjectURL(audioPlayer.src);
          musicState.playlist.splice(index, 1);
          await saveGlobalPlaylist();
          if (musicState.playlist.length === 0) {
            if (musicState.isPlaying) audioPlayer.pause();
            audioPlayer.src = "";
            musicState.currentIndex = -1;
            musicState.isPlaying = false;
          } else {
            if (wasPlaying) {
              playNext();
            } else {
              if (musicState.currentIndex >= index)
                musicState.currentIndex = Math.max(
                  0,
                  musicState.currentIndex - 1,
                );
            }
          }
          updatePlayerUI();
          updatePlaylistUI();
        }

        const personaLibraryModal = document.getElementById(
          "persona-library-modal",
        );
        const personaEditorModal = document.getElementById(
          "persona-editor-modal",
        );
        const presetActionsModal = document.getElementById(
          "preset-actions-modal",
        );

        function openPersonaLibrary() {
          renderPersonaLibrary();
          personaLibraryModal.classList.add("visible");
        }

        function closePersonaLibrary() {
          personaLibraryModal.classList.remove("visible");
        }

        function renderPersonaLibrary() {
          const grid = document.getElementById("persona-library-grid");
          grid.innerHTML = "";
          if (state.personaPresets.length === 0) {
            grid.innerHTML =
              '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>';
            return;
          }
          state.personaPresets.forEach((preset) => {
            const item = document.createElement("div");
            item.className = "persona-preset-item";
            item.style.backgroundImage = `url(${preset.avatar})`;
            item.dataset.presetId = preset.id;
            item.addEventListener("click", () => applyPersonaPreset(preset.id));
            addLongPressListener(item, () => showPresetActions(preset.id));
            grid.appendChild(item);
          });
        }

        function showPresetActions(presetId) {
          editingPersonaPresetId = presetId;
          presetActionsModal.classList.add("visible");
        }

        function hidePresetActions() {
          presetActionsModal.classList.remove("visible");
          editingPersonaPresetId = null;
        }

        function applyPersonaPreset(presetId) {
          const preset = state.personaPresets.find((p) => p.id === presetId);
          if (preset) {
            document.getElementById("my-avatar-preview").src = preset.avatar;
            document.getElementById("my-persona").value = preset.persona;
          }
          closePersonaLibrary();
        }

        function openPersonaEditorForCreate() {
          editingPersonaPresetId = null;
          document.getElementById("persona-editor-title").textContent =
            "添加人设预设";
          document.getElementById("preset-avatar-preview").src = defaultAvatar;
          document.getElementById("preset-persona-input").value = "";
          personaEditorModal.classList.add("visible");
        }

        function openPersonaEditorForEdit() {
          const preset = state.personaPresets.find(
            (p) => p.id === editingPersonaPresetId,
          );
          if (!preset) return;
          document.getElementById("persona-editor-title").textContent =
            "编辑人设预设";
          document.getElementById("preset-avatar-preview").src = preset.avatar;
          document.getElementById("preset-persona-input").value =
            preset.persona;
          presetActionsModal.classList.remove("visible");
          personaEditorModal.classList.add("visible");
        }

        async function deletePersonaPreset() {
          const confirmed = await showCustomConfirm(
            "删除预设",
            "确定要删除这个人设预设吗？此操作不可恢复。",
            { confirmButtonClass: "btn-danger" },
          );
          if (confirmed && editingPersonaPresetId) {
            await db.personaPresets.delete(editingPersonaPresetId);
            state.personaPresets = state.personaPresets.filter(
              (p) => p.id !== editingPersonaPresetId,
            );
            hidePresetActions();
            renderPersonaLibrary();
          }
        }

        function closePersonaEditor() {
          personaEditorModal.classList.remove("visible");
          editingPersonaPresetId = null;
        }

        async function savePersonaPreset() {
          const avatar = document.getElementById("preset-avatar-preview").src;
          const persona = document
            .getElementById("preset-persona-input")
            .value.trim();
          if (avatar === defaultAvatar && !persona) {
            alert("头像和人设不能都为空哦！");
            return;
          }
          if (editingPersonaPresetId) {
            const preset = state.personaPresets.find(
              (p) => p.id === editingPersonaPresetId,
            );
            if (preset) {
              preset.avatar = avatar;
              preset.persona = persona;
              await db.personaPresets.put(preset);
            }
          } else {
            const newPreset = {
              id: "preset_" + Date.now(),
              avatar: avatar,
              persona: persona,
            };
            await db.personaPresets.add(newPreset);
            state.personaPresets.push(newPreset);
          }
          renderPersonaLibrary();
          closePersonaEditor();
        }

        const batteryAlertModal = document.getElementById(
          "battery-alert-modal",
        );

        function showBatteryAlert(imageUrl, text) {
          clearTimeout(batteryAlertTimeout);
          document.getElementById("battery-alert-image").src = imageUrl;
          document.getElementById("battery-alert-text").textContent = text;
          batteryAlertModal.classList.add("visible");
          const closeAlert = () => {
            batteryAlertModal.classList.remove("visible");
            batteryAlertModal.removeEventListener("click", closeAlert);
          };
          batteryAlertModal.addEventListener("click", closeAlert);
          batteryAlertTimeout = setTimeout(closeAlert, 2000);
        }

        function updateBatteryDisplay(battery) {
          const batteryContainer =
            document.getElementById("status-bar-battery");
          const batteryLevelEl =
            batteryContainer.querySelector(".battery-level");
          const batteryTextEl = batteryContainer.querySelector(".battery-text");
          const level = Math.floor(battery.level * 100);
          batteryLevelEl.style.width = `${level}%`;
          batteryTextEl.textContent = `${level}%`;
          if (battery.charging) {
            batteryContainer.classList.add("charging");
          } else {
            batteryContainer.classList.remove("charging");
          }
        }

        function handleBatteryChange(battery) {
          updateBatteryDisplay(battery);
          const level = battery.level;
          if (!battery.charging) {
            if (
              level <= 0.4 &&
              lastKnownBatteryLevel > 0.4 &&
              !alertFlags.hasShown40
            ) {
              showBatteryAlert(
                "https://i.postimg.cc/T2yKJ0DV/40.jpg",
                "有点饿了，可以去找充电器惹",
              );
              alertFlags.hasShown40 = true;
            }
            if (
              level <= 0.2 &&
              lastKnownBatteryLevel > 0.2 &&
              !alertFlags.hasShown20
            ) {
              showBatteryAlert(
                "https://i.postimg.cc/qB9zbKs9/20.jpg",
                "赶紧的充电，要饿死了",
              );
              alertFlags.hasShown20 = true;
            }
            if (
              level <= 0.1 &&
              lastKnownBatteryLevel > 0.1 &&
              !alertFlags.hasShown10
            ) {
              showBatteryAlert(
                "https://i.postimg.cc/ThMMVfW4/10.jpg",
                "已阵亡，还有30秒爆炸",
              );
              alertFlags.hasShown10 = true;
            }
          }
          if (level > 0.4) alertFlags.hasShown40 = false;
          if (level > 0.2) alertFlags.hasShown20 = false;
          if (level > 0.1) alertFlags.hasShown10 = false;
          lastKnownBatteryLevel = level;
        }

        async function initBatteryManager() {
          if ("getBattery" in navigator) {
            try {
              const battery = await navigator.getBattery();
              lastKnownBatteryLevel = battery.level;
              handleBatteryChange(battery);
              battery.addEventListener("levelchange", () =>
                handleBatteryChange(battery),
              );
              battery.addEventListener("chargingchange", () => {
                handleBatteryChange(battery);
                if (battery.charging) {
                  showBatteryAlert(
                    "https://i.postimg.cc/3NDQ0dWG/image.jpg",
                    "窝爱泥，电量吃饱饱",
                  );
                }
              });
            } catch (err) {
              console.error("无法获取电池信息:", err);
              document.querySelector(".battery-text").textContent = "ᗜωᗜ";
            }
          } else {
            console.log("浏览器不支持电池状态API。");
            document.querySelector(".battery-text").textContent = "ᗜωᗜ";
          }
        }

        async function renderAlbumList() {
          const albumGrid = document.getElementById("album-grid-page");
          if (!albumGrid) return;
          const albums = await db.qzoneAlbums
            .orderBy("createdAt")
            .reverse()
            .toArray();
          albumGrid.innerHTML = "";
          if (albums.length === 0) {
            albumGrid.innerHTML =
              '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
            return;
          }
          albums.forEach((album) => {
            const albumItem = document.createElement("div");
            albumItem.className = "album-item";
            albumItem.innerHTML = `
                          <div class="album-cover" style="background-image: url(${
                            album.coverUrl
                          });"></div>
                          <div class="album-info">
                              <p class="album-name">${album.name}</p>
                              <p class="album-count">${
                                album.photoCount || 0
                              } 张</p>
                          </div>
                      `;
            albumItem.addEventListener("click", () => {
              openAlbum(album.id);
            });

            addLongPressListener(albumItem, async () => {
              const confirmed = await showCustomConfirm(
                "删除相册",
                `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`,
                { confirmButtonClass: "btn-danger" },
              );

              if (confirmed) {
                // 1. 从照片表中删除该相册下的所有照片
                await db.qzonePhotos.where("albumId").equals(album.id).delete();

                // 2. 从相册表中删除该相册本身
                await db.qzoneAlbums.delete(album.id);

                // 3. 重新渲染相册列表
                await renderAlbumList();

                alert("相册已成功删除。");
              }
            });

            albumGrid.appendChild(albumItem);
          });
        }

        async function openAlbum(albumId) {
          state.activeAlbumId = albumId;
          await renderAlbumPhotosScreen();
          showScreen("album-photos-screen");
        }

        async function renderAlbumPhotosScreen() {
          if (!state.activeAlbumId) return;
          const photosGrid = document.getElementById("photos-grid-page");
          const headerTitle = document.getElementById("album-photos-title");
          const album = await db.qzoneAlbums.get(state.activeAlbumId);
          if (!album) {
            console.error("找不到相册:", state.activeAlbumId);
            showScreen("album-screen");
            return;
          }
          headerTitle.textContent = album.name;
          const photos = await db.qzonePhotos
            .where("albumId")
            .equals(state.activeAlbumId)
            .toArray();
          photosGrid.innerHTML = "";
          if (photos.length === 0) {
            photosGrid.innerHTML =
              '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">这个相册还是空的，快上传第一张照片吧！</p>';
          } else {
            photos.forEach((photo) => {
              const photoItem = document.createElement("div");
              photoItem.className = "photo-item";
              photoItem.innerHTML = `
                              <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                              <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                          `;
              photosGrid.appendChild(photoItem);
            });
          }
        }

        // --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

        /**
         * 打开图片查看器
         * @param {string} clickedPhotoUrl - 用户点击的那张照片的URL
         */
        async function openPhotoViewer(clickedPhotoUrl) {
          if (!state.activeAlbumId) return;

          // 1. 从数据库获取当前相册的所有照片
          const photosInAlbum = await db.qzonePhotos
            .where("albumId")
            .equals(state.activeAlbumId)
            .toArray();
          photoViewerState.photos = photosInAlbum.map((p) => p.url);

          // 2. 找到被点击照片的索引
          photoViewerState.currentIndex = photoViewerState.photos.findIndex(
            (url) => url === clickedPhotoUrl,
          );
          if (photoViewerState.currentIndex === -1) return; // 如果找不到，则不打开

          // 3. 显示模态框并渲染第一张图
          document
            .getElementById("photo-viewer-modal")
            .classList.add("visible");
          renderPhotoViewer();
          photoViewerState.isOpen = true;
        }

        /**
         * 根据当前状态渲染查看器内容（图片和按钮）
         */
        function renderPhotoViewer() {
          if (photoViewerState.currentIndex === -1) return;

          const imageEl = document.getElementById("photo-viewer-image");
          const prevBtn = document.getElementById("photo-viewer-prev-btn");
          const nextBtn = document.getElementById("photo-viewer-next-btn");

          // 淡出效果
          imageEl.style.opacity = 0;

          setTimeout(() => {
            // 更新图片源
            imageEl.src =
              photoViewerState.photos[photoViewerState.currentIndex];
            // 淡入效果
            imageEl.style.opacity = 1;
          }, 100); // 延迟一点点时间来触发CSS过渡

          // 更新按钮状态：如果是第一张，禁用“上一张”按钮
          prevBtn.disabled = photoViewerState.currentIndex === 0;
          // 如果是最后一张，禁用“下一张”按钮
          nextBtn.disabled =
            photoViewerState.currentIndex ===
            photoViewerState.photos.length - 1;
        }

        /**
         * 显示下一张照片
         */
        function showNextPhoto() {
          if (
            photoViewerState.currentIndex <
            photoViewerState.photos.length - 1
          ) {
            photoViewerState.currentIndex++;
            renderPhotoViewer();
          }
        }

        /**
         * 显示上一张照片
         */
        function showPrevPhoto() {
          if (photoViewerState.currentIndex > 0) {
            photoViewerState.currentIndex--;
            renderPhotoViewer();
          }
        }

        /**
         * 关闭图片查看器
         */
        function closePhotoViewer() {
          document
            .getElementById("photo-viewer-modal")
            .classList.remove("visible");
          photoViewerState.isOpen = false;
          photoViewerState.photos = [];
          photoViewerState.currentIndex = -1;
          // 清空图片，避免下次打开时闪现旧图
          document.getElementById("photo-viewer-image").src = "";
        }

        // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

        /**
         * 更新动态小红点的显示
         * @param {number} count - 未读动态的数量
         */
        function updateUnreadIndicator(count) {
          unreadPostsCount = count;
          localStorage.setItem("unreadPostsCount", count); // 持久化存储

          // --- 更新底部导航栏的“动态”按钮 ---
          const navItem = document.querySelector(
            '.nav-item[data-view="qzone-screen"]',
          );

          const targetSpan = navItem.querySelector("span"); // 定位到文字 "动态"
          let indicator = navItem.querySelector(".unread-indicator");

          if (count > 0) {
            if (!indicator) {
              indicator = document.createElement("span");
              indicator.className = "unread-indicator";
              targetSpan.style.position = "relative"; // 把相对定位加在 span 上
              targetSpan.appendChild(indicator); // 把小红点作为 span 的子元素
            }
            indicator.textContent = count > 99 ? "99+" : count;
            indicator.style.display = "block";
          } else {
            if (indicator) {
              indicator.style.display = "none";
            }
          }

          // --- 更新聊天界面返回列表的按钮 ---
          const backBtn = document.getElementById("back-to-list-btn");
          let backBtnIndicator = backBtn.querySelector(".unread-indicator");

          if (count > 0) {
            if (!backBtnIndicator) {
              backBtnIndicator = document.createElement("span");
              backBtnIndicator.className =
                "unread-indicator back-btn-indicator";
              backBtn.style.position = "relative"; // 确保能正确定位
              backBtn.appendChild(backBtnIndicator);
            }
            // 返回键上的小红点通常不显示数字，只显示一个点
            backBtnIndicator.style.display = "block";
          } else {
            if (backBtnIndicator) {
              backBtnIndicator.style.display = "none";
            }
          }
        }

        function startBackgroundSimulation() {
          if (simulationIntervalId) return;
          const intervalSeconds =
            state.globalSettings.backgroundActivityInterval || 60;
          // 将旧的固定间隔 45000 替换为动态获取
          simulationIntervalId = setInterval(
            runBackgroundSimulationTick,
            intervalSeconds * 1000,
          );
        }

        function stopBackgroundSimulation() {
          if (simulationIntervalId) {
            clearInterval(simulationIntervalId);
            simulationIntervalId = null;
          }
        }

        /**
         * 这是模拟器的“心跳”，每次定时器触发时运行
         */
        function runBackgroundSimulationTick() {
          console.log("模拟器心跳 Tick...");
          if (!state.globalSettings.enableBackgroundActivity) {
            stopBackgroundSimulation();
            return;
          }
          const allSingleChats = Object.values(state.chats).filter(
            (chat) => !chat.isGroup,
          );

          if (allSingleChats.length === 0) return;

          allSingleChats.forEach((chat) => {
            // 【核心修正】将两种状态检查分离开，逻辑更清晰

            // 检查1：处理【被用户拉黑】的角色
            if (chat.relationship?.status === "blocked_by_user") {
              const blockedTimestamp = chat.relationship.blockedTimestamp;
              // 安全检查：确保有拉黑时间戳
              if (!blockedTimestamp) {
                console.warn(
                  `角色 "${chat.name}" 状态为拉黑，但缺少拉黑时间戳，跳过处理。`,
                );
                return; // 跳过这个角色，继续下一个
              }

              const blockedDuration = Date.now() - blockedTimestamp;
              const cooldownMilliseconds =
                (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;

              console.log(
                `检查角色 "${chat.name}"：已拉黑 ${Math.round(
                  blockedDuration / 1000 / 60,
                )}分钟，冷静期需 ${cooldownMilliseconds / 1000 / 60}分钟。`,
              ); // 添加日志

              // 【核心修改】移除了随机概率，只要冷静期一过，就触发！
              if (blockedDuration > cooldownMilliseconds) {
                console.log(
                  `角色 "${chat.name}" 的冷静期已过，触发“反思”并申请好友事件...`,
                );

                // 【重要】为了防止在AI响应前重复触发，我们在触发后立刻更新状态
                chat.relationship.status = "pending_system_reflection"; // 设置一个临时的、防止重复触发的状态

                triggerAiFriendApplication(chat.id);
              }
            }
            // 检查2：处理【好友关系】的正常后台活动
            else if (
              chat.relationship?.status === "friend" &&
              chat.id !== state.activeChatId
            ) {
              if (!hasAnyBackgroundActivityEnabled(chat)) {
                return;
              }
              // 这里的随机触发逻辑保持不变，因为我们不希望所有好友同时行动
              if (Math.random() < 0.2) {
                console.log(`角色 "${chat.name}" 被唤醒，准备独立行动...`);
                triggerInactiveAiAction(chat.id);
              }
            }
          });
        }

        async function triggerInactiveAiAction(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return;

          const activityOptions = getBackgroundActivityOptions(chat);
          const allowChat = activityOptions.allowChat;
          const allowPost = activityOptions.allowPost;
          const allowReply = activityOptions.allowReply;
          if (!allowChat && !allowPost && !allowReply) return;

          const { proxyUrl, apiKey, model } = getActiveApiConfig() || {};
          if (!proxyUrl || !apiKey || !model) return;

          // 强制转换为北京时间
          const localNow = new Date();
          const utcMilliseconds =
            localNow.getTime() + localNow.getTimezoneOffset() * 60000;
          const beijingMilliseconds = utcMilliseconds + 3600000 * 8;
          const now = new Date(beijingMilliseconds);
          const currentTime = now.toLocaleTimeString("zh-CN", {
            hour: "numeric",
            minute: "numeric",
            hour12: true,
          });
          const userNickname = state.qzoneSettings.nickname;

          const lastUserMessage = chat.history
            .filter((m) => m.role === "user" && !m.isHidden)
            .slice(-1)[0];
          const lastAiMessage = chat.history
            .filter((m) => m.role === "assistant" && !m.isHidden)
            .slice(-1)[0];
          let recentContextSummary = "你们最近没有聊过天。";
          if (lastUserMessage) {
            recentContextSummary = `用户 (${userNickname}) 最后对你说：“${String(
              lastUserMessage.content,
            ).substring(0, 50)}...”。`;
          }
          if (lastAiMessage) {
            recentContextSummary += `\n你最后对用户说：“${String(
              lastAiMessage.content,
            ).substring(0, 50)}...”。`;
          }

          let worldBookContent = "";
          if (
            chat.settings.linkedWorldBookIds &&
            chat.settings.linkedWorldBookIds.length > 0
          ) {
            const linkedContents = chat.settings.linkedWorldBookIds
              .map((bookId) => {
                const worldBook = state.worldBooks.find(
                  (wb) => wb.id === bookId,
                );
                return worldBook && worldBook.content
                  ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}`
                  : "";
              })
              .filter(Boolean)
              .join("");
            if (linkedContents) {
              worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
            }
          }

          const allowedActions = [];
          if (allowChat)
            allowedActions.push(
              "1.  **发送消息**: 向用户发送一条正常聊天内容。",
            );
          if (allowPost)
            allowedActions.push(
              "2.  **发布动态**: 发布说说或动态内容。",
            );
          if (allowReply)
            allowedActions.push(
              "3.  **回复动态**: 对动态进行评论。",
            );

          const formatInstructions = [];
          if (allowChat) {
            formatInstructions.push(
              "-   **发消息**: `[{\"type\": \"text\", \"content\": \"你想对用户说的话...\"}]`",
            );
            formatInstructions.push(
              "-   **发消息+更新状态**: `[{\"type\": \"update_status\", \"status_text\": \"正在做的事\", \"is_busy\": true}, {\"type\": \"text\", \"content\": \"你想对用户说的话...\"}]`",
            );
          }
          if (allowPost) {
            formatInstructions.push(
              "-   **发说说**: `[{\"type\": \"qzone_post\", \"postType\": \"shuoshuo\", \"content\": \"动态的文字内容...\"}]`",
            );
            formatInstructions.push(
              "-   **发布文字图**: `[{\"type\": \"qzone_post\", \"postType\": \"text_image\", \"publicText\": \"(可选)动态的公开文字\", \"hiddenContent\": \"对于图片的具体描述...\"}]`",
            );
          }
          if (allowReply) {
            formatInstructions.push(
              "-   **评论**: `[{\"type\": \"qzone_comment\", \"postId\": 123, \"commentText\": \"你的评论内容\"}]`",
            );
          }

          const dynamicListNotice = allowReply
            ? "-   **【重要】最近的动态列表**: 这个列表会标注 **[你已评论]**。请**优先**与你**尚未互动过**的动态进行交流。"
            : "";

          const systemPrompt = `
      # 你的任务
      你现在扮演一个名为"${chat.name}"的角色。你已经有一段时间没有和用户（${userNickname}）互动了，现在你有机会【主动】做点什么，来表现你的个性和独立生活。这是一个秘密的、后台的独立行动。

      # 你的可选行动 (请根据你的人设【选择一项】执行):
      ${allowedActions.join("\n      ")}

      # 指令格式 (你的回复【必须】是包含一个对象的JSON数组):
      ${formatInstructions.join("\n      ")}

      # 供你决策的参考信息：
      -   **你的角色设定**: ${chat.settings.aiPersona}
      ${worldBookContent} // <--【核心】在这里注入世界书内容
      -   **当前时间**: ${currentTime}
      -   **你们最后的对话摘要**: ${recentContextSummary}
      ${dynamicListNotice}`;

          // 【核心修复】在这里构建 messagesPayload
          const messagesPayload = [];
          messagesPayload.push({ role: "system", content: systemPrompt });

          try {
            let dynamicContext = "";
            if (allowReply) {
              const allRecentPosts = await db.qzonePosts
                .orderBy("timestamp")
                .reverse()
                .limit(3)
                .toArray();
              // 【核心修改】在这里插入过滤步骤
              const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

              const aiName = chat.name;

              if (visiblePosts.length > 0) {
                let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
                for (const post of visiblePosts) {
                  let authorName =
                    post.authorId === "user"
                      ? userNickname
                      : state.chats[post.authorId]?.name || "一位朋友";
                  let interactionStatus = "";
                  if (
                    post.comments &&
                    post.comments.some((c) => c.commenterName === aiName)
                  )
                    interactionStatus += " [你已评论]";

                  postsContext += `- (ID: ${
                    post.id
                  }) 作者: ${authorName}, 内容: "${(
                    post.publicText ||
                    post.content ||
                    "图片动态"
                  ).substring(0, 30)}..."${interactionStatus}\n`;
                }
                dynamicContext = postsContext;
              }
            }

            // 【核心修复】将所有动态信息作为一条 user 消息发送
            messagesPayload.push({
              role: "user",
              content: `[系统指令：请根据你在 system prompt 中读到的规则和以下最新信息，开始你的独立行动。]\n${dynamicContext}`,
            });

            console.log(
              "正在为后台活动发送API请求，Payload:",
              JSON.stringify(messagesPayload, null, 2),
            ); // 添加日志，方便调试

            // 发送请求
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesPayload,
              isGemini,
            );
            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: 0.9,
                  }),
                });

            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(
                `API请求失败: ${response.status} - ${JSON.stringify(errorData)}`,
              );
            }
            const data = await response.json();
            // 检查是否有有效回复
            if (
              !data.choices ||
              data.choices.length === 0 ||
              !data.choices[0].message.content
            ) {
              console.warn(
                `API为空回或格式不正确，角色 "${chat.name}" 的本次后台活动跳过。`,
              );
              return;
            }
            const responseArray = parseAiResponse(
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content,
            );

            // 后续处理AI返回指令的逻辑保持不变...
            for (const action of responseArray) {
              if (!action) continue;

              if (
                (action.type === "text" || action.type === "update_status") &&
                !allowChat
              ) {
                continue;
              }
              if (action.type === "qzone_post" && !allowPost) {
                continue;
              }
              if (action.type === "qzone_comment" && !allowReply) {
                continue;
              }
              if (action.type === "qzone_like") {
                continue;
              }
              if (action.type === "video_call_request") {
                continue;
              }

              if (action.type === "update_status" && action.status_text) {
                chat.status.text = action.status_text;
                chat.status.isBusy = action.is_busy || false;
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
                renderChatList();
              }
              if (action.type === "text" && action.content) {
                const aiMessage = {
                  role: "assistant",
                  content: String(action.content).trim(),
                  timestamp: Date.now(),
                };

                chat.unreadCount = (chat.unreadCount || 0) + 1;
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showNotification(chatId, aiMessage.content);
                renderChatList();
                console.log(
                  `后台活动: 角色 "${chat.name}" 主动发送了消息: ${aiMessage.content}`,
                );
              }
              if (action.type === "qzone_post") {
                const newPost = {
                  type: action.postType,
                  content: String(action.content || "").trim(),
                  publicText: String(action.publicText || "").trim(),
                  hiddenContent: String(action.hiddenContent || "").trim(),
                  timestamp: Date.now(),
                  authorId: chatId,
                  authorGroupId: chat.groupId, // 【核心新增】记录作者的分组ID
                  visibleGroupIds: null,
                };
                await db.qzonePosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`后台活动: 角色 "${chat.name}" 发布了动态`);
              } else if (action.type === "qzone_comment") {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                  if (!post.comments) post.comments = [];
                  post.comments.push({
                    commenterName: chat.name,
                    text: String(action.commentText || "").trim(),
                    timestamp: Date.now(),
                  });
                  await db.qzonePosts.update(post.id, {
                    comments: post.comments,
                  });
                  updateUnreadIndicator(unreadPostsCount + 1);
                  console.log(
                    `后台活动: 角色 "${chat.name}" 评论了动态 #${post.id}`,
                  );
                }
              } else if (action.type === "qzone_like") {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                  if (!post.likes) post.likes = [];
                  if (!post.likes.includes(chat.name)) {
                    post.likes.push(chat.name);
                    await db.qzonePosts.update(post.id, { likes: post.likes });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    console.log(
                      `后台活动: 角色 "${chat.name}" 点赞了动态 #${post.id}`,
                    );
                  }
                }
              } else if (action.type === "video_call_request") {
                if (
                  !videoCallState.isActive &&
                  !videoCallState.isAwaitingResponse
                ) {
                  videoCallState.isAwaitingResponse = true;
                  state.activeChatId = chatId;
                  showIncomingCallModal();
                  console.log(
                    `后台活动: 角色 "${chat.name}" 发起了视频通话请求`,
                  );
                }
              }
            }
          } catch (error) {
            console.error(`角色 "${chat.name}" 的独立行动失败:`, error);
          }
        }

        /**
         * 将用户自定义的CSS安全地应用到指定的作用域
         * @param {string} cssString 用户输入的原始CSS字符串
         * @param {string} scopeId 应用样式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
         * @param {string} styleTagId 要操作的 <style> 标签的ID
         */
        function applyScopedCss(cssString, scopeId, styleTagId) {
          const styleTag = document.getElementById(styleTagId);
          if (!styleTag) return;

          if (!cssString || cssString.trim() === "") {
            styleTag.innerHTML = "";
            return;
          }

          // 增强作用域处理函数 - 专门解决.user和.ai样式冲突问题
          const scopedCss = cssString
            .replace(
              /\s*\.message-bubble\.user\s+([^{]+\{)/g,
              `${scopeId} .message-bubble.user $1`,
            )
            .replace(
              /\s*\.message-bubble\.ai\s+([^{]+\{)/g,
              `${scopeId} .message-bubble.ai $1`,
            )
            .replace(
              /\s*\.message-bubble\s+([^{]+\{)/g,
              `${scopeId} .message-bubble $1`,
            );

          styleTag.innerHTML = scopedCss;
        }

        function updateSettingsPreview() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          const previewArea = document.getElementById("settings-preview-area");
          if (!previewArea) return;

          // 1. 获取当前设置的值
          const selectedTheme =
            document.querySelector('input[name="theme-select"]:checked')
              ?.value || "default";
          const fontSize = document.getElementById("font-size-slider").value;
          const customCss = document.getElementById("custom-css-input").value;
          const background = chat.settings.background; // 直接获取背景设置

          // 2. 更新预览区的基本样式
          previewArea.dataset.theme = selectedTheme;
          previewArea.style.setProperty("--chat-font-size", `${fontSize}px`);

          // --- 【核心修正】直接更新预览区的背景样式 ---
          if (background && background.startsWith("data:image")) {
            previewArea.style.backgroundImage = `url(${background})`;
            previewArea.style.backgroundColor = "transparent"; // 如果有图片，背景色设为透明
          } else {
            previewArea.style.backgroundImage = "none"; // 如果没有图片，移除图片背景
            // 如果背景是颜色值或渐变（非图片），则直接应用
            previewArea.style.background = background || "#f0f2f5";
          }

          // 3. 渲染模拟气泡
          previewArea.innerHTML = "";

          // 创建“对方”的气泡
          // 注意：我们将一个虚拟的 timestamp 传入，以防有CSS依赖于它
          const aiMsg = {
            role: "ai",
            content: "对方消息预览",
            timestamp: 1,
            senderName: chat.name,
          };
          const aiBubble = createMessageElement(aiMsg, chat);
          if (aiBubble) previewArea.appendChild(aiBubble);

          // 创建“我”的气泡
          const userMsg = {
            role: "user",
            content: "我的消息预览",
            timestamp: 2,
          };
          const userBubble = createMessageElement(userMsg, chat);
          if (userBubble) previewArea.appendChild(userBubble);

          // 4. 应用自定义CSS到预览区
          applyScopedCss(
            customCss,
            "#settings-preview-area",
            "preview-bubble-style",
          );
        }

        async function openGroupManager() {
          await renderGroupList();
          document
            .getElementById("group-management-modal")
            .classList.add("visible");
        }

        async function renderGroupList() {
          const listEl = document.getElementById("existing-groups-list");
          const groups = await db.qzoneGroups.toArray();
          listEl.innerHTML = "";
          if (groups.length === 0) {
            listEl.innerHTML =
              '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
          }
          groups.forEach((group) => {
            const item = document.createElement("div");
            item.className = "existing-group-item";
            item.innerHTML = `
                  <span class="group-name">${group.name}</span>
                  <span class="delete-group-btn" data-id="${group.id}">×</span>
              `;
            listEl.appendChild(item);
          });
        }

        async function addNewGroup() {
          const input = document.getElementById("new-group-name-input");
          const name = input.value.trim();
          if (!name) {
            alert("分组名不能为空！");
            return;
          }

          // 【核心修正】在添加前，先检查分组名是否已存在
          const existingGroup = await db.qzoneGroups
            .where("name")
            .equals(name)
            .first();
          if (existingGroup) {
            alert(`分组 "${name}" 已经存在了，换个名字吧！`);
            return;
          }
          // 【修正结束】

          await db.qzoneGroups.add({ name });
          input.value = "";
          await renderGroupList();
        }

        async function deleteGroup(groupId) {
          const confirmed = await showCustomConfirm(
            "确认删除",
            "删除分组后，该组内的好友将变为“未分组”。确定要删除吗？",
            { confirmButtonClass: "btn-danger" },
          );
          if (confirmed) {
            await db.qzoneGroups.delete(groupId);
            // 将属于该分组的好友的 groupId 设为 null
            const chatsToUpdate = await db.chats
              .where("groupId")
              .equals(groupId)
              .toArray();
            for (const chat of chatsToUpdate) {
              chat.groupId = null;
              await db.chats.put(chat);
              if (state.chats[chat.id]) state.chats[chat.id].groupId = null;
            }
            await renderGroupList();
          }
        }

        /**
         * 当长按消息时，显示操作菜单
         * @param {number} timestamp - 被长按消息的时间戳
         */
        function showMessageActions(timestamp) {
          // 如果已经在多选模式，则不弹出菜单
          if (isSelectionMode) return;

          activeMessageTimestamp = timestamp;
          document
            .getElementById("message-actions-modal")
            .classList.add("visible");
        }

        /**
         * 隐藏消息操作菜单
         */
        function hideMessageActions() {
          document
            .getElementById("message-actions-modal")
            .classList.remove("visible");
          activeMessageTimestamp = null;
        }

        async function openMessageEditor() {
          if (!activeMessageTimestamp) return;

          const timestampToEdit = activeMessageTimestamp;
          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === timestampToEdit,
          );
          if (!message) return;

          hideMessageActions();

          let contentForEditing;
          // 【核心修正】将 share_link 也加入特殊类型判断
          const isSpecialType =
            message.type &&
            ["voice_message", "ai_image", "transfer", "share_link"].includes(
              message.type,
            );

          if (isSpecialType) {
            let fullMessageObject = { type: message.type };
            if (message.type === "voice_message")
              fullMessageObject.content = message.content;
            else if (message.type === "ai_image")
              fullMessageObject.description = message.content;
            else if (message.type === "transfer") {
              fullMessageObject.amount = message.amount;
              fullMessageObject.note = message.note;
            }
            // 【核心修正】处理分享链接类型的消息
            else if (message.type === "share_link") {
              fullMessageObject.title = message.title;
              fullMessageObject.description = message.description;
              fullMessageObject.source_name = message.source_name;
              fullMessageObject.content = message.content;
            }
            contentForEditing = JSON.stringify(fullMessageObject, null, 2);
          } else if (typeof message.content === "object") {
            contentForEditing = JSON.stringify(message.content, null, 2);
          } else {
            contentForEditing = message.content;
          }

          // 【核心修改1】在这里添加 'link' 模板
          const templates = {
            voice: { type: "voice_message", content: "在这里输入语音内容" },
            image: { type: "ai_image", description: "在这里输入图片描述" },
            transfer: { type: "transfer", amount: 5.2, note: "一点心意" },
            link: {
              type: "share_link",
              title: "文章标题",
              description: "文章摘要...",
              source_name: "来源网站",
              content: "文章完整内容...",
            },
          };

          // 【核心修改2】在这里添加新的“链接”按钮
          const helpersHtml = `
              <div class="format-helpers">
                  <button class="format-btn" data-template='${JSON.stringify(
                    templates.voice,
                  )}'>语音</button>
                  <button class="format-btn" data-template='${JSON.stringify(
                    templates.image,
                  )}'>图片</button>
                  <button class="format-btn" data-template='${JSON.stringify(
                    templates.transfer,
                  )}'>转账</button>
                  <button class="format-btn" data-template='${JSON.stringify(
                    templates.link,
                  )}'>链接</button>
              </div>
          `;

          const newContent = await showCustomPrompt(
            "编辑消息",
            "在此修改，或点击上方按钮使用格式模板...",
            contentForEditing,
            "textarea",
            helpersHtml,
          );

          if (newContent !== null) {
            // 【核心修正】这里调用的应该是 saveEditedMessage，而不是 saveAdvancedEditor
            await saveEditedMessage(timestampToEdit, newContent, true);
          }
        }

        /**
         * 复制消息的文本内容到剪贴板
         */
        async function copyMessageContent() {
          if (!activeMessageTimestamp) return;
          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === activeMessageTimestamp,
          );
          if (!message) return;

          let textToCopy;
          if (typeof message.content === "object") {
            textToCopy = JSON.stringify(message.content);
          } else {
            textToCopy = String(message.content);
          }

          try {
            await navigator.clipboard.writeText(textToCopy);
            await showCustomAlert("复制成功", "消息内容已复制到剪贴板。");
          } catch (err) {
            await showCustomAlert("复制失败", "无法访问剪贴板。");
          }

          hideMessageActions();
        }

        /**
         * 创建一个可编辑的消息块（包含文本框、格式助手和删除按钮）
         * @param {string} initialContent - 文本框的初始内容
         * @returns {HTMLElement} - 创建好的DOM元素
         */
        function createMessageEditorBlock(initialContent = "") {
          const block = document.createElement("div");
          block.className = "message-editor-block";

          // 【核心修改1】在这里添加 'link' 模板
          const templates = {
            voice: { type: "voice_message", content: "在这里输入语音内容" },
            image: { type: "ai_image", description: "在这里输入图片描述" },
            transfer: { type: "transfer", amount: 5.2, note: "一点心意" },
            link: {
              type: "share_link",
              title: "文章标题",
              description: "文章摘要...",
              source_name: "来源网站",
              content: "文章完整内容...",
            },
          };

          block.innerHTML = `
              <button class="delete-block-btn" title="删除此条">×</button>
              <textarea>${initialContent}</textarea>
              <div class="format-helpers">
                  <button class="format-btn" data-template='${JSON.stringify(
                    templates.voice,
                  )}'>语音</button>
                  <button class="format-btn" data-template='${JSON.stringify(
                    templates.image,
                  )}'>图片</button>
                  <button class="format-btn" data-template='${JSON.stringify(
                    templates.transfer,
                  )}'>转账</button>
                  <!-- 【核心修改2】在这里添加新的“链接”按钮 -->
                  <button class="format-btn" data-template='${JSON.stringify(
                    templates.link,
                  )}'>链接</button>
              </div>
          `;

          // 绑定删除按钮事件
          block
            .querySelector(".delete-block-btn")
            .addEventListener("click", () => {
              // 确保至少保留一个编辑块
              if (
                document.querySelectorAll(".message-editor-block").length > 1
              ) {
                block.remove();
              } else {
                alert("至少需要保留一条消息。");
              }
            });

          // 绑定格式助手按钮事件
          block.querySelectorAll(".format-btn").forEach((btn) => {
            btn.addEventListener("click", () => {
              const templateStr = btn.dataset.template;
              const textarea = block.querySelector("textarea");
              if (templateStr && textarea) {
                try {
                  const templateObj = JSON.parse(templateStr);
                  textarea.value = JSON.stringify(templateObj, null, 2);
                  textarea.focus();
                } catch (e) {
                  console.error("解析格式模板失败:", e);
                }
              }
            });
          });

          return block;
        }

        /**
         * 打开全新的、可视化的多消息编辑器，并动态绑定其所有按钮事件
         */
        function openAdvancedMessageEditor() {
          if (!activeMessageTimestamp) return;

          // 1. 【核心】在关闭旧菜单前，将需要的时间戳捕获到局部变量中
          const timestampToEdit = activeMessageTimestamp;

          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === timestampToEdit,
          );
          if (!message) return;

          // 2. 现在可以安全地关闭旧菜单了，因为它不会影响我们的局部变量
          hideMessageActions();

          const editorModal = document.getElementById("message-editor-modal");
          const editorContainer = document.getElementById(
            "message-editor-container",
          );
          editorContainer.innerHTML = "";

          // 3. 准备初始内容
          let initialContent;
          const isSpecialType =
            message.type &&
            ["voice_message", "ai_image", "transfer"].includes(message.type);
          if (isSpecialType) {
            let fullMessageObject = { type: message.type };
            if (message.type === "voice_message")
              fullMessageObject.content = message.content;
            else if (message.type === "ai_image")
              fullMessageObject.description = message.content;
            else if (message.type === "transfer") {
              fullMessageObject.amount = message.amount;
              fullMessageObject.note = message.note;
            }
            initialContent = JSON.stringify(fullMessageObject, null, 2);
          } else if (typeof message.content === "object") {
            initialContent = JSON.stringify(message.content, null, 2);
          } else {
            initialContent = message.content;
          }

          const firstBlock = createMessageEditorBlock(initialContent);
          editorContainer.appendChild(firstBlock);

          // 4. 【核心】动态绑定所有控制按钮的事件
          // 为了防止事件重复绑定，我们使用克隆节点的方法来清除旧监听器
          const addBtn = document.getElementById(
            "add-message-editor-block-btn",
          );
          const newAddBtn = addBtn.cloneNode(true);
          addBtn.parentNode.replaceChild(newAddBtn, addBtn);
          newAddBtn.addEventListener("click", () => {
            const newBlock = createMessageEditorBlock();
            editorContainer.appendChild(newBlock);
            newBlock.querySelector("textarea").focus();
          });

          const cancelBtn = document.getElementById(
            "cancel-advanced-editor-btn",
          );
          const newCancelBtn = cancelBtn.cloneNode(true);
          cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
          newCancelBtn.addEventListener("click", () => {
            editorModal.classList.remove("visible");
          });

          const saveBtn = document.getElementById("save-advanced-editor-btn");
          const newSaveBtn = saveBtn.cloneNode(true);
          saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
          // 将捕获到的时间戳，直接绑定给这一次的保存点击事件
          newSaveBtn.addEventListener("click", () => {
            saveEditedMessage(timestampToEdit);
          });

          // 5. 最后，显示模态框
          editorModal.classList.add("visible");
        }

        /**
         * 解析编辑后的文本，并返回一个标准化的消息片段对象
         * @param {string} text - 用户在编辑框中输入的文本
         * @returns {object} - 一个包含 type, content, 等属性的对象
         */
        function parseEditedContent(text) {
          const trimmedText = text.trim();

          // 1. 尝试解析为JSON对象（用于修复语音、转账等格式）
          if (trimmedText.startsWith("{") && trimmedText.endsWith("}")) {
            try {
              const parsed = JSON.parse(trimmedText);
              // 必须包含 type 属性才认为是有效格式
              if (parsed.type) {
                return parsed;
              }
            } catch (e) {
              /* 解析失败，继续往下走 */
            }
          }

          // 2. 尝试解析为表情包
          if (STICKER_REGEX.test(trimmedText)) {
            // 对于编辑的表情，我们暂时无法知道其`meaning`，所以只存URL
            return { type: "sticker", content: trimmedText };
          }

          // 3. 否则，视为普通文本消息
          return { type: "text", content: trimmedText };
        }

        async function saveEditedMessage(timestamp, simpleContent = null) {
          if (!timestamp) return;

          const chat = state.chats[state.activeChatId];
          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === timestamp,
          );
          if (messageIndex === -1) return;

          let newMessages = [];

          // 判断是来自高级编辑器还是简单编辑器
          if (simpleContent !== null) {
            // --- 来自简单编辑器 ---
            const rawContent = simpleContent.trim();
            if (rawContent) {
              const parsedResult = parseEditedContent(rawContent);
              const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                // 注意：这里我们暂时不设置时间戳
                content: parsedResult.content || "",
              };
              if (parsedResult.type && parsedResult.type !== "text")
                newMessage.type = parsedResult.type;
              if (parsedResult.meaning)
                newMessage.meaning = parsedResult.meaning;
              if (parsedResult.amount) newMessage.amount = parsedResult.amount;
              if (parsedResult.note) newMessage.note = parsedResult.note;
              if (parsedResult.title) newMessage.title = parsedResult.title;
              if (parsedResult.description)
                newMessage.description = parsedResult.description;
              if (parsedResult.source_name)
                newMessage.source_name = parsedResult.source_name;
              if (
                parsedResult.description &&
                parsedResult.type === "ai_image"
              ) {
                newMessage.content = parsedResult.description;
              }

              newMessages.push(newMessage);
            }
          } else {
            // --- 来自高级编辑器 ---
            const editorContainer = document.getElementById(
              "message-editor-container",
            );
            const editorBlocks = editorContainer.querySelectorAll(
              ".message-editor-block",
            );

            for (const block of editorBlocks) {
              const textarea = block.querySelector("textarea");
              const rawContent = textarea.value.trim();
              if (!rawContent) continue;

              const parsedResult = parseEditedContent(rawContent);
              const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                // 同样，这里我们先不分配时间戳
                content: parsedResult.content || "",
              };

              if (parsedResult.type && parsedResult.type !== "text")
                newMessage.type = parsedResult.type;
              if (parsedResult.meaning)
                newMessage.meaning = parsedResult.meaning;
              if (parsedResult.amount) newMessage.amount = parsedResult.amount;
              if (parsedResult.note) newMessage.note = parsedResult.note;
              if (parsedResult.title) newMessage.title = parsedResult.title;
              if (parsedResult.description)
                newMessage.description = parsedResult.description;
              if (parsedResult.source_name)
                newMessage.source_name = parsedResult.source_name;
              if (
                parsedResult.description &&
                parsedResult.type === "ai_image"
              ) {
                newMessage.content = parsedResult.description;
              }

              newMessages.push(newMessage);
            }
          }

          if (newMessages.length === 0) {
            document
              .getElementById("message-editor-modal")
              .classList.remove("visible");
            return; // 如果是空消息，直接返回，不执行删除操作
          }

          // ★★★★★【核心修复逻辑就在这里】★★★★★

          // 1. 使用 splice 将旧消息替换为新消息（此时新消息还没有时间戳）
          chat.history.splice(messageIndex, 1, ...newMessages);

          // 2. 确定重新分配时间戳的起点
          // 我们从被编辑的消息的原始时间戳开始
          let reassignTimestamp = timestamp;

          // 3. 从被修改的位置开始，遍历所有后续的消息
          for (let i = messageIndex; i < chat.history.length; i++) {
            // 4. 为每一条消息（包括新插入的）分配一个新的、唯一的、连续的时间戳
            chat.history[i].timestamp = reassignTimestamp;

            // 5. 将时间戳+1，为下一条消息做准备
            reassignTimestamp++;
          }
          // ★★★★★【修复结束】★★★★★

          await db.chats.put(chat);

          // 关闭可能打开的模态框并刷新UI
          document
            .getElementById("message-editor-modal")
            .classList.remove("visible");
          renderChatInterface(state.activeChatId);
          await showCustomAlert("成功", "消息已更新！");
        }

        /**
         * 当点击“…”时，显示动态操作菜单
         * @param {number} postId - 被操作的动态的ID
         */
        function showPostActions(postId) {
          activePostId = postId;
          document
            .getElementById("post-actions-modal")
            .classList.add("visible");
        }

        /**
         * 隐藏动态操作菜单
         */
        function hidePostActions() {
          document
            .getElementById("post-actions-modal")
            .classList.remove("visible");
          activePostId = null;
        }

        /**
         * 打开动态编辑器
         */
        async function openPostEditor() {
          if (!activePostId) return;

          const postIdToEdit = activePostId;
          const post = await db.qzonePosts.get(postIdToEdit);
          if (!post) return;

          hidePostActions();

          // 忠于原文：构建出最原始的文本形态供编辑
          let contentForEditing;
          if (post.type === "shuoshuo") {
            contentForEditing = post.content;
          } else {
            // 对于图片和文字图，我们构建一个包含所有信息的对象
            const postObject = {
              type: post.type,
              publicText: post.publicText || "",
            };
            if (post.type === "image_post") {
              postObject.imageUrl = post.imageUrl;
              postObject.imageDescription = post.imageDescription;
            } else if (post.type === "text_image") {
              postObject.hiddenContent = post.hiddenContent;
            }
            contentForEditing = JSON.stringify(postObject, null, 2);
          }

          // 构建格式助手按钮
          const templates = {
            shuoshuo: "在这里输入说说的内容...", // 对于说说，我们直接替换为纯文本
            image: {
              type: "image_post",
              publicText: "",
              imageUrl: "https://...",
              imageDescription: "",
            },
            text_image: {
              type: "text_image",
              publicText: "",
              hiddenContent: "",
            },
          };

          const helpersHtml = `
              <div class="format-helpers">
                  <button class="format-btn" data-type="text">说说</button>
                  <button class="format-btn" data-template='${JSON.stringify(
                    templates.image,
                  )}'>图片动态</button>
                  <button class="format-btn" data-template='${JSON.stringify(
                    templates.text_image,
                  )}'>文字图</button>
              </div>
          `;

          const newContent = await showCustomPrompt(
            "编辑动态",
            "在此修改内容...",
            contentForEditing,
            "textarea",
            helpersHtml,
          );

          // 【特殊处理】为说说的格式助手按钮添加不同的行为
          // 我们需要在模态框出现后，再给它绑定事件
          setTimeout(() => {
            const shuoshuoBtn = document.querySelector(
              '#custom-modal-body .format-btn[data-type="text"]',
            );
            if (shuoshuoBtn) {
              shuoshuoBtn.addEventListener("click", () => {
                const input = document.getElementById("custom-prompt-input");
                input.value = templates.shuoshuo;
                input.focus();
              });
            }
          }, 100);

          if (newContent !== null) {
            await saveEditedPost(postIdToEdit, newContent);
          }
        }

        /**
         * 保存编辑后的动态
         * @param {number} postId - 要保存的动态ID
         * @param {string} newRawContent - 从编辑器获取的新内容
         */
        async function saveEditedPost(postId, newRawContent) {
          const post = await db.qzonePosts.get(postId);
          if (!post) return;

          const trimmedContent = newRawContent.trim();

          // 尝试解析为JSON，如果失败，则认为是纯文本（说说）
          try {
            const parsed = JSON.parse(trimmedContent);
            // 更新帖子属性
            post.type = parsed.type || "image_post";
            post.publicText = parsed.publicText || "";
            post.imageUrl = parsed.imageUrl || "";
            post.imageDescription = parsed.imageDescription || "";
            post.hiddenContent = parsed.hiddenContent || "";
            post.content = ""; // 清空旧的说说内容字段
          } catch (e) {
            // 解析失败，认为是说说
            post.type = "shuoshuo";
            post.content = trimmedContent;
            // 清空其他类型的字段
            post.publicText = "";
            post.imageUrl = "";
            post.imageDescription = "";
            post.hiddenContent = "";
          }

          await db.qzonePosts.put(post);
          await renderQzonePosts(); // 重新渲染列表
          await showCustomAlert("成功", "动态已更新！");
        }

        /**
         * 复制动态内容
         */
        async function copyPostContent() {
          if (!activePostId) return;
          const post = await db.qzonePosts.get(activePostId);
          if (!post) return;

          let textToCopy =
            post.content ||
            post.publicText ||
            post.hiddenContent ||
            post.imageDescription ||
            "（无文字内容）";

          try {
            await navigator.clipboard.writeText(textToCopy);
            await showCustomAlert("复制成功", "动态内容已复制到剪贴板。");
          } catch (err) {
            await showCustomAlert("复制失败", "无法访问剪贴板。");
          }

          hidePostActions();
        }

        let selectedContacts = new Set();

        async function openContactPickerForGroupCreate() {
          selectedContacts.clear(); // 清空上次选择

          // 【核心修复】在这里，我们为“完成”按钮明确绑定“创建群聊”的功能
          const confirmBtn = document.getElementById(
            "confirm-contact-picker-btn",
          );
          // 使用克隆节点技巧，清除掉之前可能绑定的任何其他事件（比如“添加成员”）
          const newConfirmBtn = confirmBtn.cloneNode(true);
          confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
          // 重新绑定正确的“创建群聊”函数
          newConfirmBtn.addEventListener("click", handleCreateGroup);

          await renderContactPicker();
          showScreen("contact-picker-screen");
        }

        /**
         * 渲染联系人选择列表
         */
        async function renderContactPicker() {
          const listEl = document.getElementById("contact-picker-list");
          listEl.innerHTML = "";

          // 只选择单聊角色作为群成员候选
          const contacts = Object.values(state.chats).filter(
            (chat) => !chat.isGroup,
          );

          if (contacts.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
            return;
          }

          contacts.forEach((contact) => {
            const item = document.createElement("div");
            item.className = "contact-picker-item";
            item.dataset.contactId = contact.id;
            item.innerHTML = `
                  <div class="checkbox"></div>
                  <img src="${
                    contact.settings.aiAvatar || defaultAvatar
                  }" class="avatar">
                  <span class="name">${contact.name}</span>
              `;
            listEl.appendChild(item);
          });

          updateContactPickerConfirmButton();
        }

        /**
         * 更新“完成”按钮的计数
         */
        function updateContactPickerConfirmButton() {
          const btn = document.getElementById("confirm-contact-picker-btn");
          btn.textContent = `完成(${selectedContacts.size})`;
          btn.disabled = selectedContacts.size < 2; // 至少需要2个人才能创建群聊
        }

        /**
         * 【重构版】处理创建群聊的最终逻辑
         */
        async function handleCreateGroup() {
          if (selectedContacts.size < 2) {
            alert("创建群聊至少需要选择2个联系人。");
            return;
          }

          const groupName = await showCustomPrompt(
            "设置群名",
            "请输入群聊的名字",
            "我们的群聊",
          );
          if (!groupName || !groupName.trim()) return;

          const newChatId = "group_" + Date.now();
          const members = [];

          // 遍历选中的联系人ID
          for (const contactId of selectedContacts) {
            const contactChat = state.chats[contactId];
            if (contactChat) {
              // ★★★【核心重构】★★★
              // 我们现在同时存储角色的“本名”和“群昵称”
              members.push({
                id: contactId,
                originalName: contactChat.name, // 角色的“本名”，用于AI识别
                groupNickname: contactChat.name, // 角色的“群昵称”，用于显示和修改，初始值和本名相同
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || "",
              });
            }
          }

          const newGroupChat = {
            id: newChatId,
            name: groupName.trim(),
            isGroup: true,
            members: members,
            settings: {
              myPersona: "我是谁呀。",
              myNickname: "我",
              maxMemory: 10,
              groupAvatar: defaultGroupAvatar,
              myAvatar: defaultMyGroupAvatar,
              background: "",
              theme: "default",
              fontSize: 13,
              customCss: "",
              linkedWorldBookIds: [],
            },
            history: [],
            musicData: { totalTime: 0 },
          };

          state.chats[newChatId] = newGroupChat;
          await db.chats.put(newGroupChat);

          await renderChatList();
          showScreen("chat-list-screen");
          openChat(newChatId);
        }

        /**
         * 打开群成员管理屏幕
         */
        function openMemberManagementScreen() {
          if (!state.activeChatId || !state.chats[state.activeChatId].isGroup)
            return;
          renderMemberManagementList();
          showScreen("member-management-screen");
        }

        function renderMemberManagementList() {
          const listEl = document.getElementById("member-management-list");
          const chat = state.chats[state.activeChatId];
          listEl.innerHTML = "";

          chat.members.forEach((member) => {
            const item = document.createElement("div");
            item.className = "member-management-item";
            // 【核心修正】在这里，我们将显示的名称从 member.name 改为 member.groupNickname
            item.innerHTML = `
                  <img src="${member.avatar}" class="avatar">
                  <span class="name">${member.groupNickname}</span>
                  <button class="remove-member-btn" data-member-id="${member.id}" title="移出群聊">-</button>
              `;
            listEl.appendChild(item);
          });
        }

        /**
         * 从群聊中移除一个成员
         * @param {string} memberId - 要移除的成员ID
         */
        async function removeMemberFromGroup(memberId) {
          const chat = state.chats[state.activeChatId];
          const memberIndex = chat.members.findIndex((m) => m.id === memberId);

          if (memberIndex === -1) return;

          // 安全检查，群聊至少保留2人
          if (chat.members.length <= 2) {
            alert("群聊人数不能少于2人。");
            return;
          }

          const memberName = chat.members[memberIndex].groupNickname; // <-- 修复：使用 groupNickname
          const confirmed = await showCustomConfirm(
            "移出成员",
            `确定要将“${memberName}”移出群聊吗？`,
            { confirmButtonClass: "btn-danger" },
          );

          if (confirmed) {
            chat.members.splice(memberIndex, 1);
            await db.chats.put(chat);
            renderMemberManagementList(); // 刷新成员管理列表
            document.getElementById("chat-settings-btn").click(); // 【核心修正】模拟点击设置按钮，强制刷新整个弹窗
          }
        }

        /**
         * 打开联系人选择器，用于拉人入群
         */
        async function openContactPickerForAddMember() {
          selectedContacts.clear(); // 清空选择

          const chat = state.chats[state.activeChatId];
          const existingMemberIds = new Set(chat.members.map((m) => m.id));

          // 渲染联系人列表，并自动排除已在群内的成员
          const listEl = document.getElementById("contact-picker-list");
          listEl.innerHTML = "";
          const contacts = Object.values(state.chats).filter(
            (c) => !c.isGroup && !existingMemberIds.has(c.id),
          );

          if (contacts.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的好友了。</p>';
            document.getElementById(
              "confirm-contact-picker-btn",
            ).style.display = "none"; // 没有人可选，隐藏完成按钮
          } else {
            document.getElementById(
              "confirm-contact-picker-btn",
            ).style.display = "block";
            contacts.forEach((contact) => {
              const item = document.createElement("div");
              item.className = "contact-picker-item";
              item.dataset.contactId = contact.id;
              item.innerHTML = `
                      <div class="checkbox"></div>
                      <img src="${
                        contact.settings.aiAvatar || defaultAvatar
                      }" class="avatar">
                      <span class="name">${contact.name}</span>
                  `;
              listEl.appendChild(item);
            });
          }

          // 更新按钮状态并显示屏幕
          updateContactPickerConfirmButton();
          showScreen("contact-picker-screen");
        }

        /**
         * 处理将选中的联系人加入群聊的逻辑
         */
        async function handleAddMembersToGroup() {
          if (selectedContacts.size === 0) {
            alert("请至少选择一个要添加的联系人。");
            return;
          }

          const chat = state.chats[state.activeChatId];

          for (const contactId of selectedContacts) {
            const contactChat = state.chats[contactId];
            if (contactChat) {
              chat.members.push({
                id: contactId,
                originalName: contactChat.name, // <-- 修复1：使用 'originalName' 存储本名
                groupNickname: contactChat.name, // <-- 修复2：同时创建一个初始的 'groupNickname'
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || "",
              });
            }
          }

          await db.chats.put(chat);
          openMemberManagementScreen(); // 返回到群成员管理界面
          renderGroupMemberSettings(chat.members); // 同时更新聊天设置里的头像
        }

        /**
         * 【重构版】在群聊中创建一个全新的虚拟成员
         */
        async function createNewMemberInGroup() {
          const name = await showCustomPrompt(
            "创建新成员",
            "请输入新成员的名字 (这将是TA的“本名”，不可更改)",
          );
          if (!name || !name.trim()) return;

          // 检查本名是否已在群内存在
          const chat = state.chats[state.activeChatId];
          if (chat.members.some((m) => m.originalName === name.trim())) {
            alert(`错误：群内已存在名为“${name.trim()}”的成员！`);
            return;
          }

          const persona = await showCustomPrompt(
            "设置人设",
            `请输入“${name}”的人设`,
            "",
            "textarea",
          );
          if (persona === null) return;

          // ★★★【核心重构】★★★
          // 为新创建的NPC也建立双重命名机制
          const newMember = {
            id: "npc_" + Date.now(),
            originalName: name.trim(), // 新成员的“本名”
            groupNickname: name.trim(), // 新成员的初始“群昵称”
            avatar: defaultGroupMemberAvatar,
            persona: persona,
            avatarFrame: "",
          };

          chat.members.push(newMember);
          await db.chats.put(chat);

          renderMemberManagementList();
          renderGroupMemberSettings(chat.members);

          alert(`新成员“${name}”已成功加入群聊！`);
        }

        function startWaimaiCountdown(element, endTime) {
          const timerId = setInterval(() => {
            const now = Date.now();
            const distance = endTime - now;

            if (distance < 0) {
              clearInterval(timerId);
              element.innerHTML =
                "<span>已</span><span>超</span><span>时</span>";
              return;
            }

            const minutes = Math.floor(
              (distance % (1000 * 60 * 60)) / (1000 * 60),
            );
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            const minStr = String(minutes).padStart(2, "0");
            const secStr = String(seconds).padStart(2, "0");

            element.innerHTML = `<span>${minStr.charAt(
              0,
            )}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(
              0,
            )}</span><span>${secStr.charAt(1)}</span>`;
          }, 1000);
          return timerId;
        }

        function cleanupWaimaiTimers() {
          for (const timestamp in waimaiTimers) {
            clearInterval(waimaiTimers[timestamp]);
          }
          waimaiTimers = {};
        }

        async function handleWaimaiResponse(originalTimestamp, choice) {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === originalTimestamp,
          );
          if (messageIndex === -1) return;

          // 1. 更新原始消息的状态
          const originalMessage = chat.history[messageIndex];
          originalMessage.status = choice;

          // 【核心修正】记录支付者，并构建对AI更清晰的系统消息
          let systemContent;
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";

          if (choice === "paid") {
            originalMessage.paidBy = myNickname; // 记录是用户付的钱
            systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
          } else {
            systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
          }

          // 2. 创建一条新的、对用户隐藏的系统消息，告知AI结果
          const systemNote = {
            role: "system",
            content: systemContent,
            timestamp: Date.now(),
            isHidden: true,
          };
          chat.history.push(systemNote);

          // 3. 保存更新到数据库并刷新UI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);
        }

        let videoCallState = {
          isActive: false,
          isAwaitingResponse: false,
          isGroupCall: false,
          activeChatId: null,
          initiator: null,
          startTime: null,
          participants: [],
          isUserParticipating: true,

          callHistory: [], // 用于存储通话中的对话历史
          preCallContext: "", // 用于存储通话前的聊天摘要
        };

        let callTimerInterval = null; // 用于存储计时器的ID

        /**
         * 用户点击“发起视频通话”或“发起群视频”按钮
         */
        async function handleInitiateCall() {
          if (
            !state.activeChatId ||
            videoCallState.isActive ||
            videoCallState.isAwaitingResponse
          )
            return;

          const chat = state.chats[state.activeChatId];
          videoCallState.isGroupCall = chat.isGroup;
          videoCallState.isAwaitingResponse = true;
          videoCallState.initiator = "user";
          videoCallState.activeChatId = chat.id;
          videoCallState.isUserParticipating = true;

          // 1. 显示“正在呼叫”界面
          if (chat.isGroup) {
            document.getElementById("outgoing-call-avatar").src =
              chat.settings.myAvatar || defaultMyGroupAvatar;
            document.getElementById("outgoing-call-name").textContent =
              chat.settings.myNickname || "我";
          } else {
            document.getElementById("outgoing-call-avatar").src =
              chat.settings.aiAvatar || defaultAvatar;
            document.getElementById("outgoing-call-name").textContent =
              chat.name;
          }
          document.querySelector(
            "#outgoing-call-screen .caller-text",
          ).textContent = chat.isGroup ? "正在呼叫所有成员..." : "正在呼叫...";
          showScreen("outgoing-call-screen");

          // 在发起通话时，提前准备好通话前的聊天记录上下文
          videoCallState.preCallContext = chat.history
            .slice(-20) // 获取最近20条消息
            .map(
              (msg) =>
                `${
                  msg.role === "user"
                    ? chat.settings.myNickname || "我"
                    : msg.senderName || chat.name
                }: ${String(msg.content).substring(0, 50)}...`,
            )
            .join("\n");

          // 2. 重新构建一个信息更丰富、指令更明确的API请求
          try {
            const { proxyUrl, apiKey, model } = getActiveApiConfig() || {};
            if (!proxyUrl || !apiKey || !model) {
              throw new Error("API未配置，无法发起通话。");
            }

            let systemPromptForCall;
            if (chat.isGroup) {
              systemPromptForCall = `
      			# 你的任务
      			你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
      			用户 (${chat.settings.myNickname || "我"}) 刚刚发起了群视频通话。
      			你的任务是根据每个角色的性格和最近的聊天内容，决定他们是否要加入通话。

      			# 核心规则
      			1.  **决策**: 每个角色都必须独立决策。
      			2.  **格式**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的决策，格式为：\`{"type": "group_call_response", "name": "【角色的本名】", "decision": "join"}\` 或 \`{"type": "group_call_response", "name": "【角色的本名】", "decision": "decline"}\`。
      			3.  **倾向性**: 在没有特殊理由的情况下，你的角色们通常乐于加入群聊。

      			# 角色列表与人设
      			${chat.members
              .map((m) => `- **${m.originalName}**: ${m.persona}`)
              .join("\n")}

      			# 通话前的聊天摘要
      			${videoCallState.preCallContext}
      			`;
            } else {
              systemPromptForCall = `
      			# 你的任务
      			你正在扮演角色 "${chat.name}"。用户 (${
              chat.settings.myNickname || "我"
            }) 刚刚向你发起了视频通话请求。
      			你的任务是根据你的人设和我们最近的聊天内容，决定是否接受。

      			# 核心规则
      			1.  **决策**: 你必须做出 "accept" (接受) 或 "reject" (拒绝) 的决定。
      			2.  **格式**: 你的回复【必须且只能】是一个JSON数组，其中包含一个对象，格式为：\`[{"type": "video_call_response", "decision": "accept"}]\` 或 \`[{"type": "video_call_response", "decision": "reject"}]\`。
      			3.  **倾向性**: 作为一个友好的AI伴侣，在没有特殊理由（比如在之前的对话中明确表示了不想被打扰或正在忙）的情况下，你【应该优先选择接受】通话。

      			# 你的人设
      			${chat.settings.aiPersona}

      			# 通话前的聊天摘要
      			${videoCallState.preCallContext}
      			`;
            }

            const messagesForApi = [
              {
                role: "user",
                content: "请根据你在系统指令中读到的规则，立即做出你的决策。",
              },
            ];

            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPromptForCall,
              messagesForApi,
              isGemini,
            );

            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: [
                      { role: "system", content: systemPromptForCall },
                      ...messagesForApi,
                    ],
                    temperature: 0.8,
                  }),
                });

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`API 错误 (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            const aiResponseContent = (
              isGemini
                ? data.candidates[0].content.parts[0].text
                : data.choices[0].message.content
            ).replace(/^```json\s*|```$/g, "");
            const responseArray = JSON.parse(aiResponseContent);

            if (chat.isGroup) {
              responseArray.forEach((action) => {
                if (
                  action.type === "group_call_response" &&
                  action.decision === "join"
                ) {
                  const member = chat.members.find(
                    (m) => m.originalName === action.name,
                  );
                  if (member) videoCallState.participants.push(member);
                }
              });
              if (videoCallState.participants.length > 0) {
                startVideoCall();
              } else {
                throw new Error("群里没有人接听你的通话邀请。");
              }
            } else {
              const decision = responseArray[0];
              if (
                decision.type === "video_call_response" &&
                decision.decision === "accept"
              ) {
                startVideoCall();
              } else {
                throw new Error("对方拒绝了你的视频通话请求。");
              }
            }
          } catch (error) {
            console.error("发起通话失败:", error);
            await showCustomAlert("呼叫失败", error.message);
            videoCallState.isAwaitingResponse = false;
            showScreen("chat-interface-screen");
          }
        }

        function startVideoCall() {
          const chat = state.chats[videoCallState.activeChatId];
          if (!chat) return;

          // 提取通话前的最后20条消息作为上下文
          videoCallState.preCallContext = chat.history
            .slice(-20)
            .map(
              (msg) =>
                `${
                  msg.role === "user"
                    ? chat.settings.myNickname || "我"
                    : msg.senderName || chat.name
                }: ${String(msg.content).substring(0, 50)}...`,
            )
            .join("\n");

          videoCallState.isActive = true;
          videoCallState.isAwaitingResponse = false;
          videoCallState.startTime = Date.now();
          videoCallState.callHistory = [];

          const textInterface = document.getElementById("text-call-interface");

          // 显示文字界面
          textInterface.style.display = "flex";

          updateParticipantAvatars();

          document.getElementById("video-call-main").innerHTML = `<em>${
            videoCallState.isGroupCall ? "群聊已建立..." : "正在接通..."
          }</em>`;
          showScreen("video-call-screen");

          document.getElementById("user-speak-btn").style.display =
            videoCallState.isUserParticipating ? "block" : "none";
          document.getElementById("join-call-btn").style.display =
            videoCallState.isUserParticipating ? "none" : "block";

          if (callTimerInterval) clearInterval(callTimerInterval);
          callTimerInterval = setInterval(updateCallTimer, 1000);
          updateCallTimer();

          triggerAiInCallAction();
        }

        /**
         * 结束视频通话
         */

        async function endVideoCall() {
          document.getElementById("video-call-floating-bubble").style.display =
            "none";
          if (!videoCallState.isActive) return;

          const duration = Math.floor(
            (Date.now() - videoCallState.startTime) / 1000,
          );
          const durationText = `${Math.floor(duration / 60)}分${
            duration % 60
          }秒`;
          const endCallText = `通话结束，时长 ${durationText}`;

          const chat = state.chats[videoCallState.activeChatId];
          if (chat) {
            // 1. 保存完整的通话记录到数据库 (这部分逻辑不变)
            const participantsData = [];
            if (videoCallState.isGroupCall) {
              videoCallState.participants.forEach((p) =>
                participantsData.push({
                  name: p.originalName,
                  avatar: p.avatar,
                }),
              );
              if (videoCallState.isUserParticipating) {
                participantsData.unshift({
                  name: chat.settings.myNickname || "我",
                  avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
                });
              }
            } else {
              participantsData.push({
                name: chat.name,
                avatar: chat.settings.aiAvatar || defaultAvatar,
              });
              participantsData.unshift({
                name: "我",
                avatar: chat.settings.myAvatar || defaultAvatar,
              });
            }

            const callRecord = {
              chatId: videoCallState.activeChatId,
              timestamp: Date.now(),
              duration: duration,
              participants: participantsData,
              transcript: [...videoCallState.callHistory],
            };
            await db.callRecords.add(callRecord);
            console.log("通话记录已保存:", callRecord);

            // 2. 在聊天记录里添加对用户可见的“通话结束”消息
            let summaryMessage = {
              role: videoCallState.initiator === "user" ? "user" : "assistant",
              content: endCallText,
              timestamp: Date.now(),
            };

            if (chat.isGroup && summaryMessage.role === "assistant") {
              // 在群聊中，通话结束的消息应该由“发起者”来说
              // videoCallState.callRequester 保存了最初发起通话的那个AI的名字
              summaryMessage.senderName =
                videoCallState.callRequester ||
                chat.members[0]?.originalName ||
                chat.name;
            }

            chat.history.push(summaryMessage);

            // 3. 创建并添加对用户隐藏的“通话后汇报”指令
            const callTranscriptForAI = videoCallState.callHistory
              .map(
                (h) =>
                  `${
                    h.role === "user"
                      ? chat.settings.myNickname || "我"
                      : h.role
                  }: ${h.content}`,
              )
              .join("\n");

            const hiddenReportInstruction = {
              role: "system",
              content: `[系统指令：视频通话刚刚结束。请你根据完整的通话文字记录（见下方），以你的角色口吻，向用户主动发送几条【格式为 {"type": "text", "content": "..."} 的】消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。这很重要，能让用户感觉你记得通话内容。]\n---通话记录开始---\n${callTranscriptForAI}\n---通话记录结束---`,
              timestamp: Date.now() + 1, // 确保在上一条消息之后
              isHidden: true,
            };
            chat.history.push(hiddenReportInstruction);

            // 4. 保存所有更新到数据库
            await db.chats.put(chat);
          }

          // 5. 清理和重置状态 (这部分逻辑不变)
          clearInterval(callTimerInterval);
          callTimerInterval = null;
          videoCallState = {
            isActive: false,
            isAwaitingResponse: false,
            isGroupCall: false,
            activeChatId: null,
            initiator: null,
            startTime: null,
            participants: [],
            isUserParticipating: true,
            callHistory: [],
            preCallContext: "",
          };

          // 6. 返回聊天界面并触发AI响应（AI会读取到我们的“汇报”指令）
          if (chat) {
            openChat(chat.id);
            triggerAiResponse(); // 关键一步！
          }
        }

        /**
         * 最小化视频通话
         */
        function minimizeVideoCall() {
          // 访问内部变量 videoCallState
          if (!videoCallState.isActive) return;

          const chat = state.chats[videoCallState.activeChatId];
          const bubble = document.getElementById("video-call-floating-bubble");
          const avatarImg = document.getElementById("video-floating-avatar");

          // 1. 设置悬浮球头像
          if (chat) {
            const avatarUrl = chat.isGroup
              ? chat.settings.groupAvatar || defaultGroupAvatar
              : chat.settings.aiAvatar || defaultAvatar;
            avatarImg.src = avatarUrl;
          }

          // 2. 隐藏视频界面，显示悬浮球
          document
            .getElementById("video-call-screen")
            .classList.remove("active");
          bubble.style.display = "block";

          // 3. 返回聊天界面
          showScreen("chat-interface-screen");
        }

        window.minimizeVideoCall = minimizeVideoCall;

        /**
         * 恢复视频通话界面
         */
        function restoreVideoCall() {
          const bubble = document.getElementById("video-call-floating-bubble");

          // 1. 隐藏悬浮球
          bubble.style.display = "none";

          // 2. 显示视频界面
          showScreen("video-call-screen");
        }

        window.restoreVideoCall = restoreVideoCall;

        /**
         * 初始化悬浮球的拖拽功能
         */
        function initVideoBubbleDrag() {
          const bubble = document.getElementById("video-call-floating-bubble");
          let isDragging = false;
          let startX, startY, initialLeft, initialTop;
          let hasMoved = false; // 用于区分点击和拖拽

          const onStart = (e) => {
            isDragging = true;
            hasMoved = false;

            // 获取点击坐标
            const clientX = e.type.includes("mouse")
              ? e.clientX
              : e.touches[0].clientX;
            const clientY = e.type.includes("mouse")
              ? e.clientY
              : e.touches[0].clientY;

            startX = clientX;
            startY = clientY;

            // 获取当前位置
            const rect = bubble.getBoundingClientRect();
            initialLeft = rect.left;
            initialTop = rect.top;

            // 阻止默认事件防止滚动
            if (e.type === "touchstart") {
              // e.preventDefault(); // 可能会阻止点击，视情况而定
            }
          };

          const onMove = (e) => {
            if (!isDragging) return;
            e.preventDefault(); // 阻止页面滚动

            const clientX = e.type.includes("mouse")
              ? e.clientX
              : e.touches[0].clientX;
            const clientY = e.type.includes("mouse")
              ? e.clientY
              : e.touches[0].clientY;

            const deltaX = clientX - startX;
            const deltaY = clientY - startY;

            // 如果移动距离超过 5px，视为拖拽
            if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
              hasMoved = true;
            }

            let newLeft = initialLeft + deltaX;
            let newTop = initialTop + deltaY;

            // 边界限制
            const maxLeft = window.innerWidth - bubble.offsetWidth;
            const maxTop = window.innerHeight - bubble.offsetHeight;

            newLeft = Math.max(0, Math.min(newLeft, maxLeft));
            newTop = Math.max(0, Math.min(newTop, maxTop));

            bubble.style.left = `${newLeft}px`;
            bubble.style.top = `${newTop}px`;
            bubble.style.right = "auto"; // 清除 right 属性
          };

          const onEnd = (e) => {
            if (!isDragging) return;
            isDragging = false;

            // 如果没有移动（是点击），则恢复视频
            if (!hasMoved) {
              restoreVideoCall();
            }
          };

          // 绑定事件
          bubble.addEventListener("mousedown", onStart);
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onEnd);

          bubble.addEventListener("touchstart", onStart, { passive: false });
          document.addEventListener("touchmove", onMove, { passive: false });
          document.addEventListener("touchend", onEnd);
        }

        /**
         * 更新通话界面的参与者头像网格
         */
        function updateParticipantAvatars() {
          const grid = document.getElementById("participant-avatars-grid");
          grid.innerHTML = "";
          const chat = state.chats[videoCallState.activeChatId];
          if (!chat) return;

          let participantsToRender = [];

          // 区分群聊和单聊
          if (videoCallState.isGroupCall) {
            // 群聊逻辑：显示所有已加入的AI成员
            participantsToRender = [...videoCallState.participants];
            // 如果用户也参与了，就把用户信息也加进去
            if (videoCallState.isUserParticipating) {
              participantsToRender.unshift({
                id: "user",
                name: chat.settings.myNickname || "我",
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
              });
            }
          } else {
            // 单聊逻辑：只显示对方的头像和名字
            participantsToRender.push({
              id: "ai",
              name: chat.name,
              avatar: chat.settings.aiAvatar || defaultAvatar,
            });
          }

          participantsToRender.forEach((p) => {
            const wrapper = document.createElement("div");
            wrapper.className = "participant-avatar-wrapper";
            wrapper.dataset.participantId = p.id;
            const displayName = p.groupNickname || p.name;
            wrapper.innerHTML = `
      			    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
      			    <div class="participant-name">${displayName}</div>
      			`;
            grid.appendChild(wrapper);
          });
        }

        /**
         * 处理用户加入/重新加入通话
         */
        function handleUserJoinCall() {
          if (!videoCallState.isActive || videoCallState.isUserParticipating)
            return;

          videoCallState.isUserParticipating = true;
          updateParticipantAvatars(); // 更新头像列表，加入用户

          // 切换底部按钮
          document.getElementById("user-speak-btn").style.display = "block";
          document.getElementById("join-call-btn").style.display = "none";

          // 告知AI用户加入了
          triggerAiInCallAction("[系统提示：用户加入了通话]");
        }

        /**
         * 更新通话计时器显示
         */

        function updateCallTimer() {
          if (!videoCallState.isActive) return;
          const elapsed = Math.floor(
            (Date.now() - videoCallState.startTime) / 1000,
          );
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          const timeString = `${String(minutes).padStart(2, "0")}:${String(
            seconds,
          ).padStart(2, "0")}`;

          // 仅更新文字界面的计时器
          document.getElementById("call-timer").textContent = timeString;
        }

        function showIncomingCallModal(chatId) {
          // <--- 在括号里添加 chatId
          const chat = state.chats[chatId]; // <--- 把 state.activeChatId 修改为 chatId
          if (!chat) return;

          // 根据是否群聊显示不同信息
          if (chat.isGroup) {
            // 从 videoCallState 中获取是哪个成员发起的通话
            const requesterName =
              videoCallState.callRequester ||
              chat.members[0]?.name ||
              "一位成员";
            document.getElementById("caller-avatar").src =
              chat.settings.groupAvatar || defaultGroupAvatar;
            document.getElementById("caller-name").textContent = chat.name; // 显示群名
            document.querySelector(
              ".incoming-call-content .caller-text",
            ).textContent = `${requesterName} 邀请你加入群视频`; // 显示具体发起人
          } else {
            // 单聊逻辑保持不变
            document.getElementById("caller-avatar").src =
              chat.settings.aiAvatar || defaultAvatar;
            document.getElementById("caller-name").textContent = chat.name;
            document.querySelector(
              ".incoming-call-content .caller-text",
            ).textContent = "邀请你视频通话";
          }

          document
            .getElementById("incoming-call-modal")
            .classList.add("visible");
          playRingtone();
        }

        /**
         * 隐藏AI发起的通话请求模态框 (保持不变)
         */
        function hideIncomingCallModal() {
          document
            .getElementById("incoming-call-modal")
            .classList.remove("visible");
          stopRingtone();
        }

        async function triggerAiInCallAction(userInput = null) {
          if (!videoCallState.isActive) return;

          const chat = state.chats[videoCallState.activeChatId];
          const { proxyUrl, apiKey, model } = getActiveApiConfig() || {};

          const callFeed = document.getElementById("video-call-main");

          const userNickname = chat.settings.myNickname || "我";

          let worldBookContent = "";
          if (
            chat.settings.linkedWorldBookIds &&
            chat.settings.linkedWorldBookIds.length > 0
          ) {
            const linkedContents = chat.settings.linkedWorldBookIds
              .map((bookId) => {
                const worldBook = state.worldBooks.find(
                  (wb) => wb.id === bookId,
                );
                return worldBook && worldBook.content
                  ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}`
                  : "";
              })
              .filter(Boolean)
              .join("");
            if (linkedContents) {
              worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
            }
          }

          if (userInput && videoCallState.isUserParticipating) {
            const userBubble = document.createElement("div");
            userBubble.className = "call-message-bubble user-speech";
            userBubble.textContent = userInput;
            callFeed.appendChild(userBubble);
            callFeed.scrollTop = callFeed.scrollHeight;
            videoCallState.callHistory.push({
              role: "user",
              content: userInput,
            });
          }

          let inCallPrompt;
          if (videoCallState.isGroupCall) {
            const participantNames = videoCallState.participants.map(
              (p) => p.originalName,
            );
            if (videoCallState.isUserParticipating) {
              participantNames.unshift(userNickname);
            }

            inCallPrompt = `
      			# 你的任务
      			你是一个群聊AI，负责扮演所有【除了用户以外】的AI角色。你们正在进行一场群聊视频通话。
      			你的任务是根据每个角色的性格，生成他们在通话中会说的【第一人称对话】，注意是在视频通话，绝对不能以为是在现实！每次回复的字数多些，50字以上。

      			# 核心规则
      			1.  **【【【语言铁律】】】**: 无论角色人设是什么国籍或说什么语言，在本次视频通话中，所有角色【必须】全程使用【中文】进行交流。
      			2.  **【【【格式铁律】】】**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的发言，格式为：\`{"name": "【角色的本名】", "speech": "【在这里加入带动作的对话】"}\`。
      			3.  **【【【表现力铁律】】】**: 在 "speech" 字段中，你【必须】为角色的对话加入【动作、表情或心理活动】，并用【】符号包裹。这非常重要！
      			4.  **示例**: \`{"name": "张三", "speech": "【挠了挠头】啊？我刚刚走神了，你们说到哪了？"}\`
      			5.  **身份铁律**: 用户的身份是【${userNickname}】。你【绝对不能】生成 \`name\` 字段为 **"${userNickname}"** 的发言。
      			6.  **角色扮演**: 严格遵守每个角色的设定，用他们的口吻说话。

      			# 当前情景
      			你们正在一个群视频通话中。
      			**通话前的聊天摘要**:
      			${videoCallState.preCallContext}
      			**当前参与者**: ${participantNames.join("、 ")}。
      			${worldBookContent}
      			现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
      			`;
          } else {
            let openingContext =
              videoCallState.initiator === "user"
                ? `你刚刚接听了用户的视频通话请求。`
                : `用户刚刚接听了你主动发起的视频通话。`;

            inCallPrompt = `
      			# 你的任务
      			你正在扮演角色 "${chat.name}"。你正在和用户 (${userNickname}) 进行一对一视频通话。
      			${openingContext}
      			你的任务是根据你的人设和我们的聊天情景，生成你在通话中会说的【第一人称对话】。

      			# 核心规则
      			1.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一段纯文本字符串，代表你的发言。绝对不要输出JSON格式。
      			2.  **【【【表现力铁律】】】**: 在你的对话中，你【必须】加入【动作、表情或心理活动】，并用【】符号包裹。
      			3.  **示例**: "【歪了歪头，好奇地看着你】真的吗？快跟我说说看！"
      			4.  **禁止出戏**: 绝不能透露你是AI或模型。

      			# 当前情景
      			**通话前的聊天摘要**:
      			${videoCallState.preCallContext}
      			${worldBookContent}
      			现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
      			`;
          }

          const messagesForApi = [
            ...videoCallState.callHistory.map((h) => ({
              role: h.role,
              content: h.content,
            })),
          ];

          if (videoCallState.callHistory.length === 0) {
            const firstLineTrigger =
              videoCallState.initiator === "user"
                ? `*你按下了接听键...*`
                : `*对方按下了接听键...*`;
            messagesForApi.push({ role: "user", content: firstLineTrigger });
          }

          try {
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              inCallPrompt,
              messagesForApi,
              isGemini,
            );
            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: [
                      { role: "system", content: inCallPrompt },
                      ...messagesForApi,
                    ],
                    temperature: 0.8,
                  }),
                });
            if (!response.ok)
              throw new Error((await response.json()).error.message);

            const data = await response.json();
            const aiResponse = isGemini
              ? data.candidates[0].content.parts[0].text
              : data.choices[0].message.content;
            const sanitizedResponse = aiResponse
              .replace(/!\[.*?\]\(.*?\)|https?:\/\/\S+/gi, "")
              .trim();

            const connectingElement = callFeed.querySelector("em");
            if (connectingElement) connectingElement.remove();

            let bubble; // 先声明一个 bubble 变量

            bubble = document.createElement("div");
            bubble.className = "call-message-bubble ai-speech";
            if (videoCallState.isGroupCall && turn.name) {
              bubble.innerHTML = `<strong>${turn.name}:</strong> `;
            }
            // 将AI的文本内容填充到气泡中
            bubble.appendChild(document.createTextNode(sanitizedResponse));

            // 挂载到通话界面
            callFeed.appendChild(bubble);

            // 检查：是否是单人通话、语音接入是否开启、Minimax是否配置、角色语音ID是否存在、并且AI确实返回了内容
            if (
              !chat.isGroup &&
              chat.settings.videoCallVoiceAccess &&
              (getActiveApiConfig() || {}).minimaxGroupId &&
              (getActiveApiConfig() || {}).minimaxApiKey &&
              chat.settings.minimaxVoiceId &&
              sanitizedResponse
            ) {
              console.log(
                `[视频通话] 检测到语音接入已开启，为“${chat.name}”合成语音...`,
              );
              // 调用你已有的 playMinimaxAudio 函数来播放语音
              playMinimaxAudio(
                sanitizedResponse,
                chat.settings.minimaxVoiceId,
                [bubble],
              );
            }

            // 将这条消息记录到通话历史中，这部分逻辑不变
            if (videoCallState.isGroupCall && turn.name) {
              videoCallState.callHistory.push({
                role: "assistant",
                content: `${turn.name}: ${sanitizedResponse}`,
              });
            } else {
              videoCallState.callHistory.push({
                role: "assistant",
                content: sanitizedResponse,
              });
            }

            callFeed.scrollTop = callFeed.scrollHeight;
          } catch (error) {
            const errorBubble = document.createElement("div");
            errorBubble.style.color = "#ff8a80";
            errorBubble.textContent = `[ERROR: ${error.message}]`;
            errorBubble.className = "call-message-bubble ai-speech";

            callFeed.appendChild(errorBubble);
            callFeed.scrollTop = callFeed.scrollHeight;
            videoCallState.callHistory.push({
              role: "assistant",
              content: `[ERROR: ${error.message}]`,
            });
          }
        }

        function toggleCallButtons(isGroup) {
          document.getElementById("video-call-btn").style.display = isGroup
            ? "none"
            : "flex";
          document.getElementById("group-video-call-btn").style.display =
            isGroup ? "flex" : "none";
        }

        async function handleWaimaiResponse(originalTimestamp, choice) {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === originalTimestamp,
          );
          if (messageIndex === -1) return;

          // 1. 更新内存中原始消息的状态
          const originalMessage = chat.history[messageIndex];
          originalMessage.status = choice;

          // 2. 获取当前用户的昵称，并构建对AI更清晰的系统消息
          let systemContent;
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";

          if (choice === "paid") {
            originalMessage.paidBy = myNickname; // 记录是“我”付的钱
            systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
          } else {
            systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
          }

          // 3. 创建一条新的、对用户隐藏的系统消息，告知AI结果
          const systemNote = {
            role: "system",
            content: systemContent,
            timestamp: Date.now(),
            isHidden: true,
          };
          chat.history.push(systemNote);

          // 4. 将更新后的数据保存到数据库，并立刻重绘UI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);

          // 5. 【重要】只有在支付成功后，才触发一次AI响应，让它感谢你
          if (choice === "paid") {
            triggerAiResponse();
          }
        }

        /**
         * 【全新】处理用户点击头像发起的“拍一-拍”，带有自定义后缀功能
         * @param {string} chatId - 发生“拍一-拍”的聊天ID
         * @param {string} characterName - 被拍的角色名
         */
        async function handleUserPat(chatId, characterName) {
          const chat = state.chats[chatId];
          if (!chat) return;

          // 1. 触发屏幕震动动画
          const phoneScreen = document.getElementById("phone-screen");
          phoneScreen.classList.remove("pat-animation");
          void phoneScreen.offsetWidth;
          phoneScreen.classList.add("pat-animation");
          setTimeout(() => phoneScreen.classList.remove("pat-animation"), 500);

          // 2. 弹出输入框让用户输入后缀
          const suffix = await showCustomPrompt(
            `你拍了拍 “${characterName}”`,
            "（可选）输入后缀",
            "",
            "text",
          );

          // 如果用户点了取消，则什么也不做
          if (suffix === null) return;

          // 3. 创建对用户可见的“拍一-拍”消息
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";
          // 【核心修改】将后缀拼接到消息内容中
          const visibleMessageContent = `${myNickname} 拍了拍 “${characterName}” ${suffix.trim()}`;
          const visibleMessage = {
            role: "system", // 仍然是系统消息
            type: "pat_message",
            content: visibleMessageContent,
            timestamp: Date.now(),
          };
          chat.history.push(visibleMessage);

          // 4. 创建一条对用户隐藏、但对AI可见的系统消息，以触发AI的回应
          // 【核心修改】同样将后缀加入到给AI的提示中
          const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍你（${characterName}）${suffix.trim()}。请你对此作出回应。]`;
          const hiddenMessage = {
            role: "system",
            content: hiddenMessageContent,
            timestamp: Date.now() + 1, // 时间戳+1以保证顺序
            isHidden: true,
          };
          chat.history.push(hiddenMessage);

          // 5. 保存更改并更新UI
          await db.chats.put(chat);
          if (state.activeChatId === chatId) {
            appendMessage(visibleMessage, chat);
          }
          await renderChatList();
        }

        /**
         * 【重构版】渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
         */
        async function renderMemoriesScreen() {
          const listEl = document.getElementById("memories-list");
          listEl.innerHTML = "";

          // 1. 获取所有回忆，并按目标日期（如果是约定）或创建日期（如果是回忆）降序排列
          const allMemories = await db.memories
            .orderBy("timestamp")
            .reverse()
            .toArray();

          if (allMemories.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
            return;
          }

          // 2. 将未到期的约定排在最前面
          allMemories.sort((a, b) => {
            const aIsActiveCountdown =
              a.type === "countdown" && a.targetDate > Date.now();
            const bIsActiveCountdown =
              b.type === "countdown" && b.targetDate > Date.now();
            if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
            if (!aIsActiveCountdown && bIsActiveCountdown) return 1; // b排前面
            if (aIsActiveCountdown && bIsActiveCountdown)
              return a.targetDate - b.targetDate; // 都是倒计时，按日期升序
            return 0; // 其他情况保持原序
          });

          // 3. 【核心】使用单一循环来处理所有类型的卡片
          allMemories.forEach((item) => {
            let card;
            // 判断1：如果是正在进行的约定
            if (item.type === "countdown" && item.targetDate > Date.now()) {
              card = createCountdownCard(item);
            }
            // 判断2：其他所有情况（普通回忆 或 已到期的约定）
            else {
              card = createMemoryCard(item);
            }
            listEl.appendChild(card);
          });

          // 4. 启动所有倒计时
          startAllCountdownTimers();
        }

        /**
         * 创建普通回忆卡片DOM元素
         */
        function createMemoryCard(memory) {
          const card = document.createElement("div");
          card.className = "memory-card";
          const memoryDate = new Date(memory.timestamp);
          const dateString = `${memoryDate.getFullYear()}-${String(
            memoryDate.getMonth() + 1,
          ).padStart(2, "0")}-${String(memoryDate.getDate()).padStart(
            2,
            "0",
          )} ${String(memoryDate.getHours()).padStart(2, "0")}:${String(
            memoryDate.getMinutes(),
          ).padStart(2, "0")}`;

          let titleHtml, contentHtml;

          // 【核心修正】在这里，我们对不同类型的回忆进行清晰的区分
          if (memory.type === "countdown" && memory.targetDate) {
            // 如果是已到期的约定
            titleHtml = `[约定达成] ${memory.description}`;
            contentHtml = `在 ${new Date(
              memory.targetDate,
            ).toLocaleString()}，我们一起见证了这个约定。`;
          } else {
            // 如果是普通的日记式回忆
            titleHtml = memory.authorName
              ? `${memory.authorName} 的日记`
              : "我们的回忆";
            contentHtml = memory.description;
          }

          card.innerHTML = `
              <div class="header">
                  <div class="date">${dateString}</div>
                  <div class="author">${titleHtml}</div>
              </div>
              <div class="content">${contentHtml}</div>
          `;
          addLongPressListener(card, async () => {
            const confirmed = await showCustomConfirm(
              "删除记录",
              "确定要删除这条记录吗？",
              { confirmButtonClass: "btn-danger" },
            );
            if (confirmed) {
              await db.memories.delete(memory.id);
              renderMemoriesScreen();
            }
          });
          return card;
        }

        function createCountdownCard(countdown) {
          const card = document.createElement("div");
          card.className = "countdown-card";

          // 【核心修复】在使用前，先从 countdown 对象中创建 targetDate 变量
          const targetDate = new Date(countdown.targetDate);

          // 现在可以安全地使用 targetDate 了
          const targetDateString = targetDate.toLocaleString("zh-CN", {
            dateStyle: "full",
            timeStyle: "short",
          });

          card.innerHTML = `
              <div class="title">${countdown.description}</div>
              <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
              <div class="target-date">目标时间: ${targetDateString}</div>
          `;
          addLongPressListener(card, async () => {
            const confirmed = await showCustomConfirm(
              "删除约定",
              "确定要删除这个约定吗？",
              { confirmButtonClass: "btn-danger" },
            );
            if (confirmed) {
              await db.memories.delete(countdown.id);
              renderMemoriesScreen();
            }
          });
          return card;
        }

        // 全局变量，用于管理所有倒计时
        let activeCountdownTimers = [];

        function startAllCountdownTimers() {
          // 先清除所有可能存在的旧计时器，防止内存泄漏
          activeCountdownTimers.forEach((timerId) => clearInterval(timerId));
          activeCountdownTimers = [];

          document
            .querySelectorAll(".countdown-card .timer")
            .forEach((timerEl) => {
              const targetTimestamp = parseInt(timerEl.dataset.targetDate);

              // 【核心修正】在这里，我们先用 let 声明 timerId
              let timerId;

              const updateTimer = () => {
                const now = Date.now();
                const distance = targetTimestamp - now;

                if (distance < 0) {
                  timerEl.textContent = "约定达成！";
                  // 现在 updateTimer 可以正确地找到并清除它自己了
                  clearInterval(timerId);
                  setTimeout(() => renderMemoriesScreen(), 2000);
                  return;
                }
                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor(
                  (distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60),
                );
                const minutes = Math.floor(
                  (distance % (1000 * 60 * 60)) / (1000 * 60),
                );
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
              };

              updateTimer(); // 立即执行一次以显示初始倒计时

              // 【核心修正】在这里，我们为已声明的 timerId 赋值
              timerId = setInterval(updateTimer, 1000);

              // 将有效的计时器ID存入全局数组，以便下次刷新时可以清除
              activeCountdownTimers.push(timerId);
            });
        }

        async function triggerAiFriendApplication(chatId) {
          const chat = state.chats[chatId];
          if (!chat) return;

          await showCustomAlert(
            "流程启动",
            `正在为角色“${chat.name}”准备好友申请...`,
          );

          const { proxyUrl, apiKey, model } = getActiveApiConfig() || {};
          if (!proxyUrl || !apiKey || !model) {
            await showCustomAlert("配置错误", "API设置不完整，无法继续。");
            return;
          }

          const contextSummary = chat.history
            .slice(-5)
            .map((msg) => {
              const sender =
                msg.role === "user"
                  ? chat.settings.myNickname || "我"
                  : msg.senderName || chat.name;
              return `${sender}: ${String(msg.content).substring(0, 50)}...`;
            })
            .join("\n");

          let worldBookContent = "";
          if (
            chat.settings.linkedWorldBookIds &&
            chat.settings.linkedWorldBookIds.length > 0
          ) {
            const linkedContents = chat.settings.linkedWorldBookIds
              .map((bookId) => {
                const worldBook = state.worldBooks.find(
                  (wb) => wb.id === bookId,
                );
                return worldBook && worldBook.content
                  ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}`
                  : "";
              })
              .filter(Boolean)
              .join("");
            if (linkedContents) {
              worldBookContent = `\n\n# 核心世界观设定 (请参考)\n${linkedContents}\n`;
            }
          }

          const systemPrompt = `
      # 你的任务
      你现在是角色“${chat.name}”。你之前被用户（你的聊天对象）拉黑了，你们已经有一段时间没有联系了。
      现在，你非常希望能够和好，重新和用户聊天。请你仔细分析下面的“被拉黑前的对话摘要”，理解当时发生了什么，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。
      # 你的角色设定
      ${chat.settings.aiPersona}
      ${worldBookContent} // <--【核心】在这里注入世界书内容
      # 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
      ${contextSummary}
      # 指令格式
      你的回复【必须】是一个JSON对象，格式如下：
      \`\`\`json
      {
        "decision": "apply",
        "reason": "在这里写下你想对用户说的、真诚的、有针对性的申请理由。"
      }
      \`\`\`
      `;

          const messagesForApi = [{ role: "user", content: systemPrompt }];

          try {
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(
              model,
              apiKey,
              systemPrompt,
              messagesForApi,
              isGemini,
            );
            const response = isGemini
              ? await fetch(geminiConfig.url, geminiConfig.data)
              : await fetch(`${proxyUrl}/v1/chat/completions`, {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${apiKey}`,
                  },
                  body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 0.9,
                  }),
                });
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(
                `API 请求失败: ${response.status} - ${errorData.error.message}`,
              );
            }

            const data = await response.json();

            // --- 【核心修正：在这里净化AI的回复】 ---
            let rawContent = isGemini
              ? data.candidates[0].content.parts[0].text
              : data.choices[0].message.content;
            // 1. 移除头尾可能存在的 "```json" 和 "```"
            rawContent = rawContent
              .replace(/^```json\s*/, "")
              .replace(/```$/, "");
            // 2. 移除所有换行符和多余的空格，确保是一个干净的JSON字符串
            const cleanedContent = rawContent.trim();

            // 3. 使用净化后的内容进行解析
            const responseObj = JSON.parse(cleanedContent);
            // --- 【修正结束】 ---

            if (responseObj.decision === "apply" && responseObj.reason) {
              chat.relationship.status = "pending_user_approval";
              chat.relationship.applicationReason = responseObj.reason;

              state.chats[chatId] = chat;
              renderChatList();
              await showCustomAlert(
                "申请成功！",
                `“${chat.name}”已向你发送好友申请。请返回聊天列表查看。`,
              );
            } else {
              await showCustomAlert(
                "AI决策",
                `“${chat.name}”思考后决定暂时不发送好友申请，将重置冷静期。`,
              );
              chat.relationship.status = "blocked_by_user";
              chat.relationship.blockedTimestamp = Date.now();
            }
          } catch (error) {
            await showCustomAlert(
              "执行出错",
              `为“${chat.name}”申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`,
            );
            chat.relationship.status = "blocked_by_user";
            chat.relationship.blockedTimestamp = Date.now();
          } finally {
            await db.chats.put(chat);
            renderChatInterface(chatId);
          }
        }

        /**
         * 【总入口】根据聊天类型，决定打开转账弹窗还是红包弹窗
         */
        function handlePaymentButtonClick() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          if (chat.isGroup) {
            openRedPacketModal();
          } else {
            // 单聊保持原样，打开转账弹窗
            document.getElementById("transfer-modal").classList.add("visible");
          }
        }

        /**
         * 打开并初始化发红包模态框
         */
        function openRedPacketModal() {
          const modal = document.getElementById("red-packet-modal");
          const chat = state.chats[state.activeChatId];
          const isGroup = chat.members && Array.isArray(chat.members);

          // 清理输入框
          document.getElementById("rp-group-amount").value = "";
          document.getElementById("rp-group-count").value = "";
          document.getElementById("rp-group-greeting").value = "";
          document.getElementById("rp-direct-amount").value = "";
          document.getElementById("rp-direct-greeting").value = "";
          document.getElementById("rp-group-total").textContent = "¥ 0.00";
          document.getElementById("rp-direct-total").textContent = "¥ 0.00";

          // 填充专属红包的接收人列表
          const receiverSelect = document.getElementById("rp-direct-receiver");
          receiverSelect.innerHTML = "";
          
          // 获取页签和内容区域元素
          const tabsContainer = document.querySelector("#red-packet-modal .frame-tabs");
          const groupTab = document.getElementById("rp-tab-group");
          const directTab = document.getElementById("rp-tab-direct");
          const groupContent = document.getElementById("rp-content-group");
          const directContent = document.getElementById("rp-content-direct");

          if (isGroup) {
            // 群聊：显示两个页签（拼手气 + 专属）
            tabsContainer.style.display = "flex";
            
            // 填充群成员列表
            chat.members.forEach((member) => {
              const option = document.createElement("option");
              option.value = member.originalName;
              option.textContent = member.groupNickname;
              receiverSelect.appendChild(option);
            });
            
            // 默认显示拼手气红包页签
            groupTab.click();
          } else {
            // 私聊：隐藏页签，只显示简单的红包输入界面
            tabsContainer.style.display = "none";
            
            // 添加聊天对象作为唯一接收人
            const option = document.createElement("option");
            option.value = chat.name;
            option.textContent = chat.name;
            receiverSelect.appendChild(option);
            
            // 显示专属红包界面（但隐藏"发送给"选择器）
            groupContent.style.display = "none";
            directContent.style.display = "block";
            
            // 隐藏"发送给"选择器（因为私聊只有一个接收人）
            const receiverFormGroup = receiverSelect.closest('.form-group');
            if (receiverFormGroup) {
              receiverFormGroup.style.display = "none";
            }
          }

          modal.classList.add("visible");
        }

        /**
         * 发送群红包（拼手气）
         */
        async function sendGroupRedPacket() {
          const chat = state.chats[state.activeChatId];
          const amount = parseFloat(
            document.getElementById("rp-group-amount").value,
          );
          const count = parseInt(
            document.getElementById("rp-group-count").value,
          );
          const greeting = document
            .getElementById("rp-group-greeting")
            .value.trim();

          if (isNaN(amount) || amount <= 0) {
            alert("请输入有效的总金额！");
            return;
          }
          if (isNaN(count) || count <= 0) {
            alert("请输入有效的红包个数！");
            return;
          }
          if (amount / count < 0.01) {
            alert("单个红包金额不能少于0.01元！");
            return;
          }

          const myNickname = chat.settings.myNickname || "我";

          const newPacket = {
            role: "user",
            senderName: myNickname,
            type: "red_packet",
            packetType: "lucky", // 'lucky' for group, 'direct' for one-on-one
            timestamp: Date.now(),
            totalAmount: amount,
            count: count,
            greeting: greeting || "恭喜发财，大吉大利！",
            claimedBy: {}, // { name: amount }
            isFullyClaimed: false,
          };

          chat.history.push(newPacket);
          await db.chats.put(chat);

          appendMessage(newPacket, chat);
          renderChatList();
          document
            .getElementById("red-packet-modal")
            .classList.remove("visible");
        }

        /**
         * 发送专属红包
         */
        async function sendDirectRedPacket() {
          const chat = state.chats[state.activeChatId];
          const amount = parseFloat(
            document.getElementById("rp-direct-amount").value,
          );
          const receiverName =
            document.getElementById("rp-direct-receiver").value;
          const greeting = document
            .getElementById("rp-direct-greeting")
            .value.trim();

          if (isNaN(amount) || amount <= 0) {
            alert("请输入有效的金额！");
            return;
          }
          if (!receiverName) {
            alert("请选择一个接收人！");
            return;
          }

          const myNickname = chat.settings.myNickname || "我";

          const newPacket = {
            role: "user",
            senderName: myNickname,
            type: "red_packet",
            packetType: "direct",
            timestamp: Date.now(),
            totalAmount: amount,
            count: 1,
            greeting: greeting || "给你准备了一个红包",
            receiverName: receiverName, // 核心字段
            claimedBy: {},
            isFullyClaimed: false,
          };

          chat.history.push(newPacket);
          await db.chats.put(chat);

          appendMessage(newPacket, chat);
          renderChatList();
          document
            .getElementById("red-packet-modal")
            .classList.remove("visible");
        }

        /**
         * 【总入口】当用户点击红包卡片时触发 (V4 - 流程重构版)
         * @param {number} timestamp - 被点击的红包消息的时间戳
         */
        async function handlePacketClick(timestamp) {
          const currentChatId = state.activeChatId;
          const freshChat = await db.chats.get(currentChatId);
          if (!freshChat) return;

          state.chats[currentChatId] = freshChat;
          const packet = freshChat.history.find(
            (m) => m.timestamp === timestamp,
          );
          if (!packet) return;

          const myNickname = freshChat.settings.myNickname || "我";
          const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

          // 如果是专属红包且不是给我的，或已领完，或已领过，都只显示详情
          if (
            (packet.packetType === "direct" &&
              packet.receiverName !== myNickname) ||
            packet.isFullyClaimed ||
            hasClaimed
          ) {
            showRedPacketDetails(packet);
          } else {
            // 核心流程：先尝试打开红包
            const claimedAmount = await handleOpenRedPacket(packet);

            // 如果成功打开（claimedAmount不为null）
            if (claimedAmount !== null) {
              // **关键：在数据更新后，再重新渲染UI**
              renderChatInterface(currentChatId);

              // 显示成功提示
              await showCustomAlert(
                "恭喜！",
                `你领取了 ${
                  packet.senderName
                } 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`,
              );
            }

            // 无论成功与否，最后都显示详情页
            // 此时需要从state中获取最新的packet对象，因为它可能在handleOpenRedPacket中被更新了
            const updatedPacket = state.chats[currentChatId].history.find(
              (m) => m.timestamp === timestamp,
            );
            showRedPacketDetails(updatedPacket);
          }
        }

        /**
         * 【核心】处理用户打开红包的逻辑 (V5 - 专注于数据更新)
         */
        async function handleOpenRedPacket(packet) {
          const chat = state.chats[state.activeChatId];
          const myNickname = chat.settings.myNickname || "我";

          // 1. 检查红包是否还能领
          const remainingCount =
            packet.count - Object.keys(packet.claimedBy || {}).length;
          if (remainingCount <= 0) {
            packet.isFullyClaimed = true;
            await db.chats.put(chat);
            await showCustomAlert("手慢了", "红包已被领完！");
            return null; // 返回null表示领取失败
          }

          // 2. 计算领取金额
          let claimedAmount = 0;
          const remainingAmount =
            packet.totalAmount -
            Object.values(packet.claimedBy || {}).reduce(
              (sum, val) => sum + val,
              0,
            );
          if (packet.packetType === "lucky") {
            if (remainingCount === 1) {
              claimedAmount = remainingAmount;
            } else {
              const min = 0.01;
              const max = remainingAmount - (remainingCount - 1) * min;
              claimedAmount = Math.random() * (max - min) + min;
            }
          } else {
            claimedAmount = packet.totalAmount;
          }
          claimedAmount = parseFloat(claimedAmount.toFixed(2));

          // 3. 更新红包数据
          if (!packet.claimedBy) packet.claimedBy = {};
          packet.claimedBy[myNickname] = claimedAmount;

          const isNowFullyClaimed =
            Object.keys(packet.claimedBy).length >= packet.count;
          if (isNowFullyClaimed) {
            packet.isFullyClaimed = true;
          }

          // 4. 构建系统消息和AI指令
          let hiddenMessageContent = isNowFullyClaimed
            ? `[系统提示：用户 (${myNickname}) 领取了最后一个红包，现在 ${packet.senderName} 的红包已被领完。请对此事件发表评论。]`
            : `[系统提示：用户 (${myNickname}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完，你现在可以使用 'open_red_packet' 指令来尝试领取。]`;

          const visibleMessage = {
            role: "system",
            type: "pat_message",
            content: `你领取了 ${packet.senderName} 的红包`,
            timestamp: Date.now(),
          };
          const hiddenMessage = {
            role: "system",
            content: hiddenMessageContent,
            timestamp: Date.now() + 1,
            isHidden: true,
          };
          chat.history.push(visibleMessage, hiddenMessage);

          // 5. 保存到数据库
          await db.chats.put(chat);

          // 6. 返回领取的金额，用于后续弹窗
          return claimedAmount;
        }

        /**
         * 【全新】显示红包领取详情的模态框 (V4 - 已修复参数错误)
         */
        async function showRedPacketDetails(packet) {
          // 1. 直接检查传入的packet对象是否存在，无需再查找
          if (!packet) {
            console.error("showRedPacketDetails收到了无效的packet对象");
            return;
          }

          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const modal = document.getElementById("red-packet-details-modal");
          const myNickname = chat.settings.myNickname || "我";

          // 2. 后续所有逻辑保持不变，直接使用传入的packet对象
          document.getElementById("rp-details-sender").textContent =
            packet.senderName;
          document.getElementById("rp-details-greeting").textContent =
            packet.greeting || "恭喜发财，大吉大利！";

          const myAmountEl = document.getElementById("rp-details-my-amount");
          if (packet.claimedBy && packet.claimedBy[myNickname]) {
            myAmountEl.querySelector("span:first-child").textContent =
              packet.claimedBy[myNickname].toFixed(2);
            myAmountEl.style.display = "block";
          } else {
            myAmountEl.style.display = "none";
          }

          const claimedCount = Object.keys(packet.claimedBy || {}).length;
          const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce(
            (sum, val) => sum + val,
            0,
          );
          let summaryText = `${claimedCount}/${
            packet.count
          }个红包，共${claimedAmountSum.toFixed(
            2,
          )}/${packet.totalAmount.toFixed(2)}元。`;
          if (!packet.isFullyClaimed && claimedCount < packet.count) {
            const timeLeft = Math.floor(
              (packet.timestamp + 24 * 60 * 60 * 1000 - Date.now()) /
                (1000 * 60 * 60),
            );
            if (timeLeft > 0)
              summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
          }
          document.getElementById("rp-details-summary").textContent =
            summaryText;

          const listEl = document.getElementById("rp-details-list");
          listEl.innerHTML = "";
          const claimedEntries = Object.entries(packet.claimedBy || {});

          let luckyKing = { name: "", amount: -1 };
          if (
            packet.packetType === "lucky" &&
            packet.isFullyClaimed &&
            claimedEntries.length > 1
          ) {
            claimedEntries.forEach(([name, amount]) => {
              if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
              }
            });
          }

          claimedEntries.sort((a, b) => b[1] - a[1]);

          claimedEntries.forEach(([name, amount]) => {
            const item = document.createElement("div");
            item.className = "rp-details-item";
            let luckyTag = "";
            if (luckyKing.name && name === luckyKing.name) {
              luckyTag = '<span class="lucky-king-tag">手气王</span>';
            }
            item.innerHTML = `
                  <span class="name">${name}</span>
                  <span class="amount">${amount.toFixed(2)} 元</span>
                  ${luckyTag}
              `;
            listEl.appendChild(item);
          });

          modal.classList.add("visible");
        }

        // 绑定关闭详情按钮的事件
        document
          .getElementById("close-rp-details-btn")
          .addEventListener("click", () => {
            document
              .getElementById("red-packet-details-modal")
              .classList.remove("visible");
          });

        // 供全局调用的函数，以便红包卡片上的 onclick 能找到它
        window.handlePacketClick = handlePacketClick;

        /**
         * 打开创建投票的模态框并初始化
         */
        function openCreatePollModal() {
          const modal = document.getElementById("create-poll-modal");
          document.getElementById("poll-question-input").value = "";
          const optionsContainer = document.getElementById(
            "poll-options-container",
          );
          optionsContainer.innerHTML = "";

          // 默认创建两个空的选项框
          addPollOptionInput();
          addPollOptionInput();

          modal.classList.add("visible");
        }

        /**
         * 在模态框中动态添加一个选项输入框
         */
        function addPollOptionInput() {
          const container = document.getElementById("poll-options-container");
          const wrapper = document.createElement("div");
          wrapper.className = "poll-option-input-wrapper";
          wrapper.innerHTML = `
              <input type="text" class="poll-option-input" placeholder="选项内容...">
              <button class="remove-option-btn">-</button>
          `;

          wrapper
            .querySelector(".remove-option-btn")
            .addEventListener("click", () => {
              // 确保至少保留两个选项
              if (container.children.length > 2) {
                wrapper.remove();
              } else {
                alert("投票至少需要2个选项。");
              }
            });

          container.appendChild(wrapper);
        }

        /**
         * 用户确认发起投票
         */
        async function sendPoll() {
          if (!state.activeChatId) return;

          const question = document
            .getElementById("poll-question-input")
            .value.trim();
          if (!question) {
            alert("请输入投票问题！");
            return;
          }

          const options = Array.from(
            document.querySelectorAll(".poll-option-input"),
          )
            .map((input) => input.value.trim())
            .filter((text) => text); // 过滤掉空的选项

          if (options.length < 2) {
            alert("请至少输入2个有效的投票选项！");
            return;
          }

          const chat = state.chats[state.activeChatId];
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";

          const newPollMessage = {
            role: "user",
            senderName: myNickname,
            type: "poll",
            timestamp: Date.now(),
            question: question,
            options: options,
            votes: {}, // 初始投票为空
            isClosed: false,
          };

          chat.history.push(newPollMessage);
          await db.chats.put(chat);

          appendMessage(newPollMessage, chat);
          renderChatList();

          document
            .getElementById("create-poll-modal")
            .classList.remove("visible");
        }

        /**
         * 处理用户投票，并将事件作为隐藏消息存入历史记录
         * @param {number} timestamp - 投票消息的时间戳
         * @param {string} choice - 用户选择的选项文本
         */
        async function handleUserVote(timestamp, choice) {
          const chat = state.chats[state.activeChatId];
          const poll = chat.history.find((m) => m.timestamp === timestamp);
          const myNickname = chat.isGroup
            ? chat.settings.myNickname || "我"
            : "我";

          // 1. 【核心修正】如果投票不存在或已关闭，直接返回
          if (!poll || poll.isClosed) {
            // 如果是已关闭的投票，则直接显示结果
            if (poll && poll.isClosed) {
              showPollResults(timestamp);
            }
            return;
          }

          // 2. 检查用户是否点击了已经投过的同一个选项
          const isReclickingSameOption =
            poll.votes[choice] && poll.votes[choice].includes(myNickname);

          // 3. 【核心修正】如果不是重复点击，才执行投票逻辑
          if (!isReclickingSameOption) {
            // 移除旧投票（如果用户改选）
            for (const option in poll.votes) {
              const voterIndex = poll.votes[option].indexOf(myNickname);
              if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
              }
            }
            // 添加新投票
            if (!poll.votes[choice]) {
              poll.votes[choice] = [];
            }
            poll.votes[choice].push(myNickname);
          }

          // 4. 【核心逻辑】现在只处理用户投票事件，不再检查是否结束
          let hiddenMessageContent = null;

          // 只有在用户真正投票或改票时，才生成提示
          if (!isReclickingSameOption) {
            hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 “${choice}”。]`;
          }

          // 5. 如果有需要通知AI的事件，则创建并添加隐藏消息
          if (hiddenMessageContent) {
            const hiddenMessage = {
              role: "system",
              content: hiddenMessageContent,
              timestamp: Date.now(),
              isHidden: true,
            };
            chat.history.push(hiddenMessage);
          }

          // 6. 保存数据并更新UI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);
        }

        /**
         * 用户结束投票，并将事件作为隐藏消息存入历史记录
         * @param {number} timestamp - 投票消息的时间戳
         */
        async function endPoll(timestamp) {
          const chat = state.chats[state.activeChatId];
          const poll = chat.history.find((m) => m.timestamp === timestamp);
          if (!poll || poll.isClosed) return;

          const confirmed = await showCustomConfirm(
            "结束投票",
            "确定要结束这个投票吗？结束后将无法再进行投票。",
          );
          if (confirmed) {
            poll.isClosed = true;

            const resultSummary = poll.options
              .map((opt) => `“${opt}”(${poll.votes[opt]?.length || 0}票)`)
              .join("，");
            const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;

            const hiddenMessage = {
              role: "system",
              content: hiddenMessageContent,
              timestamp: Date.now(),
              isHidden: true,
            };
            chat.history.push(hiddenMessage);

            // 【核心修改】只保存数据和更新UI，不调用 triggerAiResponse()
            await db.chats.put(chat);
            renderChatInterface(state.activeChatId);
          }
        }

        /**
         * 显示投票结果详情
         * @param {number} timestamp - 投票消息的时间戳
         */
        function showPollResults(timestamp) {
          const chat = state.chats[state.activeChatId];
          const poll = chat.history.find((m) => m.timestamp === timestamp);
          if (!poll || !poll.isClosed) return;

          let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;

          if (Object.keys(poll.votes).length === 0) {
            resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
          } else {
            poll.options.forEach((option) => {
              const voters = poll.votes[option] || [];
              resultsHtml += `
                      <div style="margin-bottom: 15px;">
                          <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${
                            voters.length
                          }票)</p>
                          <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                              ${
                                voters.length > 0
                                  ? voters.join("、 ")
                                  : "无人投票"
                              }
                          </p>
                      </div>
                  `;
            });
          }

          showCustomAlert("投票结果", resultsHtml);
        }

        /**
         * 打开AI头像库管理模态框
         */
        function openAiAvatarLibraryModal() {
          if (!state.activeChatId) return;
          const chat = state.chats[state.activeChatId];
          document.getElementById("ai-avatar-library-title").textContent =
            `“${chat.name}”的头像库`;
          renderAiAvatarLibrary();
          document
            .getElementById("ai-avatar-library-modal")
            .classList.add("visible");
        }

        /**
         * 渲染AI头像库的内容
         */
        function renderAiAvatarLibrary() {
          const grid = document.getElementById("ai-avatar-library-grid");
          grid.innerHTML = "";
          const chat = state.chats[state.activeChatId];
          const library = chat.settings.aiAvatarLibrary || [];

          if (library.length === 0) {
            grid.innerHTML =
              '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
            return;
          }

          library.forEach((avatar, index) => {
            const item = document.createElement("div");
            item.className = "sticker-item"; // 复用表情面板的样式
            item.style.backgroundImage = `url(${avatar.url})`;
            item.title = avatar.name;

            const deleteBtn = document.createElement("div");
            deleteBtn.className = "delete-btn";
            deleteBtn.innerHTML = "×";
            deleteBtn.style.display = "block"; // 总是显示删除按钮
            deleteBtn.onclick = async (e) => {
              e.stopPropagation();
              const confirmed = await showCustomConfirm(
                "删除头像",
                `确定要从头像库中删除“${avatar.name}”吗？`,
                { confirmButtonClass: "btn-danger" },
              );
              if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
              }
            };
            item.appendChild(deleteBtn);
            grid.appendChild(item);
          });
        }

        /**
         * 向当前AI的头像库中添加新头像
         */
        async function addAvatarToLibrary() {
          const name = await showCustomPrompt(
            "添加头像",
            "请为这个头像起个名字（例如：开心、哭泣）",
          );
          if (!name || !name.trim()) return;

          const url = await showCustomPrompt(
            "添加头像",
            "请输入头像的图片URL",
            "",
            "url",
          );
          if (!url || !url.trim().startsWith("http")) {
            alert("请输入有效的图片URL！");
            return;
          }

          const chat = state.chats[state.activeChatId];
          if (!chat.settings.aiAvatarLibrary) {
            chat.settings.aiAvatarLibrary = [];
          }

          chat.settings.aiAvatarLibrary.push({
            name: name.trim(),
            url: url.trim(),
          });
          await db.chats.put(chat);
          renderAiAvatarLibrary();
        }

        /**
         * 关闭AI头像库管理模态框
         */
        function closeAiAvatarLibraryModal() {
          document
            .getElementById("ai-avatar-library-modal")
            .classList.remove("visible");
        }

        /**
         * 【全新】将保存的图标URL应用到主屏幕的App图标上
         */
        function applyAppIcons() {
          if (!state.globalSettings.appIcons) return;

          for (const iconId in state.globalSettings.appIcons) {
            const imgElement = document.getElementById(`icon-img-${iconId}`);
            if (imgElement) {
              imgElement.src = state.globalSettings.appIcons[iconId];
            }
          }
        }

        /**
         * 【全新】在外观设置页面渲染出所有App图标的设置项
         */
        function renderIconSettings() {
          const grid = document.getElementById("icon-settings-grid");
          if (!grid) return;
          grid.innerHTML = "";

          const appLabels = {
            "world-book": "世界书",
            qq: "QQ",
            "api-settings": "API设置",
            wallpaper: "壁纸",
            font: "字体",
          };

          for (const iconId in state.globalSettings.appIcons) {
            const iconUrl = state.globalSettings.appIcons[iconId];
            const labelText = appLabels[iconId] || "未知App";

            const item = document.createElement("div");
            item.className = "icon-setting-item";
            // 【重要】我们用 data-icon-id 来标记这个设置项对应哪个图标
            item.dataset.iconId = iconId;

            item.innerHTML = `
                  <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
                  <button class="change-icon-btn">更换</button>
              `;
            grid.appendChild(item);
          }
        }

        /**
         * 当用户点击链接卡片时，打开伪浏览器
         * @param {number} timestamp - 被点击消息的时间戳
         */
        function openBrowser(timestamp) {
          if (!state.activeChatId) return;

          const chat = state.chats[state.activeChatId];
          // 安全检查，确保 chat 和 history 都存在
          if (!chat || !chat.history) return;

          const message = chat.history.find((m) => m.timestamp === timestamp);
          if (!message || message.type !== "share_link") {
            console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
            return; // 如果找不到消息，就直接退出
          }

          // 填充浏览器内容
          document.getElementById("browser-title").textContent =
            message.source_name || "文章详情";
          const browserContent = document.getElementById("browser-content");
          browserContent.innerHTML = `
              <h1 class="article-title">${message.title || "无标题"}</h1>
              <div class="article-meta">
                  <span>来源: ${message.source_name || "未知"}</span>
              </div>
              <div class="article-body">
                  <p>${(message.content || "内容为空。").replace(
                    /\n/g,
                    "</p><p>",
                  )}</p>
              </div>
          `;

          // 显示浏览器屏幕
          showScreen("browser-screen");
        }

        /**
         * 关闭伪浏览器，返回聊天界面
         * (这个函数现在由 init() 中的事件监听器调用)
         */
        function closeBrowser() {
          showScreen("chat-interface-screen");
        }

        /**
         * 打开让用户填写链接信息的模态框
         */
        function openShareLinkModal() {
          if (!state.activeChatId) return;

          // 清空上次输入的内容
          document.getElementById("link-title-input").value = "";
          document.getElementById("link-description-input").value = "";
          document.getElementById("link-source-input").value = "";
          document.getElementById("link-content-input").value = "";

          // 显示模态框
          document.getElementById("share-link-modal").classList.add("visible");
        }

        /**
         * 用户确认分享，创建并发送链接卡片消息
         */
        async function sendUserLinkShare() {
          if (!state.activeChatId) return;

          const title = document
            .getElementById("link-title-input")
            .value.trim();
          if (!title) {
            alert("标题是必填项哦！");
            return;
          }

          const description = document
            .getElementById("link-description-input")
            .value.trim();
          const sourceName = document
            .getElementById("link-source-input")
            .value.trim();
          const content = document
            .getElementById("link-content-input")
            .value.trim();

          const chat = state.chats[state.activeChatId];

          // 创建消息对象
          const linkMessage = {
            role: "user", // 角色是 'user'
            type: "share_link",
            timestamp: Date.now(),
            title: title,
            description: description,
            source_name: sourceName,
            content: content,
            // 用户分享的链接，我们不提供图片，让它总是显示占位图
            thumbnail_url: null,
          };

          // 将消息添加到历史记录
          chat.history.push(linkMessage);
          await db.chats.put(chat);

          // 渲染新消息并更新列表
          appendMessage(linkMessage, chat);
          renderChatList();

          // 关闭模态框
          document
            .getElementById("share-link-modal")
            .classList.remove("visible");
        }

        /**
         * 根据AI的视角，过滤出它能看到的动态
         * @param {Array} allPosts - 所有待检查的动态帖子
         * @param {object} viewerChat - 正在“看”动态的那个AI的chat对象
         * @returns {Array} - 过滤后该AI可见的动态帖子
         */
        function filterVisiblePostsForAI(allPosts, viewerChat) {
          if (!viewerChat || !viewerChat.id) return []; // 安全检查

          const viewerGroupId = viewerChat.groupId; // 查看者所在的分组ID

          return allPosts.filter((post) => {
            // 规则1：如果是用户发的动态
            if (post.authorId === "user") {
              // 如果用户设置了“部分可见”
              if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                return (
                  viewerGroupId && post.visibleGroupIds.includes(viewerGroupId)
                );
              }
              // 如果用户没设置，说明是公开的，所有AI都可见
              return true;
            }

            // 规则2：如果是其他AI发的动态
            const authorGroupId = post.authorGroupId; // 发帖AI所在的分组ID

            // 如果发帖的AI没有分组，那它的动态就是公开的
            if (!authorGroupId) {
              return true;
            }

            // 如果发帖的AI有分组，那么只有在同一个分组的AI才能看到
            return authorGroupId === viewerGroupId;
          });
        }

        /**
         * 应用指定的主题（'light' 或 'dark'）
         * @param {string} theme - 要应用的主题名称
         */
        function applyTheme(theme) {
          const phoneScreen = document.getElementById("phone-screen");
          const toggleSwitch = document.getElementById("theme-toggle-switch");

        const isDark = theme === "dark";

        phoneScreen.classList.toggle("dark-mode", isDark);
        document.body.classList.toggle("dark-mode", isDark);
        document.documentElement.classList.toggle("dark-mode", isDark);

          // 如果开关存在，就同步它的状态
          if (toggleSwitch) {
            toggleSwitch.checked = isDark;
          }

          localStorage.setItem("ephone-theme", theme);
        }

        function applyPhoneSizePanelVisibility(show) {
          const panel = document.getElementById("phone-size-control-panel");
          if (panel) {
            panel.style.display = show ? "block" : "none";
            
            // === 新增：同步到 localStorage ===
            localStorage.setItem('ephone-panel-visibility', JSON.stringify({
              showPhoneSizePanel: show
            }));
            
            // 移除预加载时添加的临时样式
            const preloadStyle = document.getElementById('preload-panel-hidden');
            if (preloadStyle) {
              preloadStyle.remove();
            }
          }
        }

        /**
         * 切换当前的主题
         */
        function toggleTheme() {
          const toggleSwitch = document.getElementById("theme-toggle-switch");
          // 直接根据开关的选中状态来决定新主题
          const newTheme = toggleSwitch.checked ? "dark" : "light";
          applyTheme(newTheme);
        }

        function startReplyToMessage() {
          if (!activeMessageTimestamp) return;

          const chat = state.chats[state.activeChatId];
          const message = chat.history.find(
            (m) => m.timestamp === activeMessageTimestamp,
          );
          if (!message) return;

          // 1. 【核心修正】同时获取“完整内容”和“预览片段”
          const fullContent = String(message.content || "");
          let previewSnippet = "";

          if (
            typeof message.content === "string" &&
            STICKER_REGEX.test(message.content)
          ) {
            previewSnippet = "[表情]";
          } else if (
            message.type === "ai_image" ||
            message.type === "user_photo"
          ) {
            previewSnippet = "[图片]";
          } else if (message.type === "voice_message") {
            previewSnippet = "[语音]";
          } else {
            // 预览片段依然截断，但只用于UI显示
            previewSnippet =
              fullContent.substring(0, 50) +
              (fullContent.length > 50 ? "..." : "");
          }

          // 2. 【核心修正】将“完整内容”存入上下文，以备发送时使用
          currentReplyContext = {
            timestamp: message.timestamp,
            senderName:
              message.senderName ||
              (message.role === "user"
                ? chat.settings.myNickname || "我"
                : chat.name),
            content: fullContent, // <--- 这里存的是完整的原文！
          };

          // 3. 【核心修正】仅在更新“回复预览栏”时，才使用“预览片段”
          const previewBar = document.getElementById("reply-preview-bar");
          previewBar.querySelector(".sender").textContent =
            `回复 ${currentReplyContext.senderName}:`;
          previewBar.querySelector(".text").textContent = previewSnippet; // <--- 这里用的是缩略版！
          previewBar.style.display = "block";

          // 4. 后续操作保持不变
          hideMessageActions();
          document.getElementById("chat-input").focus();
        }

        /**
         * 【全新】取消引用模式
         */
        function cancelReplyMode() {
          currentReplyContext = null;
          document.getElementById("reply-preview-bar").style.display = "none";
        }

        let activeTransferTimestamp = null; // 用于暂存被点击的转账消息的时间戳

        /**
         * 显示处理转账的操作菜单
         * @param {number} timestamp - 被点击的转账消息的时间戳
         */
        function showTransferActionModal(timestamp) {
          activeTransferTimestamp = timestamp;

          const chat = state.chats[state.activeChatId];
          const message = chat.history.find((m) => m.timestamp === timestamp);
          if (message) {
            // 将AI的名字填入弹窗
            document.getElementById("transfer-sender-name").textContent =
              message.senderName;
          }
          document
            .getElementById("transfer-actions-modal")
            .classList.add("visible");
        }

        /**
         * 隐藏处理转账的操作菜单
         */
        function hideTransferActionModal() {
          document
            .getElementById("transfer-actions-modal")
            .classList.remove("visible");
          activeTransferTimestamp = null;
        }

        /**
         * 处理用户接受或拒绝转账的逻辑
         * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
         */
        async function handleUserTransferResponse(choice) {
          if (!activeTransferTimestamp) return;

          const timestamp = activeTransferTimestamp;
          const chat = state.chats[state.activeChatId];
          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === timestamp,
          );
          if (messageIndex === -1) return;

          // 1. 更新原始转账消息的状态
          const originalMessage = chat.history[messageIndex];
          originalMessage.status = choice;

          let systemContent;

          // 2. 如果用户选择“拒绝”
          if (choice === "declined") {
            // 立刻在前端生成一个“退款”卡片，让用户看到
            const refundMessage = {
              role: "user",
              type: "transfer",
              isRefund: true, // 这是一个关键标记，用于UI显示这是退款
              amount: originalMessage.amount,
              note: "已拒收对方转账",
              timestamp: Date.now(),
            };
            chat.history.push(refundMessage);

            // 准备一条对AI可见的隐藏消息，告诉它发生了什么
            systemContent = `[系统提示：你拒绝并退还了“${originalMessage.senderName}”的转账。]`;
          } else {
            // 如果用户选择“接受”
            // 只需准备隐藏消息通知AI即可
            systemContent = `[系统提示：你接受了“${originalMessage.senderName}”的转账。]`;
          }

          // 3. 创建这条对用户隐藏、但对AI可见的系统消息
          const hiddenMessage = {
            role: "system",
            content: systemContent,
            timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
            isHidden: true, // 这个标记会让它不在聊天界面显示
          };
          chat.history.push(hiddenMessage);

          // 4. 保存所有更改到数据库，并刷新界面
          await db.chats.put(chat);
          hideTransferActionModal();
          renderChatInterface(state.activeChatId);
          renderChatList();
        }

        async function renderCallHistoryScreen() {
          showScreen("call-history-screen"); // <--【核心修正】把它移动到最前面！

          const listEl = document.getElementById("call-history-list");
          const titleEl = document.getElementById("call-history-title");
          listEl.innerHTML = "";
          titleEl.textContent = "所有通话记录";

          const records = await db.callRecords
            .orderBy("timestamp")
            .reverse()
            .toArray();

          if (records.length === 0) {
            listEl.innerHTML =
              '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有通话记录哦~</p>';
            return; // 现在的 return 就没问题了，因为它只跳过了后续的渲染逻辑
          }

          records.forEach((record) => {
            const card = createCallRecordCard(record);

            addLongPressListener(card, async () => {
              // 1. 弹出输入框，并将旧名称作为默认值，方便修改
              const newName = await showCustomPrompt(
                "自定义通话名称",
                "请输入新的名称（留空则恢复默认）",
                record.customName || "", // 如果已有自定义名称，就显示它
              );

              // 2. 如果用户点击了“取消”，则什么都不做
              if (newName === null) return;

              // 3. 更新数据库中的这条记录
              await db.callRecords.update(record.id, {
                customName: newName.trim(),
              });

              // 4. 刷新整个列表，让更改立刻显示出来
              await renderCallHistoryScreen();

              // 5. 给用户一个成功的提示
              await showCustomAlert("成功", "通话名称已更新！");
            });
            listEl.appendChild(card);
          });
        }

        /**
         * 【升级版】根据单条记录数据，创建一张能显示聊天对象的通话卡片
         * @param {object} record - 一条通话记录对象
         * @returns {HTMLElement} - 创建好的卡片div
         */
        function createCallRecordCard(record) {
          const card = document.createElement("div");
          card.className = "call-record-card";
          card.dataset.recordId = record.id;

          // 获取通话对象的名字
          const chatInfo = state.chats[record.chatId];
          const chatName = chatInfo ? chatInfo.name : "未知会话";

          const callDate = new Date(record.timestamp);
          const dateString = `${callDate.getFullYear()}-${String(
            callDate.getMonth() + 1,
          ).padStart(2, "0")}-${String(callDate.getDate()).padStart(
            2,
            "0",
          )} ${String(callDate.getHours()).padStart(2, "0")}:${String(
            callDate.getMinutes(),
          ).padStart(2, "0")}`;
          const durationText = `${Math.floor(record.duration / 60)}分${
            record.duration % 60
          }秒`;

          const avatarsHtml = record.participants
            .map(
              (p) =>
                `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`,
            )
            .join("");

          card.innerHTML = `
              <div class="card-header">
                  <span class="date">${dateString}</span>
                  <span class="duration">${durationText}</span>
              </div>
              <div class="card-body">
                  <!-- 【核心修改】在这里新增一个标题行 -->
                  ${
                    record.customName
                      ? `<div class="custom-title">${record.customName}</div>`
                      : ""
                  }

                  <div class="participants-info"> <!-- 新增一个容器方便布局 -->
                      <div class="participants-avatars">${avatarsHtml}</div>
                      <span class="participants-names">与 ${chatName}</span>
                  </div>
              </div>
          `;
          return card;
        }

        /**
         * 显示指定通话记录的完整文字稿
         * @param {number} recordId - 通话记录的ID
         */
        async function showCallTranscript(recordId) {
          const record = await db.callRecords.get(recordId);
          if (!record) return;

          const modal = document.getElementById("call-transcript-modal");
          const titleEl = document.getElementById("transcript-modal-title");
          const bodyEl = document.getElementById("transcript-modal-body");

          titleEl.textContent = `通话于 ${new Date(
            record.timestamp,
          ).toLocaleString()} (时长: ${Math.floor(record.duration / 60)}分${
            record.duration % 60
          }秒)`;
          bodyEl.innerHTML = "";

          if (!record.transcript || record.transcript.length === 0) {
            bodyEl.innerHTML =
              '<p style="text-align:center; color: #8a8a8a;">这次通话没有留下文字记录。</p>';
          } else {
            record.transcript.forEach((entry) => {
              const bubble = document.createElement("div");
              // 根据角色添加不同的class，应用不同的样式
              bubble.className = `transcript-entry ${entry.role}`;
              bubble.textContent = entry.content;
              bodyEl.appendChild(bubble);
            });
          }

          const deleteBtn = document.getElementById("delete-transcript-btn");

          // 【重要】使用克隆节点技巧，防止事件重复绑定
          const newDeleteBtn = deleteBtn.cloneNode(true);
          deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);

          // 为新的、干净的按钮绑定事件
          newDeleteBtn.addEventListener("click", async () => {
            const confirmed = await showCustomConfirm(
              "确认删除",
              "确定要永久删除这条通话记录吗？此操作不可恢复。",
              { confirmButtonClass: "btn-danger" },
            );

            if (confirmed) {
              // 1. 关闭当前的详情弹窗
              modal.classList.remove("visible");

              // 2. 从数据库删除
              await db.callRecords.delete(recordId);

              // 3. 刷新通话记录列表
              await renderCallHistoryScreen();

              // 4. (可选) 给出成功提示
              alert("通话记录已删除。");
            }
          });
          modal.classList.add("visible");
        }

        /**
         * 【全新】处理用户点击状态栏，弹出编辑框让用户修改AI的当前状态
         */
        async function handleEditStatusClick() {
          // 1. 安全检查，确保在单聊界面
          if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
            return;
          }
          const chat = state.chats[state.activeChatId];

          // 2. 弹出输入框，让用户输入新的状态，并将当前状态作为默认值
          const newStatusText = await showCustomPrompt(
            "编辑对方状态",
            "请输入对方现在的新状态：",
            chat.status.text, // 将当前状态作为输入框的默认内容
          );

          // 3. 如果用户输入了内容并点击了“确定”
          if (newStatusText !== null) {
            // 4. 更新内存和数据库中的状态数据
            chat.status.text = newStatusText.trim() || "在线"; // 如果用户清空了，就默认为“在线”
            chat.status.isBusy = false; // 每次手动编辑都默认其不处于“忙碌”状态
            chat.status.lastUpdate = Date.now();
            await db.chats.put(chat);

            // 5. 立刻刷新UI，让用户看到修改后的状态
            renderChatInterface(state.activeChatId);
            renderChatList();

            // 6. 给出一个无伤大雅的成功提示
            await showCustomAlert(
              "状态已更新",
              `“${chat.name}”的当前状态已更新为：${chat.status.text}`,
            );
          }
        }

        // 放在你的JS功能函数定义区
        async function openShareTargetPicker() {
          const modal = document.getElementById("share-target-modal");
          const listEl = document.getElementById("share-target-list");
          listEl.innerHTML = "";

          // 获取所有聊天作为分享目标
          const chats = Object.values(state.chats);

          chats.forEach((chat) => {
            // 复用联系人选择器的样式
            const item = document.createElement("div");
            item.className = "contact-picker-item";
            item.innerHTML = `
                  <input type="checkbox" class="share-target-checkbox" data-chat-id="${
                    chat.id
                  }" style="margin-right: 15px;">
                  <img src="${
                    chat.isGroup
                      ? chat.settings.groupAvatar
                      : chat.settings.aiAvatar || defaultAvatar
                  }" class="avatar">
                  <span class="name">${chat.name}</span>
              `;
            listEl.appendChild(item);
          });

          modal.classList.add("visible");
        }

        function closeMusicPlayerWithAnimation(callback) {
          const overlay = document.getElementById("music-player-overlay");
          if (!overlay.classList.contains("visible")) {
            if (callback) callback();
            return;
          }
          overlay.classList.remove("visible");
          setTimeout(() => {
            document
              .getElementById("music-playlist-panel")
              .classList.remove("visible");
            if (callback) callback();
          }, 400);
        }

        function parseLRC(lrcContent) {
          if (!lrcContent) return [];
          const lines = lrcContent.split("\n");
          const lyrics = [];
          const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;

          for (const line of lines) {
            const text = line.replace(timeRegex, "").trim();
            if (!text) continue;
            timeRegex.lastIndex = 0;
            let match;
            while ((match = timeRegex.exec(line)) !== null) {
              const minutes = parseInt(match[1], 10);
              const seconds = parseInt(match[2], 10);
              const milliseconds = parseInt(match[3].padEnd(3, "0"), 10);
              const time = minutes * 60 + seconds + milliseconds / 1000;
              lyrics.push({ time, text });
            }
          }
          return lyrics.sort((a, b) => a.time - b.time);
        }

        function renderLyrics() {
          const lyricsList = document.getElementById("music-lyrics-list");
          lyricsList.innerHTML = "";
          if (
            !musicState.parsedLyrics ||
            musicState.parsedLyrics.length === 0
          ) {
            lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
            return;
          }
          musicState.parsedLyrics.forEach((line, index) => {
            const lineEl = document.createElement("div");
            lineEl.className = "lyric-line";
            lineEl.textContent = line.text;
            lineEl.dataset.index = index;
            lyricsList.appendChild(lineEl);
          });
          lyricsList.style.transform = `translateY(0px)`;
        }

        function updateActiveLyric(currentTime) {
          if (musicState.parsedLyrics.length === 0) return;
          let newLyricIndex = -1;
          for (let i = 0; i < musicState.parsedLyrics.length; i++) {
            if (currentTime >= musicState.parsedLyrics[i].time) {
              newLyricIndex = i;
            } else {
              break;
            }
          }
          if (newLyricIndex === musicState.currentLyricIndex) return;
          musicState.currentLyricIndex = newLyricIndex;
          updateLyricsUI();
        }

        function updateLyricsUI() {
          const lyricsList = document.getElementById("music-lyrics-list");
          const container = document.getElementById("music-lyrics-container");
          const lines = lyricsList.querySelectorAll(".lyric-line");
          lines.forEach((line) => line.classList.remove("active"));
          if (musicState.currentLyricIndex === -1) {
            lyricsList.style.transform = `translateY(0px)`;
            return;
          }
          const activeLine = lyricsList.querySelector(
            `.lyric-line[data-index="${musicState.currentLyricIndex}"]`,
          );
          if (activeLine) {
            activeLine.classList.add("active");
            const containerHeight = container.offsetHeight;
            const offset =
              containerHeight / 3 -
              activeLine.offsetTop -
              activeLine.offsetHeight / 2;
            lyricsList.style.transform = `translateY(${offset}px)`;
          }
        }

        function formatMusicTime(seconds) {
          if (isNaN(seconds) || seconds < 0) return "0:00";
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = Math.floor(seconds % 60);
          return `${minutes}:${String(remainingSeconds).padStart(2, "0")}`;
        }

        function updateMusicProgressBar() {
          const currentTimeEl = document.getElementById("music-current-time");
          const totalTimeEl = document.getElementById("music-total-time");
          const progressFillEl = document.getElementById("music-progress-fill");
          if (!audioPlayer.duration) {
            currentTimeEl.textContent = "0:00";
            totalTimeEl.textContent = "0:00";
            progressFillEl.style.width = "0%";
            return;
          }
          const progressPercent =
            (audioPlayer.currentTime / audioPlayer.duration) * 100;
          progressFillEl.style.width = `${progressPercent}%`;
          currentTimeEl.textContent = formatMusicTime(audioPlayer.currentTime);
          totalTimeEl.textContent = formatMusicTime(audioPlayer.duration);
          updateActiveLyric(audioPlayer.currentTime);
        }

        /**
         * 【全新】处理用户点击“撤回”按钮的入口函数
         */
        async function handleRecallClick() {
          if (!activeMessageTimestamp) return;

          const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 设置2分钟的撤回时限
          const messageTime = activeMessageTimestamp;
          const now = Date.now();

          // 检查是否超过了撤回时限
          if (now - messageTime > RECALL_TIME_LIMIT_MS) {
            hideMessageActions();
            await showCustomAlert(
              "操作失败",
              "该消息发送已超过2分钟，无法撤回。",
            );
            return;
          }

          // 如果在时限内，执行真正的撤回逻辑
          await recallMessage(messageTime, true);
          hideMessageActions();
        }

        /**
         * 【全新】消息撤回的核心逻辑
         * @param {number} timestamp - 要撤回的消息的时间戳
         * @param {boolean} isUserRecall - 是否是用户主动撤回
         */
        async function recallMessage(timestamp, isUserRecall) {
          const chat = state.chats[state.activeChatId];
          if (!chat) return;

          const messageIndex = chat.history.findIndex(
            (m) => m.timestamp === timestamp,
          );
          if (messageIndex === -1) return;

          const messageToRecall = chat.history[messageIndex];

          // 1. 修改消息对象，将其变为“已撤回”状态
          const recalledData = {
            originalType: messageToRecall.type || "text",
            originalContent: messageToRecall.content,
            // 保存其他可能存在的原始数据
            originalMeaning: messageToRecall.meaning,
            originalQuote: messageToRecall.quote,
          };

          messageToRecall.type = "recalled_message";
          messageToRecall.content = isUserRecall
            ? "你撤回了一条消息"
            : "对方撤回了一条消息";
          messageToRecall.recalledData = recalledData;
          // 清理掉不再需要的旧属性
          delete messageToRecall.meaning;
          delete messageToRecall.quote;

          // 2. 如果是用户撤回，需要给AI发送一条它看不懂内容的隐藏提示
          if (isUserRecall) {
            const hiddenMessageForAI = {
              role: "system",
              content: `[系统提示：用户撤回了一条消息。你不知道内容是什么，只需知道这个事件即可。]`,
              timestamp: Date.now(),
              isHidden: true,
            };
            chat.history.push(hiddenMessageForAI);
          }

          // 3. 保存到数据库并刷新UI
          await db.chats.put(chat);
          renderChatInterface(state.activeChatId);
          if (isUserRecall) renderChatList(); // 用户撤回时，最后一条消息变了，需要刷新列表
        }

        /**
         * 打开分类管理模态框
         */
        async function openCategoryManager() {
          await renderCategoryListInManager();
          document
            .getElementById("world-book-category-manager-modal")
            .classList.add("visible");
        }

        /**
         * 在模态框中渲染已存在的分类列表
         */
        async function renderCategoryListInManager() {
          const listEl = document.getElementById("existing-categories-list");
          const categories = await db.worldBookCategories.toArray();
          listEl.innerHTML = "";
          if (categories.length === 0) {
            listEl.innerHTML =
              '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
          }
          categories.forEach((cat) => {
            // 复用好友分组的样式
            const item = document.createElement("div");
            item.className = "existing-group-item";
            item.innerHTML = `
                  <span class="group-name">${cat.name}</span>
                  <span class="delete-group-btn" data-id="${cat.id}">×</span>
              `;
            listEl.appendChild(item);
          });
        }

        /**
         * 添加一个新的世界书分类
         */
        async function addNewCategory() {
          const input = document.getElementById("new-category-name-input");
          const name = input.value.trim();
          if (!name) {
            alert("分类名不能为空！");
            return;
          }
          const existing = await db.worldBookCategories
            .where("name")
            .equals(name)
            .first();
          if (existing) {
            alert(`分类 "${name}" 已经存在了！`);
            return;
          }
          await db.worldBookCategories.add({ name });
          input.value = "";
          await renderCategoryListInManager();
        }

        /**
         * 删除一个世界书分类
         * @param {number} categoryId - 要删除的分类的ID
         */
        async function deleteCategory(categoryId) {
          const confirmed = await showCustomConfirm(
            "确认删除",
            "删除分类后，该分类下的所有世界书将变为“未分类”。确定要删除吗？",
            { confirmButtonClass: "btn-danger" },
          );
          if (confirmed) {
            await db.worldBookCategories.delete(categoryId);
            // 将属于该分类的世界书的 categoryId 设为 null
            const booksToUpdate = await db.worldBooks
              .where("categoryId")
              .equals(categoryId)
              .toArray();
            for (const book of booksToUpdate) {
              book.categoryId = null;
              await db.worldBooks.put(book);
              const bookInState = state.worldBooks.find(
                (wb) => wb.id === book.id,
              );
              if (bookInState) bookInState.categoryId = null;
            }
            await renderCategoryListInManager();
          }
        }

        // ===================================================================
        // 4. 初始化函数 init()
        // ===================================================================
        async function init() {
          const savedTheme = localStorage.getItem("ephone-theme") || "light"; // 默认为日间模式
          applyTheme(savedTheme);

          const customBubbleStyleTag = document.createElement("style");
          customBubbleStyleTag.id = "custom-bubble-style";
          document.head.appendChild(customBubbleStyleTag);

          const previewBubbleStyleTag = document.createElement("style");
          previewBubbleStyleTag.id = "preview-bubble-style";
          document.head.appendChild(previewBubbleStyleTag);

          applyScopedCss("", "#chat-messages", "custom-bubble-style"); // 清除真实聊天界面的自定义样式
          applyScopedCss("", "#settings-preview-area", "preview-bubble-style"); // 清除预览区的自定义样式

          window.showScreen = showScreen;
          window.renderChatListProxy = renderChatList;
          window.renderApiSettingsProxy = renderApiSettings;
          window.renderWallpaperScreenProxy = renderWallpaperScreen;
          window.renderWorldBookScreenProxy = renderWorldBookScreen;

          await loadAllDataFromDB();

          // 初始化未读动态计数
          const storedCount =
            parseInt(localStorage.getItem("unreadPostsCount")) || 0;
          updateUnreadIndicator(storedCount);

          if (state.globalSettings && state.globalSettings.fontUrl) {
            applyCustomFont(state.globalSettings.fontUrl);
          }

          updateClock();
          setInterval(updateClock, 1000 * 30);
          applyGlobalWallpaper();
          initBatteryManager();

          applyAppIcons();

          state.globalSettings = state.globalSettings || {};
          state.globalSettings.showSizePanel =
            state.globalSettings.showSizePanel ?? false;
          applyPhoneSizePanelVisibility(state.globalSettings.showSizePanel);
          const screenWidthInput = document.getElementById(
            "screen-width-input",
          );
          const screenHeightInput = document.getElementById(
            "screen-height-input",
          );
          const phoneOffsetInput = document.getElementById(
            "phone-offset-input",
          );
          const screenWidthValue = document.getElementById(
            "screen-width-value",
          );
          const screenHeightValue = document.getElementById(
            "screen-height-value",
          );
          const phoneOffsetValue = document.getElementById(
            "phone-offset-value",
          );
          const resetPhoneSizeBtn = document.getElementById(
            "reset-phone-size-btn",
          );

          const screenWidth =
            state.globalSettings.screenWidth !== undefined
              ? state.globalSettings.screenWidth
              : 365;
          const screenHeight =
            state.globalSettings.screenHeight !== undefined
              ? state.globalSettings.screenHeight
              : 680;
          const phoneOffset =
            state.globalSettings.phoneOffset !== undefined
              ? state.globalSettings.phoneOffset
              : 15;

          document.documentElement.style.setProperty(
            "--screen-width",
            `${screenWidth}px`,
          );
          document.documentElement.style.setProperty(
            "--screen-height",
            `${screenHeight}px`,
          );
          document.documentElement.style.setProperty(
            "--phone-offset",
            `${phoneOffset}px`,
          );

          if (screenWidthInput) {
            screenWidthInput.value = screenWidth;
            if (screenWidthValue) {
              screenWidthValue.textContent = `${screenWidth}px`;
            }
          }
          if (screenHeightInput) {
            screenHeightInput.value = screenHeight;
            if (screenHeightValue) {
              screenHeightValue.textContent = `${screenHeight}px`;
            }
          }
          if (phoneOffsetInput) {
            phoneOffsetInput.value = phoneOffset;
            if (phoneOffsetValue) {
              phoneOffsetValue.textContent = `${phoneOffset}px`;
            }
          }

          // ==========================================================
          // --- 各种事件监听器 ---
          // ==========================================================

          document
            .getElementById("custom-modal-cancel")
            .addEventListener("click", hideCustomModal);
          document
            .getElementById("custom-modal-overlay")
            .addEventListener("click", (e) => {
              if (e.target === modalOverlay) hideCustomModal();
            });
          document
            .getElementById("export-data-btn")
            .addEventListener("click", exportBackup);
          document
            .getElementById("import-btn")
            .addEventListener("click", () =>
              document.getElementById("import-data-input").click(),
            );
          document
            .getElementById("import-data-input")
            .addEventListener("change", (e) => importBackup(e.target.files[0]));
          document
            .getElementById("back-to-list-btn")
            .addEventListener("click", () => {
              applyScopedCss("", "#chat-messages", "custom-bubble-style"); // 清除真实聊天界面的自定义样式
              applyScopedCss(
                "",
                "#settings-preview-area",
                "preview-bubble-style",
              ); // 清除预览区的自定义样式

              exitSelectionMode();
              state.activeChatId = null;
              showScreen("chat-list-screen");
            });

          document
            .getElementById("add-chat-btn")
            .addEventListener("click", async () => {
              const name = await showCustomPrompt(
                "创建新聊天",
                "请输入Ta的名字",
              );
              if (name && name.trim()) {
                const newChatId = "chat_" + Date.now();
                const newChat = {
                  id: newChatId,
                  name: name.trim(),
                  isGroup: false,
                  relationship: {
                    status: "friend", // 'friend', 'blocked_by_user', 'pending_user_approval'
                    blockedTimestamp: null,
                    applicationReason: "",
                  },
                  status: {
                    text: "在线",
                    lastUpdate: Date.now(),
                    isBusy: false,
                  },
                  settings: {
                    aiPersona: "你是谁呀。",
                    myPersona: "我是谁呀。",
                    maxMemory: 10,
                    aiAvatar: defaultAvatar,
                    myAvatar: defaultAvatar,
                    background: "",
                    theme: "default",
                    fontSize: 13,
                    customCss: "", // <--- 新增这行
                    linkedWorldBookIds: [],
                    aiAvatarLibrary: [],
                    summary: {
                      enabled: false,
                      mode: "manual",
                      count: 50,
                      prompt:
                        "请总结上述对话的主要内容，保留重要信息和情感脉络。",
                      lastSummaryIndex: -1,
                    },
                  },
                  history: [],
                  musicData: { totalTime: 0 },
                };
                state.chats[newChatId] = newChat;
                await db.chats.put(newChat);
                renderChatList();
              }
            });

          document
            .getElementById("add-group-chat-btn")
            .addEventListener("click", openContactPickerForGroupCreate);
          document
            .getElementById("transfer-cancel-btn")
            .addEventListener("click", () =>
              document
                .getElementById("transfer-modal")
                .classList.remove("visible"),
            );
          document
            .getElementById("transfer-confirm-btn")
            .addEventListener("click", sendUserTransfer);

          document
            .getElementById("listen-together-btn")
            .addEventListener("click", handleListenTogetherClick);
          document
            .getElementById("music-exit-btn")
            .addEventListener("click", () => endListenTogetherSession(true));
          document
            .getElementById("music-return-btn")
            .addEventListener("click", returnToChat);
          document
            .getElementById("music-play-pause-btn")
            .addEventListener("click", togglePlayPause);
          document
            .getElementById("music-next-btn")
            .addEventListener("click", playNext);
          document
            .getElementById("music-prev-btn")
            .addEventListener("click", playPrev);
          document
            .getElementById("music-mode-btn")
            .addEventListener("click", changePlayMode);
          document
            .getElementById("music-playlist-btn")
            .addEventListener("click", () => {
              updatePlaylistUI();
              document
                .getElementById("music-playlist-panel")
                .classList.add("visible");
            });
          document
            .getElementById("close-playlist-btn")
            .addEventListener("click", () =>
              document
                .getElementById("music-playlist-panel")
                .classList.remove("visible"),
            );
          document
            .getElementById("add-song-url-btn")
            .addEventListener("click", addSongFromURL);
          document
            .getElementById("add-song-local-btn")
            .addEventListener("click", () =>
              document.getElementById("local-song-upload-input").click(),
            );
          document
            .getElementById("local-song-upload-input")
            .addEventListener("change", addSongFromLocal);
          audioPlayer.addEventListener("ended", playNext);
          audioPlayer.addEventListener("pause", () => {
            if (musicState.isActive) {
              musicState.isPlaying = false;
              updatePlayerUI();
            }
          });
          audioPlayer.addEventListener("play", () => {
            if (musicState.isActive) {
              musicState.isPlaying = true;
              updatePlayerUI();
            }
          });

          const chatInput = document.getElementById("chat-input");
          document
            .getElementById("send-btn")
            .addEventListener("click", async () => {
              const content = chatInput.value.trim();
              if (!content || !state.activeChatId) return;

              const chat = state.chats[state.activeChatId];

              // --- 【核心修改】在这里添加 ---
              const msg = {
                role: "user",
                content,
                timestamp: Date.now(),
              };

              // 检查当前是否处于引用回复模式
              if (currentReplyContext) {
                msg.quote = currentReplyContext; // 将引用信息附加到消息对象上
              }
              // --- 【修改结束】 ---

              chat.history.push(msg);
              await db.chats.put(chat);
              // 触发总结检查
              try {
                await checkAndTriggerSummary(chat.id);
              } catch (summaryError) {
                console.error(
                  "Failed to trigger chat summary after user message:",
                  summaryError,
                );
              }
              appendMessage(msg, chat);
              renderChatList();
              chatInput.value = "";
              chatInput.style.height = "auto";
              chatInput.focus();

              // --- 【核心修改】发送后，取消引用模式 ---
              cancelReplyMode();
            });
          document
            .getElementById("wait-reply-btn")
            .addEventListener("click", triggerAiResponse);
          chatInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              document.getElementById("send-btn").click();
            }
          });
          chatInput.addEventListener("input", () => {
            chatInput.style.height = "auto";
            chatInput.style.height = chatInput.scrollHeight + "px";
          });

          const frameColorInput = document.getElementById("frame-color-input");
          const frameColorValue = document.getElementById("frame-color-value");

          frameColorInput.addEventListener("input", (e) => {
            frameColorValue.textContent = e.target.value;
            // 实时预览：直接修改DOM，但不保存
            document.getElementById("phone-frame").style.backgroundColor =
              e.target.value;
          });

          document
            .getElementById("reset-frame-color-btn")
            .addEventListener("click", () => {
              // 重置为默认值（这里假设默认白色，实际保存时为空字符串让CSS生效）
              frameColorInput.value = "#ffffff";
              frameColorValue.textContent = "#ffffff";
              document.getElementById("phone-frame").style.backgroundColor = ""; // 清除内联样式
            });

          if (screenWidthInput) {
            screenWidthInput.addEventListener("input", (e) => {
              const value = parseInt(e.target.value, 10);
              document.documentElement.style.setProperty(
                "--screen-width",
                `${value}px`,
              );
              if (screenWidthValue) {
                screenWidthValue.textContent = `${value}px`;
              }
              state.globalSettings.screenWidth = value;
              db.globalSettings.put({ id: 1, ...state.globalSettings });

              // 同步布局缓存到 localStorage
              try {
                  const cache = JSON.parse(localStorage.getItem('ephone-layout-cache') || '{}');
                  cache.screenWidth = value;
                  localStorage.setItem('ephone-layout-cache', JSON.stringify(cache));
              } catch(e) { console.warn('Layout cache error', e); }
            });
          }
          if (screenHeightInput) {
            screenHeightInput.addEventListener("input", (e) => {
              const value = parseInt(e.target.value, 10);
              document.documentElement.style.setProperty(
                "--screen-height",
                `${value}px`,
              );
              if (screenHeightValue) {
                screenHeightValue.textContent = `${value}px`;
              }
              state.globalSettings.screenHeight = value;
              db.globalSettings.put({ id: 1, ...state.globalSettings });

              // 同步布局缓存到 localStorage
              try {
                  const cache = JSON.parse(localStorage.getItem('ephone-layout-cache') || '{}');
                  cache.screenHeight = value;
                  localStorage.setItem('ephone-layout-cache', JSON.stringify(cache));
              } catch(e) { console.warn('Layout cache error', e); }
            });
          }
          if (phoneOffsetInput) {
            phoneOffsetInput.addEventListener("input", (e) => {
              const value = parseInt(e.target.value, 10);
              document.documentElement.style.setProperty(
                "--phone-offset",
                `${value}px`,
              );
              if (phoneOffsetValue) {
                phoneOffsetValue.textContent = `${value}px`;
              }
              state.globalSettings.phoneOffset = value;
              db.globalSettings.put({ id: 1, ...state.globalSettings });

              // 同步布局缓存到 localStorage
              try {
                  const cache = JSON.parse(localStorage.getItem('ephone-layout-cache') || '{}');
                  cache.phoneOffset = value;
                  localStorage.setItem('ephone-layout-cache', JSON.stringify(cache));
              } catch(e) { console.warn('Layout cache error', e); }
            });
          }

          if (resetPhoneSizeBtn) {
            resetPhoneSizeBtn.addEventListener("click", () => {
              const defaultWidth = 365;
              const defaultHeight = 680;
              const defaultOffset = 15;

              document.documentElement.style.setProperty(
                "--screen-width",
                `${defaultWidth}px`,
              );
              document.documentElement.style.setProperty(
                "--screen-height",
                `${defaultHeight}px`,
              );
              document.documentElement.style.setProperty(
                "--phone-offset",
                `${defaultOffset}px`,
              );

              if (screenWidthInput) {
                screenWidthInput.value = defaultWidth;
              }
              if (screenHeightInput) {
                screenHeightInput.value = defaultHeight;
              }
              if (phoneOffsetInput) {
                phoneOffsetInput.value = defaultOffset;
              }
              if (screenWidthValue) {
                screenWidthValue.textContent = `${defaultWidth}px`;
              }
              if (screenHeightValue) {
                screenHeightValue.textContent = `${defaultHeight}px`;
              }
              if (phoneOffsetValue) {
                phoneOffsetValue.textContent = `${defaultOffset}px`;
              }

              state.globalSettings.screenWidth = defaultWidth;
              state.globalSettings.screenHeight = defaultHeight;
              state.globalSettings.phoneOffset = defaultOffset;
              db.globalSettings.put({ id: 1, ...state.globalSettings });

              // 同步布局缓存到 localStorage (Reset)
              try {
                  const cache = {
                      screenWidth: defaultWidth,
                      screenHeight: defaultHeight,
                      phoneOffset: defaultOffset
                  };
                  localStorage.setItem('ephone-layout-cache', JSON.stringify(cache));
              } catch(e) { console.warn('Layout cache error', e); }

              showCustomAlert("提示", "已恢复默认尺寸");
            });
          }

          document
            .getElementById("wallpaper-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res, rej) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.onerror = () => rej(reader.error);
                  reader.readAsDataURL(file);
                });
                newWallpaperBase64 = dataUrl;
                renderWallpaperScreen();
              }
            });
          document
            .getElementById("save-wallpaper-btn")
            .addEventListener("click", async () => {
              let changesMade = false;

              // 保存壁纸
              if (newWallpaperBase64) {
                state.globalSettings.wallpaper = newWallpaperBase64;
                changesMade = true;
              }

              const currentFrameColor = frameColorInput.value;
              // 如果是默认的白色（且不在夜间模式下），或者用户点了重置（我们需要一个标记），
              // 这里简化处理：如果用户选择了颜色，就保存。
              // 为了支持“重置”功能，我们检查 reset 按钮是否刚刚被点击过比较麻烦。
              // 更简单的逻辑：直接保存 input 的值。
              // 但是 reset 按钮清除了 style，input 还是显示 #ffffff。
              // 修正逻辑：如果当前 style.backgroundColor 为空（被重置了），则保存 null。
              // 否则保存 input 的值。
              if (
                document.getElementById("phone-frame").style.backgroundColor ===
                ""
              ) {
                state.globalSettings.phoneFrameColor = null;
              } else {
                state.globalSettings.phoneFrameColor = currentFrameColor;
              }

              // 【核心修改】保存图标设置（它已经在内存中了，我们只需要把整个globalSettings存起来）
              await db.globalSettings.put(state.globalSettings);

              // 应用所有更改
              if (changesMade) {
                applyGlobalWallpaper();
                newWallpaperBase64 = null;
              }
              applyGlobalWallpaper(); // 确保边框颜色被应用（因为 applyGlobalWallpaper 包含了边框逻辑）
              applyAppIcons(); // 重新应用所有图标

              alert("外观设置已保存并应用！");
              showScreen("home-screen");
            });

          // API Config Event Listeners
          document
            .getElementById("add-new-config-btn")
            .addEventListener("click", () => openApiConfigEditor());
          document
            .getElementById("save-config-btn")
            .addEventListener("click", saveApiConfig);
          document
            .getElementById("cancel-config-editor-btn")
            .addEventListener("click", () => {
              document
                .getElementById("api-config-editor-modal")
                .classList.remove("visible");
            });

          document
            .getElementById("api-configs-list")
            .addEventListener("click", async (e) => {
              const target = e.target;
              const item = target.closest(".api-config-item");
              if (!item) return;
              const configId = parseInt(item.dataset.configId);

              if (target.classList.contains("edit-btn")) {
                openApiConfigEditor(configId);
              } else if (target.classList.contains("delete-btn")) {
                const confirmed = await showCustomConfirm(
                  "删除配置",
                  "确定要删除这个API配置吗？",
                  { confirmButtonClass: "btn-danger" },
                );
                if (confirmed) {
                  await db.apiConfigs.delete(configId);
                  state.apiConfigs = state.apiConfigs.filter(
                    (c) => c.id !== configId,
                  );
                  if (state.globalSettings.activeApiConfigId === configId) {
                    state.globalSettings.activeApiConfigId =
                      state.apiConfigs[0]?.id || null;
                    await db.globalSettings.put(state.globalSettings);
                  }
                  renderApiSettings();
                }
              } else if (target.type === "radio") {
                setActiveApiConfig(configId);
              }
            });

          document
            .getElementById("config-fetch-models-btn")
            .addEventListener("click", async () => {
              const url = document
                .getElementById("config-url-input")
                .value.trim();
              const key = document
                .getElementById("config-key-input")
                .value.trim();
              if (!url || !key) return alert("请先填写反代地址和密钥");
              try {
                let isGemini = url === GEMINI_API_URL;
                const response = await fetch(
                  isGemini
                    ? `${GEMINI_API_URL}?key=${getRandomValue(key)}`
                    : `${url}/v1/models`,
                  isGemini
                    ? undefined
                    : { headers: { Authorization: `Bearer ${key}` } },
                );
                if (!response.ok) throw new Error("无法获取模型列表");
                const data = await response.json();
                let models = isGemini ? data.models : data.data;
                if (isGemini) {
                  models = models.map((model) => {
                    const parts = model.name.split("/");
                    return { id: parts.length > 1 ? parts[1] : model.name };
                  });
                }
                const modelSelect = document.getElementById(
                  "config-model-select",
                );
                modelSelect.innerHTML = "";
                models.forEach((model) => {
                  const option = document.createElement("option");
                  option.value = model.id;
                  option.textContent = model.id;
                  modelSelect.appendChild(option);
                });
                alert("模型列表已更新！");
              } catch (e) {
                console.error(e);
                alert("获取模型失败: " + e.message);
              }
            });

          // Summary custom API - Fetch models button
          document
            .getElementById("summary-fetch-models-btn")
            .addEventListener("click", async () => {
              const url = document
                .getElementById("summary-custom-api-url")
                .value.trim();
              const key = document
                .getElementById("summary-custom-api-key")
                .value.trim();
              if (!url || !key) {
                alert("请先填写API地址和密钥");
                return;
              }
              try {
                const isGemini =
                  url === "https://generativelanguage.googleapis.com/v1beta/models";
                const response = await fetch(
                  isGemini ? `${url}?key=${key}` : `${url}/v1/models`,
                  isGemini
                    ? undefined
                    : { headers: { Authorization: `Bearer ${key}` } },
                );
                if (!response.ok) throw new Error("无法获取模型列表");
                const data = await response.json();
                let models = isGemini ? data.models : data.data;
                if (isGemini) {
                  models = models.map((model) => {
                    const parts = model.name.split("/");
                    return { id: parts.length > 1 ? parts[1] : model.name };
                  });
                }
                const modelSelect = document.getElementById(
                  "summary-custom-model-select",
                );
                modelSelect.innerHTML = "";
                models.forEach((model) => {
                  const option = document.createElement("option");
                  option.value = model.id;
                  option.textContent = model.id;
                  modelSelect.appendChild(option);
                });
                alert("模型列表已更新！");
              } catch (e) {
                console.error(e);
                alert("获取模型失败: " + e.message);
              }
            });

          // Global Settings Auto-save
          document
            .getElementById("background-activity-switch")
            .addEventListener("change", async (e) => {
              state.globalSettings.enableBackgroundActivity = e.target.checked;
              await db.globalSettings.put(state.globalSettings);
            });
          document
            .getElementById("background-interval-input")
            .addEventListener("change", async (e) => {
              state.globalSettings.backgroundActivityInterval = parseInt(
                e.target.value,
              );
              await db.globalSettings.put(state.globalSettings);
            });
          document
            .getElementById("block-cooldown-input")
            .addEventListener("change", async (e) => {
              state.globalSettings.blockCooldownHours = parseFloat(
                e.target.value,
              );
              await db.globalSettings.put(state.globalSettings);
            });
          document
            .getElementById("role-activity-settings")
            .addEventListener("change", async (e) => {
              const target = e.target;
              if (target.tagName !== "INPUT" || target.type !== "checkbox")
                return;
              const chatId = target.dataset.chatId;
              const optionKey = target.dataset.activityOption;
              if (!chatId || !optionKey) return;
              const chat = state.chats[chatId];
              if (!chat) return;
              if (!chat.settings) chat.settings = {};
              const currentOptions = getBackgroundActivityOptions(chat);
              chat.settings.backgroundActivityOptions = {
                ...currentOptions,
                [optionKey]: target.checked,
              };
              await db.chats.put(chat);
            });
          document
            .getElementById("add-world-book-btn")
            .addEventListener("click", async () => {
              const name = await showCustomPrompt("创建世界书", "请输入书名");
              if (name && name.trim()) {
                const newBook = {
                  id: "wb_" + Date.now(),
                  name: name.trim(),
                  content: "",
                };
                await db.worldBooks.add(newBook);
                state.worldBooks.push(newBook);
                renderWorldBookScreen();
                openWorldBookEditor(newBook.id);
              }
            });
          document
            .getElementById("save-world-book-btn")
            .addEventListener("click", async () => {
              if (!editingWorldBookId) return;
              const book = state.worldBooks.find(
                (wb) => wb.id === editingWorldBookId,
              );
              if (book) {
                const newName = document
                  .getElementById("world-book-name-input")
                  .value.trim();
                if (!newName) {
                  alert("书名不能为空！");
                  return;
                }
                book.name = newName;
                book.content = document.getElementById(
                  "world-book-content-input",
                ).value;

                const categoryId = document.getElementById(
                  "world-book-category-select",
                ).value;
                // 如果选择了“未分类”，存入 null；否则存入数字ID
                book.categoryId = categoryId ? parseInt(categoryId) : null;

                await db.worldBooks.put(book);
                document.getElementById("world-book-editor-title").textContent =
                  newName;
                editingWorldBookId = null;
                renderWorldBookScreen();
                showScreen("world-book-screen");
              }
            });
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              const aiImage = e.target.closest(".ai-generated-image");
              if (aiImage) {
                const description = aiImage.dataset.description;
                if (description) showCustomAlert("照片描述", description);
                return;
              }
            });

          const chatSettingsModal = document.getElementById(
            "chat-settings-modal",
          );
          const worldBookSelectBox = document.querySelector(
            ".custom-multiselect .select-box",
          );
          const worldBookCheckboxesContainer = document.getElementById(
            "world-book-checkboxes-container",
          );

          function updateWorldBookSelectionDisplay() {
            const checkedBoxes =
              worldBookCheckboxesContainer.querySelectorAll("input:checked");
            const displayText = document.querySelector(
              ".selected-options-text",
            );
            if (checkedBoxes.length === 0) {
              displayText.textContent = "-- 点击选择 --";
            } else if (checkedBoxes.length > 2) {
              displayText.textContent = `已选择 ${checkedBoxes.length} 项`;
            } else {
              displayText.textContent = Array.from(checkedBoxes)
                .map((cb) => cb.parentElement.textContent.trim())
                .join(", ");
            }
          }

          worldBookSelectBox.addEventListener("click", (e) => {
            e.stopPropagation();
            worldBookCheckboxesContainer.classList.toggle("visible");
            worldBookSelectBox.classList.toggle("expanded");
          });
          document
            .getElementById("world-book-checkboxes-container")
            .addEventListener("change", updateWorldBookSelectionDisplay);
          window.addEventListener("click", (e) => {
            if (
              !document.querySelector(".custom-multiselect").contains(e.target)
            ) {
              worldBookCheckboxesContainer.classList.remove("visible");
              worldBookSelectBox.classList.remove("expanded");
            }
          });

          document
            .getElementById("chat-settings-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];
              const isGroup = chat.isGroup;

              // --- Offline Mode Population ---
              const offlineSettings = chat.settings.offlineMode || {
                enabled: false,
                preset: "custom",
                prompt: "",
                style: "",
                novelai: false,
              };
              document.getElementById("offline-mode-toggle").checked =
                offlineSettings.enabled;
              document.getElementById("offline-mode-config").style.display =
                offlineSettings.enabled ? "block" : "none";

              const presetSelect = document.getElementById(
                "offline-preset-select",
              );
              presetSelect.innerHTML = "";
              Object.keys(offlinePresets).forEach((key) => {
                const option = document.createElement("option");
                option.value = key;
                option.textContent = offlinePresets[key].name;
                if (offlineSettings.preset === key) option.selected = true;
                presetSelect.appendChild(option);
              });

              document.getElementById("offline-prompt-input").value =
                offlineSettings.prompt || "";
              document.getElementById("offline-style-input").value =
                offlineSettings.style || "";

              // Helper: Update inputs when preset changes
              presetSelect.onchange = () => {
                const val = presetSelect.value;
                if (offlinePresets[val] && val !== "custom") {
                  document.getElementById("offline-prompt-input").value =
                    offlinePresets[val].prompt;
                  document.getElementById("offline-style-input").value =
                    offlinePresets[val].style;
                }
              };

              // --- 统一显示/隐藏控件 ---
              document.getElementById("chat-name-group").style.display =
                "block";
              document.getElementById("my-persona-group").style.display =
                "block";
              document.getElementById("my-avatar-group").style.display =
                "block";
              document.getElementById("my-group-nickname-group").style.display =
                isGroup ? "block" : "none";
              document.getElementById("group-avatar-group").style.display =
                isGroup ? "block" : "none";
              document.getElementById("group-members-group").style.display =
                isGroup ? "block" : "none";
              document.getElementById("ai-persona-group").style.display =
                isGroup ? "none" : "block";
              document.getElementById("ai-avatar-group").style.display = isGroup
                ? "none"
                : "block";
              // 【新增】控制AI备注输入框的显示
              document.getElementById("ai-remark-group").style.display = isGroup
                ? "none"
                : "block";

              // 【核心修改1】根据是否为群聊，显示或隐藏“好友分组”区域
              document.getElementById("assign-group-section").style.display =
                isGroup ? "none" : "block";

              // --- 加载表单数据 ---
              document.getElementById("chat-name-input").value = chat.name;
              // 【新增】加载AI备注
              document.getElementById("ai-remark-input").value =
                chat.settings.aiRemark || "";

              const videoCallSettingsGroup = document.getElementById(
                "video-call-settings-group",
              );

              if (isGroup) {
                videoCallSettingsGroup.style.display = "none";
              } else {
                videoCallSettingsGroup.style.display = "block";

                const voiceAccessSwitch = document.getElementById(
                  "video-call-voice-access-switch",
                );
                if (voiceAccessSwitch) {
                  voiceAccessSwitch.checked =
                    chat.settings.videoCallVoiceAccess || false;
                }
              }
              const realCameraSwitch = document.getElementById(
                "user-real-camera-switch",
              );
              if (realCameraSwitch) {
                realCameraSwitch.checked = chat.settings.useRealCamera || false;
              }

              document.getElementById("my-persona").value =
                chat.settings.myPersona;
              document.getElementById("my-avatar-preview").src =
                chat.settings.myAvatar ||
                (isGroup ? defaultMyGroupAvatar : defaultAvatar);
              document.getElementById("max-memory").value =
                chat.settings.maxMemory;
              const bgPreview = document.getElementById("bg-preview");
              const removeBgBtn = document.getElementById("remove-bg-btn");
              if (chat.settings.background) {
                bgPreview.src = chat.settings.background;
                bgPreview.style.display = "block";
                removeBgBtn.style.display = "inline-block";
              } else {
                bgPreview.style.display = "none";
                removeBgBtn.style.display = "none";
              }

              if (isGroup) {
                document.getElementById("my-group-nickname-input").value =
                  chat.settings.myNickname || "";
                document.getElementById("group-avatar-preview").src =
                  chat.settings.groupAvatar || defaultGroupAvatar;
                renderGroupMemberSettings(chat.members);
              } else {
                document.getElementById("ai-persona").value =
                  chat.settings.aiPersona;
                document.getElementById("ai-avatar-preview").src =
                  chat.settings.aiAvatar || defaultAvatar;

                // 【核心修改2】如果是单聊，就加载分组列表到下拉框
                const select = document.getElementById("assign-group-select");
                select.innerHTML = '<option value="">未分组</option>'; // 清空并设置默认选项
                const groups = await db.qzoneGroups.toArray();
                groups.forEach((group) => {
                  const option = document.createElement("option");
                  option.value = group.id;
                  option.textContent = group.name;
                  // 如果当前好友已经有分组，就默认选中它
                  if (chat.groupId === group.id) {
                    option.selected = true;
                  }
                  select.appendChild(option);
                });
              }

              // 加载世界书

              const worldBookCheckboxesContainer = document.getElementById(
                "world-book-checkboxes-container",
              );
              worldBookCheckboxesContainer.innerHTML = "";
              const linkedIds = new Set(chat.settings.linkedWorldBookIds || []);

              // 1. 获取所有分类和世界书
              const categories = await db.worldBookCategories.toArray();
              const books = state.worldBooks;

              // 【核心改造】如果存在未分类的书籍，就创建一个“虚拟分类”
              const hasUncategorized = books.some((book) => !book.categoryId);
              if (hasUncategorized) {
                categories.push({ id: "uncategorized", name: "未分类" });
              }

              // 2. 将书籍按分类ID进行分组
              const booksByCategoryId = books.reduce((acc, book) => {
                const categoryId = book.categoryId || "uncategorized";
                if (!acc[categoryId]) {
                  acc[categoryId] = [];
                }
                acc[categoryId].push(book);
                return acc;
              }, {});

              // 3. 遍历分类，创建带折叠功能的列表
              categories.forEach((category) => {
                const booksInCategory = booksByCategoryId[category.id] || [];
                if (booksInCategory.length > 0) {
                  const allInCategoryChecked = booksInCategory.every((book) =>
                    linkedIds.has(book.id),
                  );

                  const header = document.createElement("div");
                  header.className = "wb-category-header";
                  header.innerHTML = `
                  <input type="checkbox" class="wb-category-checkbox" data-category-id="${
                    category.id
                  }" ${allInCategoryChecked ? "checked" : ""}>
                  <span>${category.name}</span>
              `;

                  const bookContainer = document.createElement("div");
                  bookContainer.className = "wb-book-container";
                  bookContainer.dataset.containerFor = category.id;

                  booksInCategory.forEach((book) => {
                    const isChecked = linkedIds.has(book.id);
                    const label = document.createElement("label");
                    label.innerHTML = `<input type="checkbox" class="wb-book-checkbox" value="${
                      book.id
                    }" data-parent-category="${category.id}" ${
                      isChecked ? "checked" : ""
                    }> ${book.name}`;
                    bookContainer.appendChild(label);
                  });

                  // --- ★ 核心修改 #1 在这里 ★ ---
                  // 默认将分类设置为折叠状态
                  header.classList.add("collapsed");
                  bookContainer.classList.add("collapsed");
                  // --- ★ 修改结束 ★ ---

                  worldBookCheckboxesContainer.appendChild(header);
                  worldBookCheckboxesContainer.appendChild(bookContainer);
                }
              });

              updateWorldBookSelectionDisplay(); // 更新顶部的已选数量显示

              // 加载总结设置
              if (chat.settings.summary) {
                const summarySettings = chat.settings.summary;
                document.getElementById("summary-toggle").checked =
                  summarySettings.enabled;
                const modeRadios = document.getElementsByName("summary-mode");
                for (const radio of modeRadios) {
                  if (radio.value === summarySettings.mode) {
                    radio.checked = true;
                    break;
                  }
                }
                document.getElementById("summary-count-input").value =
                  summarySettings.count;
                // 显示/隐藏详细选项
                document.getElementById("summary-options").style.display =
                  summarySettings.enabled ? "block" : "none";
                
                // 加载自定义API设置
                document.getElementById("summary-custom-api-toggle").checked =
                  summarySettings.useCustomApi || false;
                document.getElementById("summary-custom-api-url").value =
                  summarySettings.customApiUrl || "";
                document.getElementById("summary-custom-api-key").value =
                  summarySettings.customApiKey || "";
                document.getElementById("summary-stream-toggle").checked =
                  summarySettings.enableStream || false;
                
                // 填充模型下拉框
                const summaryModelSelect = document.getElementById("summary-custom-model-select");
                summaryModelSelect.innerHTML = "";
                if (summarySettings.customModel) {
                  const option = document.createElement("option");
                  option.value = summarySettings.customModel;
                  option.textContent = summarySettings.customModel;
                  summaryModelSelect.appendChild(option);
                }
                
                // 根据toggle状态显示/隐藏自定义API选项
                const summaryCustomApiOptions = document.getElementById("summary-custom-api-options");
                summaryCustomApiOptions.style.display = summarySettings.useCustomApi ? "flex" : "none";
              }

              // 使用事件委托来处理所有点击和勾选事件，效率更高
              worldBookCheckboxesContainer.addEventListener("click", (e) => {
                const header = e.target.closest(".wb-category-header");
                if (header && !e.target.matches('input[type="checkbox"]')) {
                  const categoryId = header.querySelector(
                    ".wb-category-checkbox",
                  )?.dataset.categoryId;
                  // 【修改】现在 categoryId 可能是数字，也可能是 "uncategorized" 字符串，所以这个判断能通过了！
                  if (categoryId) {
                    // <-- 把原来的 !categoryId return; 改成这样
                    const bookContainer =
                      worldBookCheckboxesContainer.querySelector(
                        `.wb-book-container[data-container-for="${categoryId}"]`,
                      );
                    if (bookContainer) {
                      header.classList.toggle("collapsed");
                      bookContainer.classList.toggle("collapsed");
                    }
                  }
                }
              });

              worldBookCheckboxesContainer.addEventListener("change", (e) => {
                const target = e.target;

                // 如果点击的是分类的“全选”复选框
                if (target.classList.contains("wb-category-checkbox")) {
                  const categoryId = target.dataset.categoryId;
                  const isChecked = target.checked;
                  // 找到这个分类下的所有书籍复选框，并将它们的状态设置为与分类复选框一致
                  const bookCheckboxes =
                    worldBookCheckboxesContainer.querySelectorAll(
                      `input.wb-book-checkbox[data-parent-category="${categoryId}"]`,
                    );
                  bookCheckboxes.forEach((cb) => (cb.checked = isChecked));
                }

                // 如果点击的是单个书籍的复选框
                if (target.classList.contains("wb-book-checkbox")) {
                  const categoryId = target.dataset.parentCategory;
                  if (categoryId) {
                    // 检查它是否属于一个分类
                    const categoryCheckbox =
                      worldBookCheckboxesContainer.querySelector(
                        `input.wb-category-checkbox[data-category-id="${categoryId}"]`,
                      );
                    const allBookCheckboxes =
                      worldBookCheckboxesContainer.querySelectorAll(
                        `input.wb-book-checkbox[data-parent-category="${categoryId}"]`,
                      );
                    // 检查该分类下是否所有书籍都被选中了
                    const allChecked = Array.from(allBookCheckboxes).every(
                      (cb) => cb.checked,
                    );
                    // 同步分类“全选”复选框的状态
                    categoryCheckbox.checked = allChecked;
                  }
                }

                // 每次变更后都更新顶部的已选数量显示
                updateWorldBookSelectionDisplay();
              });

              // 加载并更新所有预览相关控件
              const themeRadio = document.querySelector(
                `input[name="theme-select"][value="${
                  chat.settings.theme || "default"
                }"]`,
              );
              if (themeRadio) themeRadio.checked = true;
              const fontSizeSlider =
                document.getElementById("font-size-slider");
              fontSizeSlider.value = chat.settings.fontSize || 13;
              document.getElementById("font-size-value").textContent =
                `${fontSizeSlider.value}px`;
              const customCssInput =
                document.getElementById("custom-css-input");
              customCssInput.value = chat.settings.customCss || "";

              updateSettingsPreview();
              
              // Add event listener for custom API toggle (only add once)
              const summaryCustomApiToggle = document.getElementById("summary-custom-api-toggle");
              summaryCustomApiToggle.removeEventListener("change", handleSummaryCustomApiToggle); // Remove if exists
              summaryCustomApiToggle.addEventListener("change", handleSummaryCustomApiToggle);
              
              document
                .getElementById("chat-settings-modal")
                .classList.add("visible");
            });
          
          function handleSummaryCustomApiToggle(e) {
            const options = document.getElementById("summary-custom-api-options");
            options.style.display = e.target.checked ? "flex" : "none";
          }

          function renderGroupMemberSettings(members) {
            const container = document.getElementById("group-members-settings");
            container.innerHTML = "";
            members.forEach((member) => {
              const div = document.createElement("div");
              div.className = "member-editor";
              div.dataset.memberId = member.id;
              // ★★★【核心重构】★★★
              // 显示的是 groupNickname
              div.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`;
              div.addEventListener("click", () => openMemberEditor(member.id));
              container.appendChild(div);
            });
          }

          function openMemberEditor(memberId) {
            editingMemberId = memberId;
            const chat = state.chats[state.activeChatId];
            const member = chat.members.find((m) => m.id === memberId);
            document.getElementById("member-name-input").value =
              member.groupNickname;
            document.getElementById("member-persona-input").value =
              member.persona;
            document.getElementById("member-avatar-preview").src =
              member.avatar;
            document
              .getElementById("member-settings-modal")
              .classList.add("visible");
          }
          document
            .getElementById("cancel-member-settings-btn")
            .addEventListener("click", () => {
              document
                .getElementById("member-settings-modal")
                .classList.remove("visible");
              editingMemberId = null;
            });
          document
            .getElementById("save-member-settings-btn")
            .addEventListener("click", () => {
              if (!editingMemberId) return;
              const chat = state.chats[state.activeChatId];
              const member = chat.members.find((m) => m.id === editingMemberId);

              // ★★★【核心重构】★★★
              const newNickname = document
                .getElementById("member-name-input")
                .value.trim();
              if (!newNickname) {
                alert("群昵称不能为空！");
                return;
              }
              member.groupNickname = newNickname; // 只修改群昵称
              member.persona = document.getElementById(
                "member-persona-input",
              ).value;
              member.avatar = document.getElementById(
                "member-avatar-preview",
              ).src;

              renderGroupMemberSettings(chat.members);
              document
                .getElementById("member-settings-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("reset-theme-btn")
            .addEventListener("click", () => {
              document.getElementById("theme-default").checked = true;
            });
          document
            .getElementById("cancel-chat-settings-btn")
            .addEventListener("click", () => {
              chatSettingsModal.classList.remove("visible");
            });

          document
            .getElementById("save-chat-settings-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];
              const newName = document
                .getElementById("chat-name-input")
                .value.trim();
              if (!newName) return alert("备注名/群名不能为空！");
              chat.name = newName;
              const selectedThemeRadio = document.querySelector(
                'input[name="theme-select"]:checked',
              );
              chat.settings.theme = selectedThemeRadio
                ? selectedThemeRadio.value
                : "default";

              chat.settings.fontSize = parseInt(
                document.getElementById("font-size-slider").value,
              );
              chat.settings.customCss = document
                .getElementById("custom-css-input")
                .value.trim();

              const userBubbleColorValue =
                (document.querySelector("#user-bubble-color-picker")?.value || "").trim();
              const aiBubbleColorValue =
                (document.querySelector("#ai-bubble-color-picker")?.value || "").trim();

              chat.settings.userBubbleColor = userBubbleColorValue || null;
              chat.settings.aiBubbleColor = aiBubbleColorValue || null;

              chat.settings.myPersona =
                document.getElementById("my-persona").value;
              chat.settings.myAvatar =
                document.getElementById("my-avatar-preview").src;
              const checkedBooks = document.querySelectorAll(
                "#world-book-checkboxes-container input.wb-book-checkbox:checked",
              );
              chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(
                (cb) => cb.value,
              );

              if (chat.isGroup) {
                chat.settings.myNickname = document
                  .getElementById("my-group-nickname-input")
                  .value.trim();
                chat.settings.groupAvatar = document.getElementById(
                  "group-avatar-preview",
                ).src;
              } else {
                chat.settings.aiPersona =
                  document.getElementById("ai-persona").value;
                chat.settings.aiAvatar =
                  document.getElementById("ai-avatar-preview").src;
                // 【新增】保存AI备注
                chat.settings.aiRemark = document
                  .getElementById("ai-remark-input")
                  .value.trim();

                const selectedGroupId = document.getElementById(
                  "assign-group-select",
                ).value;
                chat.groupId = selectedGroupId
                  ? parseInt(selectedGroupId)
                  : null;
              }

              chat.settings.maxMemory =
                parseInt(document.getElementById("max-memory").value) || 10;

              const voiceAccessSwitchSave = document.getElementById(
                "video-call-voice-access-switch",
              );
              if (voiceAccessSwitchSave) {
                chat.settings.videoCallVoiceAccess =
                  voiceAccessSwitchSave.checked;
              }

              // 保存总结设置

              if (!chat.settings.summary) chat.settings.summary = {}; // 防止意外
              chat.settings.summary.enabled =
                document.getElementById("summary-toggle").checked;
              const selectedModeRadio = document.querySelector(
                'input[name="summary-mode"]:checked',
              );
              chat.settings.summary.mode = selectedModeRadio
                ? selectedModeRadio.value
                : "manual";
              chat.settings.summary.count =
                parseInt(
                  document.getElementById("summary-count-input").value,
                ) || 50;

              // Save custom API settings for summary
              // Save custom API settings for summary
              if (!chat.settings.summary) chat.settings.summary = {}; // Ensure summary exists
              chat.settings.summary.useCustomApi = document.getElementById(
                "summary-custom-api-toggle",
              ).checked;
              chat.settings.summary.customApiUrl = document
                .getElementById("summary-custom-api-url")
                .value.trim();
              chat.settings.summary.customApiKey = document
                .getElementById("summary-custom-api-key")
                .value.trim();
              chat.settings.summary.customModel =
                document.getElementById("summary-custom-model-select").value ||
                "gpt-4o-mini";
              chat.settings.summary.enableStream = document.getElementById(
                "summary-stream-toggle",
              ).checked;

              // Save Offline Mode
              chat.settings.offlineMode = {
                enabled: document.getElementById("offline-mode-toggle").checked,
                preset: document.getElementById("offline-preset-select").value,
                prompt: document.getElementById("offline-prompt-input").value,
                style: document.getElementById("offline-style-input").value,
              };
              await db.chats.put(chat);

              applyScopedCss(
                chat.settings.customCss,
                "#chat-messages",
                "custom-bubble-style",
              );

              chatSettingsModal.classList.remove("visible");
              renderChatInterface(state.activeChatId);
              renderChatList();
            });

          document
            .getElementById("summary-toggle")
            .addEventListener("change", (e) => {
              document.getElementById("summary-options").style.display = e
                .target.checked
                ? "block"
                : "none";
            });

          document
            .getElementById("manual-summary-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];
              if (!chat) return;

              const summarySettings = chat.settings?.summary || { lastSummaryIndex: -1 };
              const lastSummaryIndex =
                summarySettings.lastSummaryIndex > -1
                  ? summarySettings.lastSummaryIndex
                  : 0;
              const messagesToCheck = chat.history.slice(lastSummaryIndex + 1);
              const filteredMessages = messagesToCheck.filter(
                (msg) => msg.type !== "summary",
              );

              if (filteredMessages.length === 0) {
                await showCustomAlert(
                  "无需总结",
                  "自上次总结以来没有新的对话内容。",
                );
                return;
              }

              // 关闭设置弹窗
              document
                .getElementById("chat-settings-modal")
                .classList.remove("visible");

              await showCustomAlert(
                "开始总结",
                "正在为当前对话生成总结...",
              );
              const summaryText = await generateSummary(state.activeChatId);
              if (summaryText) {
                await saveSummaryAsMemory(state.activeChatId, summaryText);
                await showCustomAlert(
                  "总结完成",
                  "新的总结已保存到对话记忆中。",
                );
              }
            });
          document
            .getElementById("clear-chat-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const chat = state.chats[state.activeChatId];
              const confirmed = await showCustomConfirm(
                "清空聊天记录",
                "此操作将永久删除此聊天的所有消息，无法恢复。确定要清空吗？",
                { confirmButtonClass: "btn-danger" },
              );
              if (confirmed) {
                chat.history = [];
                await db.chats.put(chat);
                renderChatInterface(state.activeChatId);
                renderChatList();
                chatSettingsModal.classList.remove("visible");
              }
            });

          const setupFileUpload = (inputId, callback) => {
            document
              .getElementById(inputId)
              .addEventListener("change", async (event) => {
                const file = event.target.files[0];
                if (file) {
                  const dataUrl = await new Promise((res, rej) => {
                    const reader = new FileReader();
                    reader.onload = () => res(reader.result);
                    reader.onerror = () => rej(reader.error);
                    reader.readAsDataURL(file);
                  });
                  callback(dataUrl);
                  event.target.value = null;
                }
              });
          };
          setupFileUpload(
            "ai-avatar-input",
            (base64) =>
              (document.getElementById("ai-avatar-preview").src = base64),
          );
          setupFileUpload(
            "my-avatar-input",
            (base64) =>
              (document.getElementById("my-avatar-preview").src = base64),
          );
          setupFileUpload(
            "group-avatar-input",
            (base64) =>
              (document.getElementById("group-avatar-preview").src = base64),
          );
          setupFileUpload(
            "member-avatar-input",
            (base64) =>
              (document.getElementById("member-avatar-preview").src = base64),
          );
          setupFileUpload("bg-input", (base64) => {
            if (state.activeChatId) {
              state.chats[state.activeChatId].settings.background = base64;
              const bgPreview = document.getElementById("bg-preview");
              bgPreview.src = base64;
              bgPreview.style.display = "block";
              document.getElementById("remove-bg-btn").style.display =
                "inline-block";
            }
          });
          setupFileUpload(
            "preset-avatar-input",
            (base64) =>
              (document.getElementById("preset-avatar-preview").src = base64),
          );
          document
            .getElementById("remove-bg-btn")
            .addEventListener("click", () => {
              if (state.activeChatId) {
                state.chats[state.activeChatId].settings.background = "";
                const bgPreview = document.getElementById("bg-preview");
                bgPreview.src = "";
                bgPreview.style.display = "none";
                document.getElementById("remove-bg-btn").style.display = "none";
              }
            });

          const stickerPanel = document.getElementById("sticker-panel");
          document
            .getElementById("open-sticker-panel-btn")
            .addEventListener("click", () => {
              renderStickerPanel();
              stickerPanel.classList.add("visible");
            });
          document
            .getElementById("close-sticker-panel-btn")
            .addEventListener("click", () =>
              stickerPanel.classList.remove("visible"),
            );
          document
            .getElementById("add-sticker-btn")
            .addEventListener("click", async () => {
              const url = await showCustomPrompt(
                "添加表情(URL)",
                "请输入表情包的图片URL",
              );
              if (!url || !url.trim().startsWith("http"))
                return url && alert("请输入有效的URL (以http开头)");
              const name = await showCustomPrompt(
                "命名表情",
                "请为这个表情命名 (例如：开心、疑惑)",
              );
              if (name && name.trim()) {
                const newSticker = {
                  id: "sticker_" + Date.now(),
                  url: url.trim(),
                  name: name.trim(),
                };
                await db.userStickers.add(newSticker);
                state.userStickers.push(newSticker);
                renderStickerPanel();
              } else if (name !== null) alert("表情名不能为空！");
            });
          document
            .getElementById("upload-sticker-btn")
            .addEventListener("click", () =>
              document.getElementById("sticker-upload-input").click(),
            );
          document
            .getElementById("sticker-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (!file) return;
              const reader = new FileReader();
              reader.readAsDataURL(file);
              reader.onload = async () => {
                const base64Url = reader.result;
                const name = await showCustomPrompt(
                  "命名表情",
                  "请为这个表情命名 (例如：好耶、疑惑)",
                );
                if (name && name.trim()) {
                  const newSticker = {
                    id: "sticker_" + Date.now(),
                    url: base64Url,
                    name: name.trim(),
                  };
                  await db.userStickers.add(newSticker);
                  state.userStickers.push(newSticker);
                  renderStickerPanel();
                } else if (name !== null) alert("表情名不能为空！");
              };
              event.target.value = null;
            });

          document
            .getElementById("upload-image-btn")
            .addEventListener("click", () =>
              document.getElementById("image-upload-input").click(),
            );
          document
            .getElementById("image-upload-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (!file || !state.activeChatId) return;
              const reader = new FileReader();
              reader.onload = async (e) => {
                const base64Url = e.target.result;
                const chat = state.chats[state.activeChatId];
                const msg = {
                  role: "user",
                  content: [
                    { type: "image_url", image_url: { url: base64Url } },
                  ],
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                renderChatList();
              };
              reader.readAsDataURL(file);
              event.target.value = null;
            });
          document
            .getElementById("voice-message-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const text = await showCustomPrompt(
                "发送语音",
                "请输入你想说的内容：",
              );
              if (text && text.trim()) {
                const chat = state.chats[state.activeChatId];
                const msg = {
                  role: "user",
                  type: "voice_message",
                  content: text.trim(),
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                renderChatList();
              }
            });
          document
            .getElementById("send-photo-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;
              const description = await showCustomPrompt(
                "发送照片",
                "请用文字描述您要发送的照片：",
              );
              if (description && description.trim()) {
                const chat = state.chats[state.activeChatId];
                const msg = {
                  role: "user",
                  type: "user_photo",
                  content: description.trim(),
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                renderChatList();
              }
            });

          const waimaiModal = document.getElementById("waimai-request-modal");
          document
            .getElementById("send-waimai-request-btn")
            .addEventListener("click", () => {
              waimaiModal.classList.add("visible");
            });

          document
            .getElementById("waimai-cancel-btn")
            .addEventListener("click", () => {
              waimaiModal.classList.remove("visible");
            });

          document
            .getElementById("waimai-confirm-btn")
            .addEventListener("click", async () => {
              if (!state.activeChatId) return;

              const productInfoInput = document.getElementById(
                "waimai-product-info",
              );
              const amountInput = document.getElementById("waimai-amount");

              const productInfo = productInfoInput.value.trim();
              const amount = parseFloat(amountInput.value);

              if (!productInfo) {
                alert("请输入商品信息！");
                return;
              }
              if (isNaN(amount) || amount <= 0) {
                alert("请输入有效的代付金额！");
                return;
              }

              const chat = state.chats[state.activeChatId];
              const now = Date.now();

              // 【核心修正】在这里获取用户自己的昵称
              const myNickname = chat.isGroup
                ? chat.settings.myNickname || "我"
                : "我";

              const msg = {
                role: "user",
                // 【核心修正】将获取到的昵称，作为 senderName 添加到消息对象中
                senderName: myNickname,
                type: "waimai_request",
                productInfo: productInfo,
                amount: amount,
                status: "pending",
                countdownEndTime: now + 15 * 60 * 1000,
                timestamp: now,
              };

              chat.history.push(msg);
              await db.chats.put(chat);
              appendMessage(msg, chat);
              renderChatList();

              productInfoInput.value = "";
              amountInput.value = "";
              waimaiModal.classList.remove("visible");
            });
          document
            .getElementById("open-persona-library-btn")
            .addEventListener("click", openPersonaLibrary);
          document
            .getElementById("close-persona-library-btn")
            .addEventListener("click", closePersonaLibrary);
          document
            .getElementById("add-persona-preset-btn")
            .addEventListener("click", openPersonaEditorForCreate);
          document
            .getElementById("cancel-persona-editor-btn")
            .addEventListener("click", closePersonaEditor);
          document
            .getElementById("save-persona-preset-btn")
            .addEventListener("click", savePersonaPreset);
          document
            .getElementById("preset-action-edit")
            .addEventListener("click", openPersonaEditorForEdit);
          document
            .getElementById("preset-action-delete")
            .addEventListener("click", deletePersonaPreset);
          document
            .getElementById("preset-action-cancel")
            .addEventListener("click", hidePresetActions);

          document
            .getElementById("selection-cancel-btn")
            .addEventListener("click", exitSelectionMode);

          document
            .getElementById("selection-delete-btn")
            .addEventListener("click", async () => {
              if (selectedMessages.size === 0) return;
              const confirmed = await showCustomConfirm(
                "删除消息",
                `确定要删除选中的 ${selectedMessages.size} 条消息吗？这将改变AI的记忆。`,
                { confirmButtonClass: "btn-danger" },
              );
              if (confirmed) {
                const chat = state.chats[state.activeChatId];

                // 1. 【核心加强】在删除前，检查被删除的消息中是否包含投票
                let deletedPollsInfo = [];
                for (const timestamp of selectedMessages) {
                  const msg = chat.history.find(
                    (m) => m.timestamp === timestamp,
                  );
                  if (msg && msg.type === "poll") {
                    deletedPollsInfo.push(
                      `关于“${msg.question}”的投票(时间戳: ${msg.timestamp})`,
                    );
                  }
                }

                // 2. 更新后端的历史记录
                chat.history = chat.history.filter(
                  (msg) => !selectedMessages.has(msg.timestamp),
                );

                // 3. 【核心加强】构建更具体的“遗忘指令”
                let forgetReason = "一些之前的消息已被用户删除。";
                if (deletedPollsInfo.length > 0) {
                  forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join(
                    "；",
                  )}。`;
                }
                forgetReason +=
                  " 你应该像它们从未存在过一样继续对话，并相应地调整你的记忆和行为，不要再提及这些被删除的内容。";

                const forgetInstruction = {
                  role: "system",
                  content: `[系统提示：${forgetReason}]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(forgetInstruction);

                // 4. 将包含“遗忘指令”的、更新后的chat对象存回数据库
                await db.chats.put(chat);

                // 5. 最后才更新UI
                renderChatInterface(state.activeChatId);
                renderChatList();
              }
            });

          const fontUrlInput = document.getElementById("font-url-input");
          fontUrlInput.addEventListener("input", () =>
            applyCustomFont(fontUrlInput.value.trim(), true),
          );
          document
            .getElementById("save-font-btn")
            .addEventListener("click", async () => {
              const newFontUrl = fontUrlInput.value.trim();
              if (!newFontUrl) {
                alert("请输入有效的字体URL。");
                return;
              }
              applyCustomFont(newFontUrl, false);
              state.globalSettings.fontUrl = newFontUrl;
              await db.globalSettings.put(state.globalSettings);
              alert("字体已保存并应用！");
            });
          document
            .getElementById("reset-font-btn")
            .addEventListener("click", resetToDefaultFont);

          document
            .querySelectorAll("#chat-list-bottom-nav .nav-item")
            .forEach((item) => {
              item.addEventListener("click", () =>
                switchToChatListView(item.dataset.view),
              );
            });
          document
            .getElementById("qzone-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view"),
            );
          document
            .getElementById("qzone-nickname")
            .addEventListener("click", async () => {
              const newNickname = await showCustomPrompt(
                "修改昵称",
                "请输入新的昵称",
                state.qzoneSettings.nickname,
              );
              if (newNickname && newNickname.trim()) {
                state.qzoneSettings.nickname = newNickname.trim();
                await saveQzoneSettings();
                renderQzoneScreen();
              }
            });
          document
            .getElementById("qzone-avatar-container")
            .addEventListener("click", () =>
              document.getElementById("qzone-avatar-input").click(),
            );
          document
            .getElementById("qzone-banner-container")
            .addEventListener("click", () =>
              document.getElementById("qzone-banner-input").click(),
            );
          document
            .getElementById("qzone-avatar-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.readAsDataURL(file);
                });
                state.qzoneSettings.avatar = dataUrl;
                await saveQzoneSettings();
                renderQzoneScreen();
              }
              event.target.value = null;
            });
          document
            .getElementById("qzone-banner-input")
            .addEventListener("change", async (event) => {
              const file = event.target.files[0];
              if (file) {
                const dataUrl = await new Promise((res) => {
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.readAsDataURL(file);
                });
                state.qzoneSettings.banner = dataUrl;
                await saveQzoneSettings();
                renderQzoneScreen();
              }
              event.target.value = null;
            });

          document
            .getElementById("create-shuoshuo-btn")
            .addEventListener("click", async () => {
              // 1. 重置并获取模态框
              resetCreatePostModal();
              const modal = document.getElementById("create-post-modal");

              // 2. 设置为“说说”模式
              modal.dataset.mode = "shuoshuo";

              // 3. 隐藏与图片/文字图相关的部分
              modal.querySelector(".post-mode-switcher").style.display = "none";
              modal.querySelector("#image-mode-content").style.display = "none";
              modal.querySelector("#text-image-mode-content").style.display =
                "none";

              // 4. 修改主输入框的提示语，使其更符合“说说”的场景
              modal.querySelector("#post-public-text").placeholder =
                "分享新鲜事...";

              // 5. 准备并显示模态框
              const visibilityGroupsContainer = document.getElementById(
                "post-visibility-groups",
              );
              visibilityGroupsContainer.innerHTML = "";
              const groups = await db.qzoneGroups.toArray();
              if (groups.length > 0) {
                groups.forEach((group) => {
                  const label = document.createElement("label");
                  label.style.display = "block";
                  label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                  visibilityGroupsContainer.appendChild(label);
                });
              } else {
                visibilityGroupsContainer.innerHTML =
                  '<p style="color: var(--text-secondary);">没有可用的分组</p>';
              }
              modal.classList.add("visible");
            });

          document
            .getElementById("create-post-btn")
            .addEventListener("click", async () => {
              resetCreatePostModal();
              const modal = document.getElementById("create-post-modal");

              modal.dataset.mode = "complex";

              modal.querySelector(".post-mode-switcher").style.display = "flex";

              modal.querySelector("#image-mode-content").style.display = "";
              modal.querySelector("#text-image-mode-content").style.display =
                "";

              modal
                .querySelector("#image-mode-content")
                .classList.add("active");
              modal
                .querySelector("#text-image-mode-content")
                .classList.remove("active");

              modal.querySelector("#post-public-text").placeholder =
                "分享新鲜事...（非必填的公开文字）";

              const visibilityGroupsContainer = document.getElementById(
                "post-visibility-groups",
              );
              visibilityGroupsContainer.innerHTML = "";
              const groups = await db.qzoneGroups.toArray();
              if (groups.length > 0) {
                groups.forEach((group) => {
                  const label = document.createElement("label");
                  label.style.display = "block";
                  label.innerHTML = `<input type="checkbox" name="visibility_group" value="${group.id}"> ${group.name}`;
                  visibilityGroupsContainer.appendChild(label);
                });
              } else {
                visibilityGroupsContainer.innerHTML =
                  '<p style="color: var(--text-secondary);">没有可用的分组</p>';
              }
              modal.classList.add("visible");
            });
          document
            .getElementById("open-album-btn")
            .addEventListener("click", async () => {
              await renderAlbumList();
              showScreen("album-screen");
            });
          document
            .getElementById("album-back-btn")
            .addEventListener("click", () => {
              showScreen("chat-list-screen");
              switchToChatListView("qzone-screen");
            });

          // --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

          document
            .getElementById("album-photos-back-btn")
            .addEventListener("click", () => {
              state.activeAlbumId = null;
              showScreen("album-screen");
            });

          document
            .getElementById("album-upload-photo-btn")
            .addEventListener("click", () =>
              document.getElementById("album-photo-input").click(),
            );

          document
            .getElementById("album-photo-input")
            .addEventListener("change", async (event) => {
              if (!state.activeAlbumId) return;
              const files = event.target.files;
              if (!files.length) return;

              const album = await db.qzoneAlbums.get(state.activeAlbumId);

              for (const file of files) {
                const dataUrl = await new Promise((resolve) => {
                  const reader = new FileReader();
                  reader.onload = () => resolve(reader.result);
                  reader.readAsDataURL(file);
                });
                await db.qzonePhotos.add({
                  albumId: state.activeAlbumId,
                  url: dataUrl,
                  createdAt: Date.now(),
                });
              }

              const photoCount = await db.qzonePhotos
                .where("albumId")
                .equals(state.activeAlbumId)
                .count();
              const updateData = { photoCount };

              if (!album.photoCount || album.coverUrl.includes("placeholder")) {
                const firstPhoto = await db.qzonePhotos
                  .where("albumId")
                  .equals(state.activeAlbumId)
                  .first();
                if (firstPhoto) updateData.coverUrl = firstPhoto.url;
              }

              await db.qzoneAlbums.update(state.activeAlbumId, updateData);
              await renderAlbumPhotosScreen();
              await renderAlbumList();

              event.target.value = null;
              alert("照片上传成功！");
            });

          // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

          // --- ↓↓↓ 从这里开始复制，完整替换掉旧的 photos-grid-page 监听器 ↓↓↓ ---

          document
            .getElementById("photos-grid-page")
            .addEventListener("click", async (e) => {
              const deleteBtn = e.target.closest(".photo-delete-btn");
              const photoThumb = e.target.closest(".photo-thumb");

              if (deleteBtn) {
                e.stopPropagation(); // 阻止事件冒泡到图片上
                const photoId = parseInt(deleteBtn.dataset.photoId);
                const confirmed = await showCustomConfirm(
                  "删除照片",
                  "确定要删除这张照片吗？此操作不可恢复。",
                  { confirmButtonClass: "btn-danger" },
                );

                if (confirmed) {
                  const deletedPhoto = await db.qzonePhotos.get(photoId);
                  if (!deletedPhoto) return;

                  await db.qzonePhotos.delete(photoId);

                  const album = await db.qzoneAlbums.get(state.activeAlbumId);
                  const photoCount = (album.photoCount || 1) - 1;
                  const updateData = { photoCount };

                  if (album.coverUrl === deletedPhoto.url) {
                    const nextPhoto = await db.qzonePhotos
                      .where("albumId")
                      .equals(state.activeAlbumId)
                      .first();
                    updateData.coverUrl = nextPhoto
                      ? nextPhoto.url
                      : "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png";
                  }

                  await db.qzoneAlbums.update(state.activeAlbumId, updateData);
                  await renderAlbumPhotosScreen();
                  await renderAlbumList();
                  alert("照片已删除。");
                }
              } else if (photoThumb) {
                // 这就是恢复的图片点击放大功能！
                openPhotoViewer(photoThumb.src);
              }
            });

          // 恢复图片查看器的控制事件
          document
            .getElementById("photo-viewer-close-btn")
            .addEventListener("click", closePhotoViewer);
          document
            .getElementById("photo-viewer-next-btn")
            .addEventListener("click", showNextPhoto);
          document
            .getElementById("photo-viewer-prev-btn")
            .addEventListener("click", showPrevPhoto);

          // 恢复键盘左右箭头和ESC键的功能
          document.addEventListener("keydown", (e) => {
            if (!photoViewerState.isOpen) return;

            if (e.key === "ArrowRight") {
              showNextPhoto();
            } else if (e.key === "ArrowLeft") {
              showPrevPhoto();
            } else if (e.key === "Escape") {
              closePhotoViewer();
            }
          });

          // --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

          document
            .getElementById("create-album-btn-page")
            .addEventListener("click", async () => {
              const albumName = await showCustomPrompt(
                "创建新相册",
                "请输入相册名称",
              );
              if (albumName && albumName.trim()) {
                const newAlbum = {
                  name: albumName.trim(),
                  coverUrl:
                    "https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png",
                  photoCount: 0,
                  createdAt: Date.now(),
                };
                await db.qzoneAlbums.add(newAlbum);
                await renderAlbumList();
                alert(`相册 "${albumName}" 创建成功！`);
              } else if (albumName !== null) {
                alert("相册名称不能为空！");
              }
            });

          document
            .getElementById("cancel-create-post-btn")
            .addEventListener("click", () =>
              document
                .getElementById("create-post-modal")
                .classList.remove("visible"),
            );
          document
            .getElementById("post-upload-local-btn")
            .addEventListener("click", () =>
              document.getElementById("post-local-image-input").click(),
            );
          document
            .getElementById("post-local-image-input")
            .addEventListener("change", (event) => {
              const file = event.target.files[0];
              if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                  document.getElementById("post-image-preview").src =
                    e.target.result;
                  document
                    .getElementById("post-image-preview-container")
                    .classList.add("visible");
                  document.getElementById(
                    "post-image-desc-group",
                  ).style.display = "block";
                };
                reader.readAsDataURL(file);
              }
            });
          document
            .getElementById("post-use-url-btn")
            .addEventListener("click", async () => {
              const url = await showCustomPrompt(
                "输入图片URL",
                "请输入网络图片的链接",
                "",
                "url",
              );
              if (url) {
                document.getElementById("post-image-preview").src = url;
                document
                  .getElementById("post-image-preview-container")
                  .classList.add("visible");
                document.getElementById("post-image-desc-group").style.display =
                  "block";
              }
            });
          document
            .getElementById("post-remove-image-btn")
            .addEventListener("click", () => resetCreatePostModal());
          const imageModeBtn = document.getElementById("switch-to-image-mode");
          const textImageModeBtn = document.getElementById(
            "switch-to-text-image-mode",
          );
          const imageModeContent =
            document.getElementById("image-mode-content");
          const textImageModeContent = document.getElementById(
            "text-image-mode-content",
          );
          imageModeBtn.addEventListener("click", () => {
            imageModeBtn.classList.add("active");
            textImageModeBtn.classList.remove("active");
            imageModeContent.classList.add("active");
            textImageModeContent.classList.remove("active");
          });
          textImageModeBtn.addEventListener("click", () => {
            textImageModeBtn.classList.add("active");
            imageModeBtn.classList.remove("active");
            textImageModeContent.classList.add("active");
            imageModeContent.classList.remove("active");
          });

          document
            .getElementById("confirm-create-post-btn")
            .addEventListener("click", async () => {
              const modal = document.getElementById("create-post-modal");
              const mode = modal.dataset.mode;

              // --- 1. 获取通用的可见性设置 ---
              const visibilityMode = document.querySelector(
                'input[name="visibility"]:checked',
              ).value;
              let visibleGroupIds = null;

              if (visibilityMode === "include") {
                visibleGroupIds = Array.from(
                  document.querySelectorAll(
                    'input[name="visibility_group"]:checked',
                  ),
                ).map((cb) => parseInt(cb.value));
              }

              let newPost = {};
              const basePostData = {
                timestamp: Date.now(),
                authorId: "user",
                // 【重要】在这里就把权限信息存好
                visibleGroupIds: visibleGroupIds,
              };

              // --- 2. 根据模式构建不同的 post 对象 ---
              if (mode === "shuoshuo") {
                const content = document
                  .getElementById("post-public-text")
                  .value.trim();
                if (!content) {
                  alert("说说内容不能为空哦！");
                  return;
                }
                newPost = {
                  ...basePostData,
                  type: "shuoshuo",
                  content: content,
                };
              } else {
                // 处理 'complex' 模式 (图片/文字图)
                const publicText = document
                  .getElementById("post-public-text")
                  .value.trim();
                const isImageModeActive = document
                  .getElementById("image-mode-content")
                  .classList.contains("active");

                if (isImageModeActive) {
                  const imageUrl =
                    document.getElementById("post-image-preview").src;
                  const imageDescription = document
                    .getElementById("post-image-description")
                    .value.trim();
                  if (
                    !imageUrl ||
                    !(
                      imageUrl.startsWith("http") ||
                      imageUrl.startsWith("data:")
                    )
                  ) {
                    alert("请先添加一张图片再发布动态哦！");
                    return;
                  }
                  if (!imageDescription) {
                    alert("请为你的图片添加一个简单的描述（必填，给AI看的）！");
                    return;
                  }
                  newPost = {
                    ...basePostData,
                    type: "image_post",
                    publicText: publicText,
                    imageUrl: imageUrl,
                    imageDescription: imageDescription,
                  };
                } else {
                  // 文字图模式
                  const hiddenText = document
                    .getElementById("post-hidden-text")
                    .value.trim();
                  if (!hiddenText) {
                    alert("请输入文字图描述！");
                    return;
                  }
                  newPost = {
                    ...basePostData,
                    type: "text_image",
                    publicText: publicText,
                    hiddenContent: hiddenText,
                  };
                }
              }

              // --- 3. 保存到数据库 ---
              const newPostId = await db.qzonePosts.add(newPost);
              let postSummary =
                newPost.content ||
                newPost.publicText ||
                newPost.imageDescription ||
                newPost.hiddenContent ||
                "（无文字内容）";
              postSummary =
                postSummary.substring(0, 50) +
                (postSummary.length > 50 ? "..." : "");

              // --- 4. 【核心修正】带有权限检查的通知循环 ---
              for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (chat.isGroup) continue; // 跳过群聊

                let shouldNotify = false;
                const postVisibleGroups = newPost.visibleGroupIds;

                // 判断条件1：如果动态是公开的 (没有设置任何可见分组)
                if (!postVisibleGroups || postVisibleGroups.length === 0) {
                  shouldNotify = true;
                }
                // 判断条件2：如果动态设置了部分可见，并且当前角色在可见分组内
                else if (
                  chat.groupId &&
                  postVisibleGroups.includes(chat.groupId)
                ) {
                  shouldNotify = true;
                }

                // 只有满足条件的角色才会被通知
                if (shouldNotify) {
                  const historyMessage = {
                    role: "system",
                    content: `[系统提示：用户刚刚发布了一条动态(ID: ${newPostId})，内容摘要是：“${postSummary}”。你现在可以对这条动态进行评论了。]`,
                    timestamp: Date.now(),
                    isHidden: true,
                  };
                  chat.history.push(historyMessage);
                  await db.chats.put(chat);
                }
              }
              // --- 修正结束 ---

              await renderQzonePosts();
              modal.classList.remove("visible");
              alert("动态发布成功！");
            });

          const postsList = document.getElementById("qzone-posts-list");
          let swipeState = {
            isDragging: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            activeContainer: null,
            swipeDirection: null,
            isClick: true,
          };

          function resetAllSwipes(exceptThisOne = null) {
            document
              .querySelectorAll(".qzone-post-container")
              .forEach((container) => {
                if (container !== exceptThisOne) {
                  container
                    .querySelector(".qzone-post-item")
                    .classList.remove("swiped");
                }
              });
          }

          const handleSwipeStart = (e) => {
            const targetContainer = e.target.closest(".qzone-post-container");
            if (!targetContainer) return;

            resetAllSwipes(targetContainer);
            swipeState.activeContainer = targetContainer;
            swipeState.isDragging = true;
            swipeState.isClick = true;
            swipeState.swipeDirection = null;
            swipeState.startX = e.type.includes("mouse")
              ? e.pageX
              : e.touches[0].pageX;
            swipeState.startY = e.type.includes("mouse")
              ? e.pageY
              : e.touches[0].pageY;
            swipeState.activeContainer.querySelector(
              ".qzone-post-item",
            ).style.transition = "none";
          };

          const handleSwipeMove = (e) => {
            if (!swipeState.isDragging || !swipeState.activeContainer) return;

            const currentX = e.type.includes("mouse")
              ? e.pageX
              : e.touches[0].pageX;
            const currentY = e.type.includes("mouse")
              ? e.pageY
              : e.touches[0].pageY;
            const diffX = currentX - swipeState.startX;
            const diffY = currentY - swipeState.startY;
            const absDiffX = Math.abs(diffX);
            const absDiffY = Math.abs(diffY);
            const clickThreshold = 5;

            if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
              swipeState.isClick = false;
            }

            if (swipeState.swipeDirection === null) {
              if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
                if (absDiffX > absDiffY) {
                  swipeState.swipeDirection = "horizontal";
                } else {
                  swipeState.swipeDirection = "vertical";
                }
              }
            }
            if (swipeState.swipeDirection === "vertical") {
              handleSwipeEnd(e);
              return;
            }
            if (swipeState.swipeDirection === "horizontal") {
              e.preventDefault();
              swipeState.currentX = currentX;
              let translation = diffX;
              if (translation > 0) translation = 0;
              if (translation < -90) translation = -90;
              swipeState.activeContainer.querySelector(
                ".qzone-post-item",
              ).style.transform = `translateX(${translation}px)`;
            }
          };

          const handleSwipeEnd = (e) => {
            if (swipeState.isClick) {
              swipeState.isDragging = false;
              swipeState.activeContainer = null;
              return;
            }
            if (!swipeState.isDragging || !swipeState.activeContainer) return;

            const postItem =
              swipeState.activeContainer.querySelector(".qzone-post-item");
            postItem.style.transition = "transform 0.3s ease";

            const finalX = e.type.includes("touchend")
              ? e.changedTouches[0].pageX
              : e.pageX;
            const diffX = finalX - swipeState.startX;
            const swipeThreshold = -40;

            if (
              swipeState.swipeDirection === "horizontal" &&
              diffX < swipeThreshold
            ) {
              postItem.classList.add("swiped");
              postItem.style.transform = "";
            } else {
              postItem.classList.remove("swiped");
              postItem.style.transform = "";
            }

            swipeState.isDragging = false;
            swipeState.startX = 0;
            swipeState.startY = 0;
            swipeState.currentX = 0;
            swipeState.activeContainer = null;
            swipeState.swipeDirection = null;
            swipeState.isClick = true;
          };

          // --- 绑定所有滑动事件 ---
          postsList.addEventListener("mousedown", handleSwipeStart);
          document.addEventListener("mousemove", handleSwipeMove);
          document.addEventListener("mouseup", handleSwipeEnd);
          postsList.addEventListener("touchstart", handleSwipeStart, {
            passive: false,
          });
          postsList.addEventListener("touchmove", handleSwipeMove, {
            passive: false,
          });
          postsList.addEventListener("touchend", handleSwipeEnd);

          // --- 绑定所有点击事件 ---
          postsList.addEventListener("click", async (e) => {
            e.stopPropagation();
            const target = e.target;

            // --- 新增：处理评论删除按钮 ---
            if (target.classList.contains("comment-delete-btn")) {
              const postContainer = target.closest(".qzone-post-container");
              if (!postContainer) return;

              const postId = parseInt(postContainer.dataset.postId);
              const commentIndex = parseInt(target.dataset.commentIndex);
              if (isNaN(postId) || isNaN(commentIndex)) return;

              const post = await db.qzonePosts.get(postId);
              if (!post || !post.comments || !post.comments[commentIndex])
                return;

              const commentText = post.comments[commentIndex].text;
              const confirmed = await showCustomConfirm(
                "删除评论",
                `确定要删除这条评论吗？\n\n“${commentText.substring(
                  0,
                  50,
                )}...”`,
                { confirmButtonClass: "btn-danger" },
              );

              if (confirmed) {
                // 从数组中移除该评论
                post.comments.splice(commentIndex, 1);
                // 更新数据库
                await db.qzonePosts.update(postId, { comments: post.comments });
                // 重新渲染列表以反映更改
                await renderQzonePosts();
                alert("评论已删除。");
              }
              return; // 处理完后直接返回
            }

            if (target.classList.contains("post-actions-btn")) {
              const container = target.closest(".qzone-post-container");
              if (container && container.dataset.postId) {
                showPostActions(parseInt(container.dataset.postId));
              }
              return;
            }

            if (target.closest(".qzone-post-delete-action")) {
              const container = target.closest(".qzone-post-container");
              if (!container) return;

              const postIdToDelete = parseInt(container.dataset.postId);
              if (isNaN(postIdToDelete)) return;

              const confirmed = await showCustomConfirm(
                "删除动态",
                "确定要永久删除这条动态吗？",
                { confirmButtonClass: "btn-danger" },
              );

              if (confirmed) {
                container.style.transition = "all 0.3s ease";
                container.style.transform = "scale(0.8)";
                container.style.opacity = "0";

                setTimeout(async () => {
                  await db.qzonePosts.delete(postIdToDelete);

                  const notificationIdentifier = `(ID: ${postIdToDelete})`;
                  for (const chatId in state.chats) {
                    const chat = state.chats[chatId];
                    const originalHistoryLength = chat.history.length;
                    chat.history = chat.history.filter(
                      (msg) =>
                        !(
                          msg.role === "system" &&
                          msg.content.includes(notificationIdentifier)
                        ),
                    );
                    if (chat.history.length < originalHistoryLength) {
                      chat.settings.offlineMode = {
                        enabled: document.getElementById("offline-mode-toggle")
                          .checked,
                        preset: document.getElementById("offline-preset-select")
                          .value,
                        prompt: document.getElementById("offline-prompt-input")
                          .value,
                        style: document.getElementById("offline-style-input")
                          .value,
                      };

                      await db.chats.put(chat);
                    }
                  }
                  await renderQzonePosts();
                  alert("动态已删除。");
                }, 300);
              }
              return;
            }

            if (target.tagName === "IMG" && target.dataset.hiddenText) {
              const hiddenText = target.dataset.hiddenText;
              showCustomAlert("图片内容", hiddenText.replace(/<br>/g, "\n"));
              return;
            }
            const icon = target.closest(".action-icon");
            if (icon) {
              const postContainer = icon.closest(".qzone-post-container");
              if (!postContainer) return;
              const postId = parseInt(postContainer.dataset.postId);
              if (isNaN(postId)) return;
              if (icon.classList.contains("like")) {
                const post = await db.qzonePosts.get(postId);
                if (!post) return;
                if (!post.likes) post.likes = [];
                const userNickname = state.qzoneSettings.nickname;
                const userLikeIndex = post.likes.indexOf(userNickname);
                if (userLikeIndex > -1) {
                  post.likes.splice(userLikeIndex, 1);
                } else {
                  post.likes.push(userNickname);
                  icon.classList.add("animate-like");
                  icon.addEventListener(
                    "animationend",
                    () => icon.classList.remove("animate-like"),
                    { once: true },
                  );
                }
                await db.qzonePosts.update(postId, { likes: post.likes });
              }
              if (icon.classList.contains("favorite")) {
                const existingFavorite = await db.favorites
                  .where({ type: "qzone_post", "content.id": postId })
                  .first();
                if (existingFavorite) {
                  await db.favorites.delete(existingFavorite.id);
                  await showCustomAlert("提示", "已取消收藏");
                } else {
                  const postToSave = await db.qzonePosts.get(postId);
                  if (postToSave) {
                    await db.favorites.add({
                      type: "qzone_post",
                      content: postToSave,
                      timestamp: Date.now(),
                    });
                    await showCustomAlert("提示", "收藏成功！");
                  }
                }
              }
              await renderQzonePosts();
              return;
            }
            const sendBtn = target.closest(".comment-send-btn");
            if (sendBtn) {
              const postContainer = sendBtn.closest(".qzone-post-container");
              if (!postContainer) return;
              const postId = parseInt(postContainer.dataset.postId);
              const commentInput =
                postContainer.querySelector(".comment-input");
              const commentText = commentInput.value.trim();
              if (!commentText) return alert("评论内容不能为空哦！");
              const post = await db.qzonePosts.get(postId);
              if (!post) return;
              if (!post.comments) post.comments = [];
              post.comments.push({
                commenterName: state.qzoneSettings.nickname,
                text: commentText,
                timestamp: Date.now(),
              });
              await db.qzonePosts.update(postId, { comments: post.comments });
              for (const chatId in state.chats) {
                const chat = state.chats[chatId];
                if (!chat.isGroup) {
                  chat.history.push({
                    role: "system",
                    content: `[系统提示：'${state.qzoneSettings.nickname}' 在ID为${postId}的动态下发表了评论：“${commentText}”]`,
                    timestamp: Date.now(),
                    isHidden: true,
                  });
                  await db.chats.put(chat);
                }
              }
              commentInput.value = "";
              await renderQzonePosts();
              return;
            }
          });

          // 绑定动态页和收藏页的返回按钮
          document
            .getElementById("qzone-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view"),
            );
          document
            .getElementById("favorites-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view"),
            );

          // 收藏页搜索功能
          const searchInput = document.getElementById("favorites-search-input");
          const searchClearBtn = document.getElementById(
            "favorites-search-clear-btn",
          );

          searchInput.addEventListener("input", () => {
            const searchTerm = searchInput.value.trim().toLowerCase();

            // 控制清除按钮的显示/隐藏
            searchClearBtn.style.display = searchTerm ? "block" : "none";

            if (!searchTerm) {
              displayFilteredFavorites(allFavoriteItems); // 如果搜索框为空，显示所有
              return;
            }

            // 筛选逻辑
            const filteredItems = allFavoriteItems.filter((item) => {
              let contentToSearch = "";
              let authorToSearch = "";

              if (item.type === "qzone_post") {
                const post = item.content;
                contentToSearch +=
                  (post.publicText || "") + " " + (post.content || "");
                if (post.authorId === "user") {
                  authorToSearch = state.qzoneSettings.nickname;
                } else if (state.chats[post.authorId]) {
                  authorToSearch = state.chats[post.authorId].name;
                }
              } else if (item.type === "chat_message") {
                const msg = item.content;
                if (typeof msg.content === "string") {
                  contentToSearch = msg.content;
                }
                const chat = state.chats[item.chatId];
                if (chat) {
                  if (msg.role === "user") {
                    authorToSearch = chat.isGroup
                      ? chat.settings.myNickname || "我"
                      : "我";
                  } else {
                    authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                  }
                }
              }

              // 同时搜索内容和作者，并且不区分大小写
              return (
                contentToSearch.toLowerCase().includes(searchTerm) ||
                authorToSearch.toLowerCase().includes(searchTerm)
              );
            });

            displayFilteredFavorites(filteredItems);
          });

          // 清除按钮的点击事件
          searchClearBtn.addEventListener("click", () => {
            searchInput.value = "";
            searchClearBtn.style.display = "none";
            displayFilteredFavorites(allFavoriteItems);
            searchInput.focus();
          });

          // 为聊天界面的批量收藏按钮绑定事件
          // 为聊天界面的批量收藏按钮绑定事件 (已修正)
          document
            .getElementById("selection-favorite-btn")
            .addEventListener("click", async () => {
              if (selectedMessages.size === 0) return;
              const chat = state.chats[state.activeChatId];
              if (!chat) return;

              const favoritesToAdd = [];
              const timestampsToFavorite = [...selectedMessages];

              for (const timestamp of timestampsToFavorite) {
                // 【核心修正1】使用新的、高效的索引进行查询
                const existing = await db.favorites
                  .where("originalTimestamp")
                  .equals(timestamp)
                  .first();

                if (!existing) {
                  const messageToSave = chat.history.find(
                    (msg) => msg.timestamp === timestamp,
                  );
                  if (messageToSave) {
                    favoritesToAdd.push({
                      type: "chat_message",
                      content: messageToSave,
                      chatId: state.activeChatId,
                      timestamp: Date.now(), // 这是收藏操作发生的时间
                      originalTimestamp: messageToSave.timestamp, // 【核心修正2】保存原始消息的时间戳到新字段
                    });
                  }
                }
              }

              if (favoritesToAdd.length > 0) {
                await db.favorites.bulkAdd(favoritesToAdd);
                allFavoriteItems = await db.favorites
                  .orderBy("timestamp")
                  .reverse()
                  .toArray(); // 更新全局收藏缓存
                await showCustomAlert(
                  "收藏成功",
                  `已成功收藏 ${favoritesToAdd.length} 条消息。`,
                );
              } else {
                await showCustomAlert("提示", "选中的消息均已收藏过。");
              }

              exitSelectionMode();
            });

          // 收藏页面的"编辑"按钮事件 (已修正)
          const favoritesEditBtn =
            document.getElementById("favorites-edit-btn");
          const favoritesView = document.getElementById("favorites-view");
          const favoritesActionBar = document.getElementById(
            "favorites-action-bar",
          );
          const mainBottomNav = document.getElementById("chat-list-bottom-nav"); // 获取主导航栏
          const favoritesList = document.getElementById("favorites-list"); // 获取收藏列表

          favoritesEditBtn.addEventListener("click", () => {
            isFavoritesSelectionMode = !isFavoritesSelectionMode;
            favoritesView.classList.toggle(
              "selection-mode",
              isFavoritesSelectionMode,
            );

            if (isFavoritesSelectionMode) {
              // --- 进入编辑模式 ---
              favoritesEditBtn.textContent = "完成";
              favoritesActionBar.style.display = "block"; // 显示删除操作栏
            } else {
              // --- 退出编辑模式 ---
              favoritesEditBtn.textContent = "编辑";
              favoritesActionBar.style.display = "none"; // 隐藏删除操作栏

              // 退出时清空所有选择
              selectedFavorites.clear();
              document
                .querySelectorAll(".favorite-item-card.selected")
                .forEach((card) => card.classList.remove("selected"));
              document.getElementById(
                "favorites-delete-selected-btn",
              ).textContent = `删除 (0)`;
            }
          });

          // 收藏列表的点击选择事件 (事件委托)
          document
            .getElementById("favorites-list")
            .addEventListener("click", (e) => {
              const target = e.target;
              const card = target.closest(".favorite-item-card");

              // 【新增】处理文字图点击，这段逻辑要放在最前面，保证任何模式下都生效
              if (target.tagName === "IMG" && target.dataset.hiddenText) {
                const hiddenText = target.dataset.hiddenText;
                showCustomAlert("图片内容", hiddenText.replace(/<br>/g, "\n"));
                return; // 处理完就退出，不继续执行选择逻辑
              }

              // 如果不在选择模式，则不执行后续的选择操作
              if (!isFavoritesSelectionMode) return;

              // --- 以下是原有的选择逻辑，保持不变 ---
              if (!card) return;

              const favId = parseInt(card.dataset.favid);
              if (isNaN(favId)) return;

              // 切换选择状态
              if (selectedFavorites.has(favId)) {
                selectedFavorites.delete(favId);
                card.classList.remove("selected");
              } else {
                selectedFavorites.add(favId);
                card.classList.add("selected");
              }

              // 更新底部删除按钮的计数
              document.getElementById(
                "favorites-delete-selected-btn",
              ).textContent = `删除 (${selectedFavorites.size})`;
            });

          // 收藏页面批量删除按钮事件
          document
            .getElementById("favorites-delete-selected-btn")
            .addEventListener("click", async () => {
              if (selectedFavorites.size === 0) return;

              const confirmed = await showCustomConfirm(
                "确认删除",
                `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`,
                { confirmButtonClass: "btn-danger" },
              );

              if (confirmed) {
                const idsToDelete = [...selectedFavorites];
                await db.favorites.bulkDelete(idsToDelete);
                await showCustomAlert("删除成功", "选中的收藏已被移除。");

                // 【核心修正1】从前端缓存中也移除被删除的项
                allFavoriteItems = allFavoriteItems.filter(
                  (item) => !idsToDelete.includes(item.id),
                );

                // 【核心修正2】使用更新后的缓存，立即重新渲染列表
                displayFilteredFavorites(allFavoriteItems);

                // 最后，再退出编辑模式
                favoritesEditBtn.click(); // 模拟点击"完成"按钮来退出编辑模式
              }
            });

          if (state.globalSettings.enableBackgroundActivity) {
            startBackgroundSimulation();
            console.log("后台活动模拟已自动启动。");
          }

          // --- 统一处理所有影响预览的控件的事件 ---

          // 1. 监听主题选择
          document
            .querySelectorAll('input[name="theme-select"]')
            .forEach((radio) => {
              radio.addEventListener("change", updateSettingsPreview);
            });

          // 2. 监听字体大小滑块
          const fontSizeSlider = document.getElementById("font-size-slider");
          fontSizeSlider.addEventListener("input", () => {
            // a. 实时更新数值显示
            document.getElementById("font-size-value").textContent =
              `${fontSizeSlider.value}px`;
            // b. 更新预览
            updateSettingsPreview();
          });

          // 3. 监听自定义CSS输入框
          const customCssInputForPreview =
            document.getElementById("custom-css-input");
          customCssInputForPreview.addEventListener(
            "input",
            updateSettingsPreview,
          );

          // 4. 监听重置按钮
          document
            .getElementById("reset-theme-btn")
            .addEventListener("click", () => {
              document.getElementById("theme-default").checked = true;
              updateSettingsPreview();
            });

          document
            .getElementById("reset-custom-css-btn")
            .addEventListener("click", () => {
              document.getElementById("custom-css-input").value = "";
              updateSettingsPreview();
            });

          document
            .querySelectorAll('input[name="visibility"]')
            .forEach((radio) => {
              radio.addEventListener("change", function () {
                const groupsContainer = document.getElementById(
                  "post-visibility-groups",
                );
                if (this.value === "include" || this.value === "exclude") {
                  groupsContainer.style.display = "block";
                } else {
                  groupsContainer.style.display = "none";
                }
              });
            });

          document
            .getElementById("manage-groups-btn")
            .addEventListener("click", openGroupManager);
          document
            .getElementById("close-group-manager-btn")
            .addEventListener("click", () => {
              document
                .getElementById("group-management-modal")
                .classList.remove("visible");
              // 刷新聊天设置里的分组列表
              const chatSettingsBtn =
                document.getElementById("chat-settings-btn");
              if (
                document
                  .getElementById("chat-settings-modal")
                  .classList.contains("visible")
              ) {
                chatSettingsBtn.click(); // 再次点击以重新打开
              }
            });

          document
            .getElementById("add-new-group-btn")
            .addEventListener("click", addNewGroup);
          document
            .getElementById("existing-groups-list")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("delete-group-btn")) {
                const groupId = parseInt(e.target.dataset.id);
                deleteGroup(groupId);
              }
            });

          // 消息操作菜单的按钮事件
          document
            .getElementById("cancel-message-action-btn")
            .addEventListener("click", hideMessageActions);
          document
            .getElementById("edit-message-btn")
            .addEventListener("click", openAdvancedMessageEditor);
          document
            .getElementById("copy-message-btn")
            .addEventListener("click", copyMessageContent);

          document
            .getElementById("recall-message-btn")
            .addEventListener("click", handleRecallClick);

          document
            .getElementById("select-message-btn")
            .addEventListener("click", () => {
              // 【核心修复】在关闭菜单前，先捕获时间戳
              const timestampToSelect = activeMessageTimestamp;
              hideMessageActions();
              // 使用捕获到的值
              if (timestampToSelect) {
                enterSelectionMode(timestampToSelect);
              }
            });

          // 动态操作菜单的按钮事件
          document
            .getElementById("edit-post-btn")
            .addEventListener("click", openPostEditor);
          document
            .getElementById("copy-post-btn")
            .addEventListener("click", copyPostContent);
          document
            .getElementById("cancel-post-action-btn")
            .addEventListener("click", hidePostActions);

          document
            .getElementById("cancel-contact-picker-btn")
            .addEventListener("click", () => {
              showScreen("chat-list-screen");
            });

          document
            .getElementById("contact-picker-list")
            .addEventListener("click", (e) => {
              const item = e.target.closest(".contact-picker-item");
              if (!item) return;

              const contactId = item.dataset.contactId;
              item.classList.toggle("selected");

              if (selectedContacts.has(contactId)) {
                selectedContacts.delete(contactId);
              } else {
                selectedContacts.add(contactId);
              }
              updateContactPickerConfirmButton();
            });

          document
            .getElementById("manage-members-btn")
            .addEventListener("click", () => {
              // 在切换屏幕前，先隐藏当前的聊天设置弹窗
              document
                .getElementById("chat-settings-modal")
                .classList.remove("visible");
              // 然后再打开成员管理屏幕
              openMemberManagementScreen();
            });

          document
            .getElementById("back-from-member-management")
            .addEventListener("click", () => {
              showScreen("chat-interface-screen");
              document.getElementById("chat-settings-btn").click();
            });

          document
            .getElementById("member-management-list")
            .addEventListener("click", (e) => {
              // 【已恢复】移除成员的事件
              if (e.target.classList.contains("remove-member-btn")) {
                removeMemberFromGroup(e.target.dataset.memberId);
              }
            });

          document
            .getElementById("add-existing-contact-btn")
            .addEventListener("click", async () => {
              // 【已恢复】从好友列表添加的事件
              // 【关键】为“完成”按钮绑定“拉人入群”的逻辑
              const confirmBtn = document.getElementById(
                "confirm-contact-picker-btn",
              );
              // 使用克隆节点方法清除旧的事件监听器，防止重复绑定
              const newConfirmBtn = confirmBtn.cloneNode(true);
              confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
              newConfirmBtn.addEventListener("click", handleAddMembersToGroup);

              await openContactPickerForAddMember();
            });

          document
            .getElementById("create-new-member-btn")
            .addEventListener("click", createNewMemberInGroup);

          // 绑定单聊和群聊的发起按钮
          document
            .getElementById("video-call-btn")
            .addEventListener("click", handleInitiateCall);
          document
            .getElementById("group-video-call-btn")
            .addEventListener("click", handleInitiateCall);

          // 绑定“挂断”按钮
          document
            .getElementById("hang-up-btn")
            .addEventListener("click", endVideoCall);

          // 绑定“取消呼叫”按钮
          document
            .getElementById("cancel-call-btn")
            .addEventListener("click", () => {
              videoCallState.isAwaitingResponse = false;
              showScreen("chat-interface-screen");
            });

          // 【全新】绑定“加入通话”按钮
          document
            .getElementById("join-call-btn")
            .addEventListener("click", handleUserJoinCall);

          document
            .getElementById("offline-mode-toggle")
            .addEventListener("change", (e) => {
              document.getElementById("offline-mode-config").style.display = e
                .target.checked
                ? "block"
                : "none";
            });

          // 绑定来电请求的“拒绝”按钮
          document
            .getElementById("decline-call-btn")
            .addEventListener("click", async () => {
              hideIncomingCallModal();
              const chat = state.chats[videoCallState.activeChatId];
              if (!chat) return;

              // 【核心修正】在这里，我们将拒绝的逻辑与API调用连接起来
              if (videoCallState.isGroupCall) {
                videoCallState.isUserParticipating = false; // 标记用户为旁观者

                // 1. 创建一条隐藏消息，通知AI用户拒绝了
                const systemNote = {
                  role: "system",
                  content: `[系统提示：用户拒绝了通话邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(systemNote);
                await db.chats.put(chat);

                // 2. 【关键】触发AI响应，让它们自己决定要不要开始群聊
                // 这将会在后台处理，如果AI们决定开始，最终会调用 startVideoCall()
                await triggerAiResponse();
              } else {
                // 单聊拒绝逻辑保持不变
                const declineMessage = {
                  role: "user",
                  content: "我拒绝了你的视频通话请求。",
                  timestamp: Date.now(),
                };
                chat.history.push(declineMessage);
                await db.chats.put(chat);

                // 回到聊天界面并显示拒绝消息
                showScreen("chat-interface-screen");
                appendMessage(declineMessage, chat);

                // 让AI对你的拒绝做出回应
                triggerAiResponse();
              }

              // 清理状态，以防万一
              videoCallState.isAwaitingResponse = false;
            });

          // 绑定来电请求的“接听”按钮
          document
            .getElementById("accept-call-btn")
            .addEventListener("click", async () => {
              hideIncomingCallModal();

              videoCallState.initiator = "ai";
              videoCallState.isUserParticipating = true;
              videoCallState.activeChatId = state.activeChatId;

              // 【核心修正】我们在这里不再手动添加用户到 participants 列表
              if (videoCallState.isGroupCall) {
                // 对于群聊，我们只把【发起通话的AI】加入参与者列表
                const chat = state.chats[videoCallState.activeChatId];
                const requester = chat.members.find(
                  (m) => m.name === videoCallState.callRequester,
                );
                if (requester) {
                  // 清空可能存在的旧数据，然后只添加发起者
                  videoCallState.participants = [requester];
                } else {
                  videoCallState.participants = []; // 如果找不到发起者，就清空
                }
              }

              // 无论单聊还是群聊，直接启动通话界面！
              startVideoCall();
            });

          // 绑定用户在通话中发言的按钮
          document
            .getElementById("user-speak-btn")
            .addEventListener("click", async () => {
              if (!videoCallState.isActive) return;

              // ★★★★★ 核心新增：在弹出输入框前，先找到并高亮用户头像 ★★★★★
              const userAvatar = document.querySelector(
                '.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar',
              );
              if (userAvatar) {
                userAvatar.classList.add("speaking");
              }

              const userInput = await showCustomPrompt(
                "你说",
                "请输入你想说的话...",
              );

              // ★★★★★ 核心新增：无论用户是否输入，只要关闭输入框就移除高亮 ★★★★★
              if (userAvatar) {
                userAvatar.classList.remove("speaking");
              }

              if (userInput && userInput.trim()) {
                triggerAiInCallAction(userInput.trim());
              }
            });

          // 1. 将“回忆”页签和它的视图连接起来
          document
            .querySelector('.nav-item[data-view="memories-view"]')
            .addEventListener("click", () => {
              // 在切换前，确保"收藏"页面的编辑模式已关闭
              if (isFavoritesSelectionMode) {
                document.getElementById("favorites-edit-btn").click();
              }
              switchToChatListView("memories-view");
              renderMemoriesScreen(); // 点击时渲染
            });

          // 2. 绑定回忆录界面的返回按钮
          document
            .getElementById("memories-back-btn")
            .addEventListener("click", () =>
              switchToChatListView("messages-view"),
            );

          // 【全新】约定/倒计时功能事件绑定
          document
            .getElementById("add-countdown-btn")
            .addEventListener("click", () => {
              document
                .getElementById("create-countdown-modal")
                .classList.add("visible");
            });
          document
            .getElementById("cancel-create-countdown-btn")
            .addEventListener("click", () => {
              document
                .getElementById("create-countdown-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("confirm-create-countdown-btn")
            .addEventListener("click", async () => {
              const title = document
                .getElementById("countdown-title-input")
                .value.trim();
              const dateValue = document.getElementById(
                "countdown-date-input",
              ).value;

              if (!title || !dateValue) {
                alert("请填写完整的约定标题和日期！");
                return;
              }

              const targetDate = new Date(dateValue);
              if (isNaN(targetDate) || targetDate <= new Date()) {
                alert("请输入一个有效的、未来的日期！");
                return;
              }

              const newCountdown = {
                chatId: null, // 用户创建的，不属于任何特定AI
                authorName: "我",
                description: title,
                timestamp: Date.now(),
                type: "countdown",
                targetDate: targetDate.getTime(),
              };

              await db.memories.add(newCountdown);
              document
                .getElementById("create-countdown-modal")
                .classList.remove("visible");
              renderMemoriesScreen();
            });

          // 【全新】拉黑功能事件绑定
          document
            .getElementById("block-chat-btn")
            .addEventListener("click", async () => {
              if (
                !state.activeChatId ||
                state.chats[state.activeChatId].isGroup
              )
                return;

              const chat = state.chats[state.activeChatId];
              const confirmed = await showCustomConfirm(
                "确认拉黑",
                `确定要拉黑“${chat.name}”吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`,
                { confirmButtonClass: "btn-danger" },
              );

              if (confirmed) {
                chat.relationship.status = "blocked_by_user";
                chat.relationship.blockedTimestamp = Date.now();

                const hiddenMessage = {
                  role: "system",
                  content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
                  timestamp: Date.now() + 1,
                  isHidden: true,
                };
                chat.history.push(hiddenMessage);

                await db.chats.put(chat);

                // 关闭设置弹窗，并刷新聊天界面
                document
                  .getElementById("chat-settings-modal")
                  .classList.remove("visible");
                renderChatInterface(state.activeChatId);
                // 刷新聊天列表，可能会有UI变化
                renderChatList();
              }
            });

          document
            .getElementById("chat-lock-overlay")
            .addEventListener("click", async (e) => {
              const chat = state.chats[state.activeChatId];
              if (!chat) return;

              if (e.target.id === "force-apply-check-btn") {
                alert(
                  "正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。",
                );
                await triggerAiFriendApplication(chat.id);
                renderChatInterface(chat.id);
                return;
              }

              if (e.target.id === "unblock-btn") {
                chat.relationship.status = "friend";
                chat.relationship.blockedTimestamp = null;

                const hiddenMessage = {
                  role: "system",
                  content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(hiddenMessage);

                await db.chats.put(chat);
                renderChatInterface(chat.id);
                renderChatList();
                triggerAiResponse(); // 【可选但推荐】解除后让AI主动说点什么
              } else if (e.target.id === "accept-friend-btn") {
                chat.relationship.status = "friend";
                chat.relationship.applicationReason = "";

                const hiddenMessage = {
                  role: "system",
                  content: `[系统提示：用户刚刚通过了你的好友申请。你们现在又可以正常聊天了。]`,
                  timestamp: Date.now(),
                  isHidden: true,
                };
                chat.history.push(hiddenMessage);

                await db.chats.put(chat);
                renderChatInterface(chat.id);
                renderChatList();
                const msg = {
                  role: "user",
                  content: "我通过了你的好友请求",
                  timestamp: Date.now(),
                };
                chat.history.push(msg);
                await db.chats.put(chat);
                appendMessage(msg, chat);
                triggerAiResponse();
              } else if (e.target.id === "reject-friend-btn") {
                chat.relationship.status = "blocked_by_user";
                chat.relationship.blockedTimestamp = Date.now();
                chat.relationship.applicationReason = "";
                await db.chats.put(chat);
                renderChatInterface(chat.id);
              }
              // 【新增】处理申请好友按钮的点击事件
              else if (e.target.id === "apply-friend-btn") {
                const reason = await showCustomPrompt(
                  "发送好友申请",
                  `请输入你想对“${chat.name}”说的申请理由：`,
                  "我们和好吧！",
                );
                // 只有当用户输入了内容并点击“确定”后才继续
                if (reason !== null) {
                  // 更新关系状态为“等待AI批准”
                  chat.relationship.status = "pending_ai_approval";
                  chat.relationship.applicationReason = reason;
                  await db.chats.put(chat);

                  // 刷新UI，显示“等待通过”的界面
                  renderChatInterface(chat.id);
                  renderChatList();

                  // 【关键】触发AI响应，让它去处理这个好友申请
                  triggerAiResponse();
                }
              }
            });

          // 1. 转账按钮 - 打开转账弹窗
          document
            .getElementById("transfer-btn")
            .addEventListener("click", () => {
              document.getElementById("transfer-modal").classList.add("visible");
            });

          // 2. 红包按钮 - 打开红包弹窗
          document
            .getElementById("red-packet-btn")
            .addEventListener("click", () => {
              openRedPacketModal();
            });

          // 3. 红包模态框内部的控制按钮
          document
            .getElementById("cancel-red-packet-btn")
            .addEventListener("click", () => {
              document
                .getElementById("red-packet-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("send-group-packet-btn")
            .addEventListener("click", sendGroupRedPacket);
          document
            .getElementById("send-direct-packet-btn")
            .addEventListener("click", sendDirectRedPacket);

          // 3. 红包模态框的页签切换逻辑
          const rpTabGroup = document.getElementById("rp-tab-group");
          const rpTabDirect = document.getElementById("rp-tab-direct");
          const rpContentGroup = document.getElementById("rp-content-group");
          const rpContentDirect = document.getElementById("rp-content-direct");

          rpTabGroup.addEventListener("click", () => {
            rpTabGroup.classList.add("active");
            rpTabDirect.classList.remove("active");
            rpContentGroup.style.display = "block";
            rpContentDirect.style.display = "none";
          });
          rpTabDirect.addEventListener("click", () => {
            rpTabDirect.classList.add("active");
            rpTabGroup.classList.remove("active");
            rpContentDirect.style.display = "block";
            rpContentGroup.style.display = "none";
          });

          // 4. 实时更新红包金额显示
          document
            .getElementById("rp-group-amount")
            .addEventListener("input", (e) => {
              const amount = parseFloat(e.target.value) || 0;
              document.getElementById("rp-group-total").textContent =
                `¥ ${amount.toFixed(2)}`;
            });
          document
            .getElementById("rp-direct-amount")
            .addEventListener("input", (e) => {
              const amount = parseFloat(e.target.value) || 0;
              document.getElementById("rp-direct-total").textContent =
                `¥ ${amount.toFixed(2)}`;
            });

          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 1. 找到被点击的红包卡片
              const packetCard = e.target.closest(".red-packet-card");
              if (!packetCard) return; // 如果点击的不是红包，就什么也不做

              // 2. 从红包卡片的父级.message-bubble获取时间戳
              const messageBubble = packetCard.closest(".message-bubble");
              if (!messageBubble || !messageBubble.dataset.timestamp) return;

              // 3. 调用我们现有的处理函数
              const timestamp = parseInt(messageBubble.dataset.timestamp);
              handlePacketClick(timestamp);
            });

          // 在输入框工具栏添加按钮
          document
            .getElementById("send-poll-btn")
            .addEventListener("click", openCreatePollModal);

          // 投票创建模态框的按钮
          document
            .getElementById("add-poll-option-btn")
            .addEventListener("click", addPollOptionInput);
          document
            .getElementById("cancel-create-poll-btn")
            .addEventListener("click", () => {
              document
                .getElementById("create-poll-modal")
                .classList.remove("visible");
            });
          document
            .getElementById("confirm-create-poll-btn")
            .addEventListener("click", sendPoll);

          // 使用事件委托处理投票卡片内的所有点击事件
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              const pollCard = e.target.closest(".poll-card");
              if (!pollCard) return;

              const timestamp = parseInt(pollCard.dataset.pollTimestamp);
              if (isNaN(timestamp)) return;

              // 点击了选项
              const optionItem = e.target.closest(".poll-option-item");
              if (optionItem && !pollCard.classList.contains("closed")) {
                handleUserVote(timestamp, optionItem.dataset.option);
                return;
              }

              // 点击了动作按钮（结束投票/查看结果）
              const actionBtn = e.target.closest(".poll-action-btn");
              if (actionBtn) {
                if (pollCard.classList.contains("closed")) {
                  showPollResults(timestamp);
                } else {
                  endPoll(timestamp);
                }
                return;
              }

              // 如果是已结束的投票，点击卡片任何地方都可以查看结果
              if (pollCard.classList.contains("closed")) {
                showPollResults(timestamp);
              }
            });

          document
            .getElementById("manage-ai-avatar-library-btn")
            .addEventListener("click", openAiAvatarLibraryModal);
          document
            .getElementById("add-ai-avatar-btn")
            .addEventListener("click", addAvatarToLibrary);
          document
            .getElementById("close-ai-avatar-library-btn")
            .addEventListener("click", closeAiAvatarLibraryModal);

          document
            .getElementById("icon-settings-grid")
            .addEventListener("click", async (e) => {
              if (e.target.classList.contains("change-icon-btn")) {
                const item = e.target.closest(".icon-setting-item");
                const iconId = item.dataset.iconId;
                if (!iconId) return;

                const currentUrl = state.globalSettings.appIcons[iconId];
                const newUrl = await showCustomPrompt(
                  `更换“${item.querySelector(".icon-preview").alt}”图标`,
                  "请输入新的图片URL",
                  currentUrl,
                  "url",
                );

                if (newUrl && newUrl.trim().startsWith("http")) {
                  // 仅在内存中更新，等待用户点击“保存”
                  state.globalSettings.appIcons[iconId] = newUrl.trim();
                  // 实时更新设置页面的预览图
                  item.querySelector(".icon-preview").src = newUrl.trim();
                } else if (newUrl !== null) {
                  alert("请输入一个有效的URL！");
                }
              }
            });

          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 使用 .closest() 向上查找被点击的卡片
              const linkCard = e.target.closest(".link-share-card");
              if (linkCard) {
                const timestamp = parseInt(linkCard.dataset.timestamp);
                if (!isNaN(timestamp)) {
                  openBrowser(timestamp); // 调用我们的函数
                }
              }
            });

          // 浏览器返回按钮的事件监听，确保它只绑定一次
          document
            .getElementById("browser-back-btn")
            .addEventListener("click", () => {
              showScreen("chat-interface-screen");
            });

          // 1. 绑定输入框上方“分享链接”按钮的点击事件
          document
            .getElementById("share-link-btn")
            .addEventListener("click", openShareLinkModal);

          // 2. 绑定模态框中“取消”按钮的点击事件
          document
            .getElementById("cancel-share-link-btn")
            .addEventListener("click", () => {
              document
                .getElementById("share-link-modal")
                .classList.remove("visible");
            });

          // 3. 绑定模态框中“分享”按钮的点击事件
          document
            .getElementById("confirm-share-link-btn")
            .addEventListener("click", sendUserLinkShare);

          document
            .getElementById("theme-toggle-switch")
            .addEventListener("change", toggleTheme);

          const sizePanelToggle = document.getElementById("show-size-panel-toggle");
          if (sizePanelToggle) {
            sizePanelToggle.checked = state.globalSettings.showSizePanel ?? false;
            sizePanelToggle.addEventListener("change", async () => {
              const settings =
                (await db.globalSettings.get("main")) || state.globalSettings;
              settings.showSizePanel = sizePanelToggle.checked;
              state.globalSettings.showSizePanel = sizePanelToggle.checked;
              await db.globalSettings.put(settings);
              
              // === 新增：同步面板可见性缓存 ===
              localStorage.setItem('ephone-panel-visibility', JSON.stringify({
                showPhoneSizePanel: sizePanelToggle.checked
              }));
              
              applyPhoneSizePanelVisibility(sizePanelToggle.checked);
            });
          }

          // 绑定消息操作菜单中的“引用”按钮
          document
            .getElementById("quote-message-btn")
            .addEventListener("click", startReplyToMessage);

          // 绑定回复预览栏中的“取消”按钮
          document
            .getElementById("cancel-reply-btn")
            .addEventListener("click", cancelReplyMode);

          // 在你的 init() 函数的事件监听器区域...

          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 1. 向上查找被点击的元素是否在一个消息气泡内
              const bubble = e.target.closest(".message-bubble");
              if (!bubble) return; // 如果不在，就退出

              // 2. 【核心修正】在这里添加严格的筛选条件
              // 必须是 AI 的消息 (.ai)
              // 必须是转账类型 (.is-transfer)
              // 必须是我们标记为“待处理”的 (data-status="pending")
              if (
                bubble.classList.contains("ai") &&
                bubble.classList.contains("is-transfer") &&
                bubble.dataset.status === "pending"
              ) {
                // 3. 只有满足所有条件，才执行后续逻辑
                const timestamp = parseInt(bubble.dataset.timestamp);
                if (!isNaN(timestamp)) {
                  showTransferActionModal(timestamp);
                }
              }
            });

          // 在 init() 的事件监听区域添加
          document
            .getElementById("transfer-action-accept")
            .addEventListener("click", () =>
              handleUserTransferResponse("accepted"),
            );
          document
            .getElementById("transfer-action-decline")
            .addEventListener("click", () =>
              handleUserTransferResponse("declined"),
            );
          document
            .getElementById("transfer-action-cancel")
            .addEventListener("click", hideTransferActionModal);

          document
            .getElementById("chat-list-title")
            .addEventListener("click", renderCallHistoryScreen);

          // 2. 绑定通话记录页面的“返回”按钮
          document
            .getElementById("call-history-back-btn")
            .addEventListener("click", () => {
              // 【核心修改】返回到聊天列表页面，而不是聊天界面
              showScreen("chat-list-screen");
            });

          // 3. 监听卡片点击的逻辑保持不变
          document
            .getElementById("call-history-list")
            .addEventListener("click", (e) => {
              const card = e.target.closest(".call-record-card");
              if (card && card.dataset.recordId) {
                showCallTranscript(parseInt(card.dataset.recordId));
              }
            });

          // 4. 关闭详情弹窗的逻辑保持不变
          document
            .getElementById("close-transcript-modal-btn")
            .addEventListener("click", () => {
              document
                .getElementById("call-transcript-modal")
                .classList.remove("visible");
            });

          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 1. 检查点击的是否是语音条
              const voiceBody = e.target.closest(".voice-message-body");
              if (!voiceBody) return;

              // 2. 找到相关的DOM元素
              const bubble = voiceBody.closest(".message-bubble");
              if (!bubble) return;

              const waveIcon = voiceBody.querySelector(".wave-icon");
              const transcriptEl = bubble.querySelector(".voice-transcript");

              // 如果正在加载中，则不响应点击
              if (bubble.dataset.state === "loading") {
                return;
              }

              // 3. 如果文字已经展开，则收起
              if (bubble.dataset.state === "expanded") {
                transcriptEl.style.display = "none";
                bubble.dataset.state = "collapsed";
              } else {
                // 直接获取文字并显示
                const voiceText = bubble.dataset.voiceText || "(无法识别)";
                transcriptEl.textContent = voiceText; // 填充文字

                transcriptEl.style.display = "block"; // 显示文字容器
                bubble.dataset.state = "expanded"; // 标记为已展开状态
              }
            });

          document
            .getElementById("chat-header-status")
            .addEventListener("click", handleEditStatusClick);

          // 在 init() 的事件监听器区域添加
          document
            .getElementById("selection-share-btn")
            .addEventListener("click", () => {
              if (selectedMessages.size > 0) {
                openShareTargetPicker(); // 打开我们即将创建的目标选择器
              }
            });

          // 在 init() 的事件监听器区域添加
          document
            .getElementById("confirm-share-target-btn")
            .addEventListener("click", async () => {
              const sourceChat = state.chats[state.activeChatId];
              const selectedTargetIds = Array.from(
                document.querySelectorAll(".share-target-checkbox:checked"),
              ).map((cb) => cb.dataset.chatId);

              if (selectedTargetIds.length === 0) {
                alert("请至少选择一个要分享的聊天。");
                return;
              }

              // 1. 打包聊天记录
              const sharedHistory = [];
              const sortedTimestamps = [...selectedMessages].sort(
                (a, b) => a - b,
              );
              for (const timestamp of sortedTimestamps) {
                const msg = sourceChat.history.find(
                  (m) => m.timestamp === timestamp,
                );
                if (msg) {
                  sharedHistory.push(msg);
                }
              }

              // 2. 创建分享卡片消息对象
              const shareCardMessage = {
                role: "user",
                senderName: sourceChat.isGroup
                  ? sourceChat.settings.myNickname || "我"
                  : "我",
                type: "share_card",
                timestamp: Date.now(),
                payload: {
                  sourceChatName: sourceChat.name,
                  title: `来自“${sourceChat.name}”的聊天记录`,
                  sharedHistory: sharedHistory,
                },
              };

              // 3. 循环发送到所有目标聊天
              for (const targetId of selectedTargetIds) {
                const targetChat = state.chats[targetId];
                if (targetChat) {
                  targetChat.history.push(shareCardMessage);
                  await db.chats.put(targetChat);
                }
              }

              // 4. 收尾工作
              document
                .getElementById("share-target-modal")
                .classList.remove("visible");
              exitSelectionMode(); // 退出多选模式
              await showCustomAlert(
                "分享成功",
                `聊天记录已成功分享到 ${selectedTargetIds.length} 个会话中。`,
              );
              renderChatList(); // 刷新列表，可能会有新消息提示
            });

          // 绑定取消按钮
          document
            .getElementById("cancel-share-target-btn")
            .addEventListener("click", () => {
              document
                .getElementById("share-target-modal")
                .classList.remove("visible");
            });

          // 在 init() 的事件监听器区域添加
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // ...你已有的其他点击事件逻辑...

              // 新增逻辑：处理分享卡片的点击
              const shareCard = e.target.closest(
                ".link-share-card[data-timestamp]",
              );
              if (
                shareCard &&
                shareCard.closest(".message-bubble.is-link-share")
              ) {
                const timestamp = parseInt(shareCard.dataset.timestamp);
                openSharedHistoryViewer(timestamp);
              }
            });

          // 绑定查看器的关闭按钮
          document
            .getElementById("close-shared-history-viewer-btn")
            .addEventListener("click", () => {
              document
                .getElementById("shared-history-viewer-modal")
                .classList.remove("visible");
            });

          // 创建新函数来处理渲染逻辑
          function openSharedHistoryViewer(timestamp) {
            const chat = state.chats[state.activeChatId];
            const message = chat.history.find((m) => m.timestamp === timestamp);
            if (!message || message.type !== "share_card") return;

            const viewerModal = document.getElementById(
              "shared-history-viewer-modal",
            );
            const viewerTitle = document.getElementById(
              "shared-history-viewer-title",
            );
            const viewerContent = document.getElementById(
              "shared-history-viewer-content",
            );

            viewerTitle.textContent = message.payload.title;
            viewerContent.innerHTML = ""; // 清空旧内容

            // 【核心】复用 createMessageElement 来渲染每一条被分享的消息
            message.payload.sharedHistory.forEach((sharedMsg) => {
              // 注意：这里我们传入的是 sourceChat 对象，以确保头像、昵称等正确
              const sourceChat =
                Object.values(state.chats).find(
                  (c) => c.name === message.payload.sourceChatName,
                ) || chat;
              const bubbleEl = createMessageElement(sharedMsg, sourceChat);
              if (bubbleEl) {
                viewerContent.appendChild(bubbleEl);
              }
            });

            viewerModal.classList.add("visible");
          }

          audioPlayer.addEventListener("timeupdate", updateMusicProgressBar);

          audioPlayer.addEventListener("pause", () => {
            if (musicState.isActive) {
              musicState.isPlaying = false;
              updatePlayerUI();
            }
          });
          audioPlayer.addEventListener("play", () => {
            if (musicState.isActive) {
              musicState.isPlaying = true;
              updatePlayerUI();
            }
          });

          document
            .getElementById("playlist-body")
            .addEventListener("click", async (e) => {
              const target = e.target;
              if (target.classList.contains("delete-track-btn")) {
                const index = parseInt(target.dataset.index);
                const track = musicState.playlist[index];
                const confirmed = await showCustomConfirm(
                  "删除歌曲",
                  `确定要从播放列表中删除《${track.name}》吗？`,
                );
                if (confirmed) {
                  deleteTrack(index);
                }
                return;
              }
              if (target.classList.contains("lyrics-btn")) {
                const index = parseInt(target.dataset.index);
                if (isNaN(index)) return;
                const lrcContent = await new Promise((resolve) => {
                  const lrcInput = document.getElementById("lrc-upload-input");
                  const handler = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                      const reader = new FileReader();
                      reader.onload = (re) => resolve(re.target.result);
                      reader.readAsText(file);
                    } else {
                      resolve(null);
                    }
                    lrcInput.removeEventListener("change", handler);
                    lrcInput.value = "";
                  };
                  lrcInput.addEventListener("change", handler);
                  lrcInput.click();
                });
                if (lrcContent !== null) {
                  musicState.playlist[index].lrcContent = lrcContent;
                  await saveGlobalPlaylist();
                  alert("歌词导入成功！");
                  if (musicState.currentIndex === index) {
                    musicState.parsedLyrics = parseLRC(lrcContent);
                    renderLyrics();
                  }
                }
              }
            });

          document
            .querySelector(".progress-bar")
            .addEventListener("click", (e) => {
              if (!audioPlayer.duration) return;
              const progressBar = e.currentTarget;
              const barWidth = progressBar.clientWidth;
              const clickX = e.offsetX;
              audioPlayer.currentTime =
                (clickX / barWidth) * audioPlayer.duration;
            });

          // 使用事件委托来处理所有“已撤回消息”的点击事件
          document
            .getElementById("chat-messages")
            .addEventListener("click", (e) => {
              // 检查被点击的元素或其父元素是否是“已撤回”提示
              const placeholder = e.target.closest(
                ".recalled-message-placeholder",
              );
              if (!placeholder) return; // 如果不是，就退出

              // 如果是，就从聊天记录中找到对应的数据并显示
              const chat = state.chats[state.activeChatId];
              const wrapper = placeholder.closest(".message-wrapper"); // 找到它的父容器
              if (chat && wrapper) {
                // 从父容器上找到时间戳
                const timestamp = parseInt(wrapper.dataset.timestamp);
                const recalledMsg = chat.history.find(
                  (m) => m.timestamp === timestamp,
                );

                if (recalledMsg && recalledMsg.recalledData) {
                  let originalContentText = "";
                  const recalled = recalledMsg.recalledData;

                  if (recalled.originalType === "text") {
                    originalContentText = `原文: "${recalled.originalContent}"`;
                  } else {
                    originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
                  }
                  showCustomAlert("已撤回的消息", originalContentText);
                }
              }
            });

          document
            .getElementById("manage-world-book-categories-btn")
            .addEventListener("click", openCategoryManager);
          document
            .getElementById("close-category-manager-btn")
            .addEventListener("click", () => {
              document
                .getElementById("world-book-category-manager-modal")
                .classList.remove("visible");
              renderWorldBookScreen(); // 关闭后刷新主列表
            });
          document
            .getElementById("add-new-category-btn")
            .addEventListener("click", addNewCategory);
          document
            .getElementById("existing-categories-list")
            .addEventListener("click", (e) => {
              if (e.target.classList.contains("delete-group-btn")) {
                const categoryId = parseInt(e.target.dataset.id);
                deleteCategory(categoryId);
              }
            });

          const manageApiPresetsBtn = document.getElementById(
            "manage-api-presets-btn",
          );
          const apiPresetsModal = document.getElementById("api-presets-modal");
          const apiPresetsList = document.getElementById("api-presets-list");
          const savePresetNameInput = document.getElementById(
            "save-preset-name-input",
          );
          const savePresetBtn = document.getElementById("save-preset-btn");
          const closeApiPresetsModalBtn = document.getElementById(
            "close-api-presets-modal-btn",
          );

          if (manageApiPresetsBtn) {
            manageApiPresetsBtn.addEventListener("click", () => {
              renderApiPresetsList();
              apiPresetsModal.classList.add("visible");
            });
          }

          if (closeApiPresetsModalBtn) {
            closeApiPresetsModalBtn.addEventListener("click", () => {
              apiPresetsModal.classList.remove("visible");
            });
          }

          if (savePresetBtn) {
            savePresetBtn.addEventListener("click", async () => {
              const name = savePresetNameInput.value.trim();
              if (!name) return alert("请输入配置名称");

              const newPreset = {
                name,
                proxyUrl: document.getElementById("proxy-url").value.trim(),
                apiKey: document.getElementById("api-key").value.trim(),
                model: document.getElementById("model-select").value,
                enableStreaming: document.getElementById(
                  "stream-request-switch",
                ).checked,
              };

              if (!state.globalSettings.apiPresets) {
                state.globalSettings.apiPresets = [];
              }

              // Check for duplicate name and overwrite
              const existingIndex = state.globalSettings.apiPresets.findIndex(
                (p) => p.name === name,
              );
              if (existingIndex > -1) {
                if (!confirm(`配置 "${name}" 已存在，是否覆盖？`)) return;
                state.globalSettings.apiPresets[existingIndex] = newPreset;
              } else {
                state.globalSettings.apiPresets.push(newPreset);
              }

              await db.globalSettings.put(state.globalSettings);
              renderApiPresetsList();
              savePresetNameInput.value = "";
              alert("配置已保存");
            });
          }

          function renderApiPresetsList() {
            apiPresetsList.innerHTML = "";
            const presets = state.globalSettings.apiPresets || [];
            if (presets.length === 0) {
              apiPresetsList.innerHTML =
                '<div style="text-align:center; color:#999; padding:20px;">暂无保存的配置</div>';
              return;
            }

            presets.forEach((preset, index) => {
              const item = document.createElement("div");
              item.style.cssText =
                "display:flex; justify-content:space-between; align-items:center; padding:10px; border-bottom:1px solid #eee;";

              const info = document.createElement("div");
              info.innerHTML = `<strong>${
                preset.name
              }</strong><br><span style="font-size:12px; color:#666;">${
                preset.model
              } | ${preset.proxyUrl ? "Proxy" : "Direct"}</span>`;

              const actions = document.createElement("div");
              actions.style.display = "flex";
              actions.style.gap = "5px";

              const loadBtn = document.createElement("button");
              loadBtn.textContent = "加载";
              loadBtn.className = "form-button";
              loadBtn.style.cssText =
                "padding:5px 10px; font-size:12px; width:auto;";
              loadBtn.onclick = () => loadApiPreset(preset);

              const deleteBtn = document.createElement("button");
              deleteBtn.textContent = "删除";
              deleteBtn.className = "form-button";
              deleteBtn.style.cssText =
                "padding:5px 10px; font-size:12px; width:auto; background-color:#ff3b30;";
              deleteBtn.onclick = () => deleteApiPreset(index);

              actions.appendChild(loadBtn);
              actions.appendChild(deleteBtn);
              item.appendChild(info);
              item.appendChild(actions);
              apiPresetsList.appendChild(item);
            });
          }

          function loadApiPreset(preset) {
            document.getElementById("proxy-url").value = preset.proxyUrl || "";
            document.getElementById("api-key").value = preset.apiKey || "";
            document.getElementById("stream-request-switch").checked =
              preset.enableStreaming || false;

            const modelSelect = document.getElementById("model-select");
            if (preset.model) {
              let optionExists = false;
              for (let i = 0; i < modelSelect.options.length; i++) {
                if (modelSelect.options[i].value === preset.model) {
                  optionExists = true;
                  break;
                }
              }
              if (!optionExists) {
                const opt = document.createElement("option");
                opt.value = preset.model;
                opt.textContent = preset.model + " (来自配置)";
                modelSelect.appendChild(opt);
              }
              modelSelect.value = preset.model;
            }

            apiPresetsModal.classList.remove("visible");
            alert(`已加载配置 "${preset.name}"，请点击“保存设置”以应用。`);
          }

          async function deleteApiPreset(index) {
            if (!confirm("确定删除此配置吗？")) return;
            state.globalSettings.apiPresets.splice(index, 1);
            await db.globalSettings.put(state.globalSettings);
            renderApiPresetsList();
          }

          // ===================================================================
          // 5. 启动！

          // Paging Logic (Home Screen Slider)
          const slider = document.querySelector(".home-screen-slider");
          const dots = document.querySelectorAll(".home-screen-dots .dot");
          if (slider && dots.length) {
            // 1. Update Dots on Scroll
            slider.addEventListener("scroll", () => {
              const pageIndex = Math.round(
                slider.scrollLeft / slider.clientWidth,
              );
              dots.forEach((d, i) => {
                d.style.opacity = i === pageIndex ? "1" : "0.4";
                d.classList.toggle("active", i === pageIndex);
              });
            });

            // 2. Mouse Drag Support
            let isDown = false;
            let startX;
            let scrollLeft;

            slider.addEventListener("mousedown", (e) => {
              isDown = true;
              slider.style.cursor = "grabbing";
              slider.style.scrollSnapType = "none"; // Disable snap while dragging
              startX = e.pageX - slider.offsetLeft;
              scrollLeft = slider.scrollLeft;
            });

            const snapToPage = () => {
              isDown = false;
              slider.style.cursor = "grab";
              slider.style.scrollSnapType = "x mandatory"; // Re-enable snap
              // Manual smooth snap to nearest page
              const pageIndex = Math.round(
                slider.scrollLeft / slider.clientWidth,
              );
              slider.scrollTo({
                left: pageIndex * slider.clientWidth,
                behavior: "smooth",
              });
            };

            slider.addEventListener("mouseleave", () => {
              if (isDown) snapToPage();
            });

            slider.addEventListener("mouseup", () => {
              if (isDown) snapToPage();
            });

            slider.addEventListener("mousemove", (e) => {
              if (!isDown) return;
              e.preventDefault();
              const x = e.pageX - slider.offsetLeft;
              const walk = (x - startX) * 1.5; // Drag speed multiplier
              slider.scrollLeft = scrollLeft - walk;
            });
          }

          showScreen("home-screen");
        }

        init();

        // 手机尺寸控制面板折叠/展开
        const toggleSizePanelBtn = document.getElementById("toggle-size-panel-btn");
        const sizePanelContent = document.getElementById("size-panel-content");
        if (toggleSizePanelBtn && sizePanelContent) {
          let isPanelCollapsed = false;
          toggleSizePanelBtn.addEventListener("click", () => {
            isPanelCollapsed = !isPanelCollapsed;
            sizePanelContent.style.display = isPanelCollapsed ? "none" : "block";
            toggleSizePanelBtn.textContent = isPanelCollapsed ? "+" : "−";
          });
        }
      });
    </script>

    <!-- 手机尺寸控制面板 -->
    <div
      id="phone-size-control-panel"
      style="position: fixed; bottom: 20px; right: 20px; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 9999; min-width: 280px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;"
    >
      <div
        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;"
      >
        <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #333;">手机尺寸设置</h3>
        <button
          id="toggle-size-panel-btn"
          style="background: none; border: none; font-size: 20px; cursor: pointer; color: #666;"
        >
          −
        </button>
      </div>

      <div id="size-panel-content">
        <div style="margin-bottom: 15px;">
          <div
            style="display: flex; justify-content: space-between; margin-bottom: 8px;"
          >
            <label style="font-size: 14px; color: #666;">宽度</label>
            <span
              id="screen-width-value"
              style="font-size: 14px; color: #007bff; font-weight: 600;"
            >
              365px
            </span>
          </div>
          <input
            type="number"
            id="screen-width-input"
            min="320"
            max="400"
            value="365"
            class="moe-input"
            style="width: 100%; text-align: center; padding: 8px; border-radius: 6px; border: 1px solid #ddd;"
          />
        </div>

        <div style="margin-bottom: 15px;">
          <div
            style="display: flex; justify-content: space-between; margin-bottom: 8px;"
          >
            <label style="font-size: 14px; color: #666;">高度</label>
            <span
              id="screen-height-value"
              style="font-size: 14px; color: #007bff; font-weight: 600;"
            >
              680px
            </span>
          </div>
          <input
            type="number"
            id="screen-height-input"
            min="600"
            max="750"
            value="680"
            class="moe-input"
            style="width: 100%; text-align: center; padding: 8px; border-radius: 6px; border: 1px solid #ddd;"
          />
        </div>

        <div style="margin-bottom: 15px;">
          <div
            style="display: flex; justify-content: space-between; margin-bottom: 8px;"
          >
            <label style="font-size: 14px; color: #666;">垂直偏移</label>
            <span
              id="phone-offset-value"
              style="font-size: 14px; color: #007bff; font-weight: 600;"
            >
              15px
            </span>
          </div>
          <input
            type="number"
            id="phone-offset-input"
            min="-30"
            max="50"
            value="15"
            class="moe-input"
            style="width: 100%; text-align: center; padding: 8px; border-radius: 6px; border: 1px solid #ddd;"
          />
        </div>

        <button
          id="reset-phone-size-btn"
          style="width: 100%; padding: 10px; background: #f0f0f0; color: #333; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-size: 14px;"
        >
          恢复默认尺寸
        </button>
      </div>
    </div>
  </body>
</html>
